<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Referencia architektúra - Jegyzet</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="Szoftverfejlesztés multinacionális vállalatoknál">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="description.html"><strong aria-hidden="true">1.</strong> Tárgyleírás</a></li><li class="chapter-item expanded "><a href="schedule.html"><strong aria-hidden="true">2.</strong> Ütemezés</a></li><li class="chapter-item expanded "><a href="literature.html"><strong aria-hidden="true">3.</strong> Felkészülést segítő anyagok</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="lectures/software_architecture.html"><strong aria-hidden="true">3.1.</strong> Software Architecture</a></li><li class="chapter-item "><a href="lectures/daily_work.html"><strong aria-hidden="true">3.2.</strong> Daily Work, Clean Code, Version Control</a></li><li class="chapter-item "><a href="lectures/agile_scrum_kanban.html"><strong aria-hidden="true">3.3.</strong> Agile, SCRUM, Kanban</a></li><li class="chapter-item "><a href="lectures/tdd.html"><strong aria-hidden="true">3.4.</strong> TDD, Unit Testing</a></li><li class="chapter-item "><a href="lectures/legacy_code.html"><strong aria-hidden="true">3.5.</strong> Legacy Code, SOLID</a></li><li class="chapter-item "><a href="lectures/review.html"><strong aria-hidden="true">3.6.</strong> Review</a></li><li class="chapter-item "><a href="lectures/ci.html"><strong aria-hidden="true">3.7.</strong> Continuous Integration</a></li><li class="chapter-item "><a href="mindmap.html"><strong aria-hidden="true">3.8.</strong> MindMap</a></li></ol></li><li class="chapter-item expanded "><a href="software.html"><strong aria-hidden="true">4.</strong> A feladat</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="sprints/sprints.html"><strong aria-hidden="true">4.1.</strong> Sprintek</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="sprints/sprint_1.html"><strong aria-hidden="true">4.1.1.</strong> Sprint 1</a></li><li class="chapter-item "><a href="sprints/sprint_2.html"><strong aria-hidden="true">4.1.2.</strong> Sprint 2</a></li></ol></li><li class="chapter-item "><a href="sprints_old/sprints.html"><strong aria-hidden="true">4.2.</strong> Sprintek [régi]</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="sprints_old/sprint_1.html"><strong aria-hidden="true">4.2.1.</strong> Sprint 1</a></li><li class="chapter-item "><a href="sprints_old/sprint_2.html"><strong aria-hidden="true">4.2.2.</strong> Sprint 2</a></li><li class="chapter-item "><a href="sprints_old/sprint_3.html"><strong aria-hidden="true">4.2.3.</strong> Sprint 3</a></li></ol></li><li class="chapter-item "><a href="demo.html"><strong aria-hidden="true">4.3.</strong> Demók</a></li><li class="chapter-item "><a href="sprints/convoy.html"><strong aria-hidden="true">4.4.</strong> Acceptance test</a></li></ol></li><li class="chapter-item expanded "><a href="working_environment.html"><strong aria-hidden="true">5.</strong> Munkakörnyezet</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="git.html"><strong aria-hidden="true">5.1.</strong> Git</a></li><li class="chapter-item "><a href="github.html"><strong aria-hidden="true">5.2.</strong> GitHub</a></li><li class="chapter-item "><a href="developing_tools.html"><strong aria-hidden="true">5.3.</strong> Fejlesztői eszközök</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="vs_code.html"><strong aria-hidden="true">5.3.1.</strong> Visual Studio Code</a></li><li class="chapter-item "><a href="intellij_rider.html"><strong aria-hidden="true">5.3.2.</strong> IntelliJ Rider</a></li><li class="chapter-item "><a href="intellij_idea.html"><strong aria-hidden="true">5.3.3.</strong> IntelliJ IDEA (Java)</a></li><li class="chapter-item "><a href="code_formatting.html"><strong aria-hidden="true">5.3.4.</strong> Kódformázás</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="csharp_style_guide.html"><strong aria-hidden="true">5.3.4.1.</strong> C#</a></li><li class="chapter-item "><a href="java_style_guide.html"><strong aria-hidden="true">5.3.4.2.</strong> Java</a></li></ol></li></ol></li><li class="chapter-item "><a href="workflow.html"><strong aria-hidden="true">5.4.</strong> Munkafolyamat</a></li></ol></li><li class="chapter-item expanded "><a href="implementation.html"><strong aria-hidden="true">6.</strong> Implementáció</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="virtual_world.html"><strong aria-hidden="true">6.1.</strong> Virtuális világ</a></li><li class="chapter-item "><a href="physics.html"><strong aria-hidden="true">6.2.</strong> Fizika</a></li><li class="chapter-item "><a href="sensors.html"><strong aria-hidden="true">6.3.</strong> Szenzorok</a></li><li class="chapter-item "><a href="functions.html"><strong aria-hidden="true">6.4.</strong> Vezetéstámogató funkciók</a></li><li class="chapter-item expanded "><a href="reference_architecture.html" class="active"><strong aria-hidden="true">6.5.</strong> Referencia architektúra</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Jegyzet</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="referencia-architektúra"><a class="header" href="#referencia-architektúra">Referencia architektúra</a></h1>
<p>A repó található kezdeti kódot (skeleton) egységes alapot képez a félév során megvalósítandó szoftver számára, azonban nem kíván tökéletes és teljes megoldást biztosítani a feladat egyetlen elemére sem, mindösszesen példaként szolgál a következőkre:</p>
<ul>
<li>projekt struktúra</li>
<li>grafikus felület létrehozása
<ul>
<li>WPF keretrendszerrel</li>
<li>Avalonia keretrendszerrel</li>
</ul>
</li>
<li>világmodell benépesítése</li>
<li>vezérelt autó példányosítása és kiválasztása</li>
<li>képfájl betöltése projektkönyvtárból</li>
<li>világobjektumok rajzolása MVVM rendszerben</li>
<li>vezérelt autó állapotának megjelenítése a műszerfalon</li>
<li>ütemező használata</li>
<li>billentyű lenyomás és felengedés esemény kezelése</li>
<li>szenzor objektum létrehozása</li>
<li>adatcsomag küldése és fogadása a <em>Virtual Function Bus</em>-on keresztül</li>
</ul>
<!-- A fejezet további felépítse: -->
<!-- toc -->
<h2 id="Átfogó-kép"><a class="header" href="#Átfogó-kép">Átfogó kép</a></h2>
<p>A teljes szoftver moduljai <a href="sprints.html">12 user story</a>-ra vannak bontva. Az egyes modulok a teljes szoftver egy-egy komponensét valósítják meg. A legtöbb ilyen komponens a vezérelt autón belül kap majd helyet. Azonban vannak olyan komponensek (irányítás és megjelenítés), amelyek  nem csak az autón belül, de azon kívül, a keretszoftverben működnek.</p>
<p><img src="images/full_software.png" alt="" /></p>
<p>A billentyűzet események kezelése értelemszerűen a szoftverban történik, amelyet aztán a szimulált autó kezelőszerveire (gáz- és fékpedál, kormány) kell leképezni.
A megjelenítésnek pedig értelemszerűen a teljes világot, de legalábbis az autó egy környezetét kell, hogy kirajzolnia.</p>
<h2 id="virtual-function-bus"><a class="header" href="#virtual-function-bus">Virtual Function Bus</a></h2>
<p>A VirtualFunctionBus (VFB) egy kommunikációs megoldás az AutomatedCar komponensei (SystemComponent) számára. A komponensek feliratkoznak a buszra és <strong>a feliratkozás sorrendjében</strong> ciklikusan meghívásra kerül a <code>Process()</code> metódusok.</p>
<p>Ebből következik, hogy a feliratkozást az ábrán látható sorrendben kell megtenni, mivel az adatáramlásnak ilyen irányultsága van. Az ábra a kód kezdeti állapotát szemlélteti, a munka során további modulok (szenzorok, vezetés támogató rendszerek) is csatlakoznak majd. Valamint a hajtáslánc és a kormányzás modult nem kötelező ennyire élesen szétválasztani.</p>
<p><img src="plantuml/dummy_sensor_vfb.svg" alt="" /></p>
<p>Minden adatközlő modulnak létre kell hoznia egy-egy csomag (packet) típust (és vele párhuzamosan egy az olvasást biztosító interfészt), amely tartalmazza azokat az információkat amelyeket továbbítania kell. Például az input modul a pedál és kormány állásokat. A hajtáslánc a következő, kiolvassa a pedál és váltó állást, számol vele, majd visszaírja a <em>saját</em> csomagjába motor fordulatszámát és az autó sebességét, stb. Ezekre legközelebb a kormányzás modulnak lesz szüksége, az kiolvassa ugyanúgy mint az input modul kormányállás értékét, számol vele, majd visszaírja a autó adott iterációra vonatkozó elmozdulását.</p>
<h3 id="használata-általánosan"><a class="header" href="#használata-általánosan">Használata általánosan</a></h3>
<ol>
<li>Create a new package (e.g. SteeringAnglePacket)</li>
<li>Create a new interface for it (e.g. IReadonlySteeringAnglePacket)</li>
<li>Add reference to the owner component (e.g. SteeringSystem)</li>
<li>Add the interface reference to the VirtualFunctionBus</li>
<li>In the loop method of the writing componenet set the payload value of the packet</li>
<li>In the loop method of the reading compontent read the payload of the packet</li>
</ol>
<h3 id="konkrét-példán-keresztül-dummysensor"><a class="header" href="#konkrét-példán-keresztül-dummysensor">Konkrét példán keresztül: DummySensor</a></h3>
<p>A <em>DummySensor</em> egy rendkívül primitív „szenzor”: egyetlen feladata, hogy kiszámolja az egocar ás a <em>Circle</em> objektum közötti távolságot. Pontosabban az egocar és a kör referenciapont X, Y koordinátáinak különbségét. Azonban ez is teljes mértékben képes bemutatni a szenzorok működését és a buszon keresztüli adatcserét.</p>
<p>A példa szempontjából releváns komponensek viszonyát alábbi ábra szemlélteti.</p>
<p><img src="plantuml/dummy_sensor_component.svg" alt="" /></p>
<!--
```plantuml
@startuml
component [World] as world {

  component [AutomatedCar] as egocar {
    component [DummySensor] as ds
    component [VirtualFunctionBus] as vfb

    interface register as rc
  }

  component [Circle] {
  }
  
  ds -left-( rc
  vfb -right- rc
 
}

header
DummySensor component diagram
endheader

@enduml
```
-->
<p>A <em>World</em> singleton osztály tartalmaz minden <em>WorldObject</em>-et és tartalmaz referenciát a vezérelt autóra, amely közvetetten szintén <em>WorldObject</em>, csakúgy mint a <em>Circle</em>. Az <em>AutomatedCar</em> tartalmazza a <em>VirtualFunctionBus</em>-t, mivel ez az autó komponenseinek kommunikációs csatornáját valósítja meg. Szintén az <em>AutomatedCar</em> tartalmazza a szenzorokat, jelen esetben a <em>DummySensor</em>-t.</p>
<p>Ahhoz, hogy a szenzorok (vagy egyéb komponensek mint a hajtáslánc például) adatot cserélhessenek fel kell iratkozniuk a VFB-ra. Miután a feliratkozás megtörtént, a VFB minden ciklusában meghívja a <code>Porcess()</code> metódusát. A <em>DummySensor</em> esetében ez a metódus elkéri a világtól a <em>kör</em> objektumot, kiszámolja a vezérelt autó és a kör távolságát, majd ezt a távolságot eltárolja a <em>DummyPacket</em> objektumban (amely egy IReadOnlyDummyPacket típuson keresztül a VFB-ban van tárolva).</p>
<!-- A szenzor része az *AutomatedCar*-nak, közvetlenül hozzáférhet a világhoz (*World*) mivel az singleton. Lekéri a világobjektumok közül a kört (*Circle*), majd kiszámolja a koordináták különbségét a `process()` metódusban és az eredményt eltárolja az `dummyPacket` változóban. -->
<p>A <code>dummyPacket</code> referenciája eltárolásra került a <em>VirtualFunctionBus</em>ban, amely referenciáját a a szenzor konstruktorának biztosítani kell. Ehhez előzetesen létre kell hozni egy <code>IReadOnlyDummyPacket</code> típusú változót a VFB-ban.</p>
<p>Miután a <code>DummyPacket</code> megvalósítja az <code>IReadOnlyDummyPacket</code> interfészt, a VFB-ban az utóbbi típus tárolására szolgáló változó kerül deklarálásra. Ezzel biztosítható, hogy az adott értéket csak a csomag tulajdonosa (jelen esetben a <em>DummySensor</em>) tudja majd írni, de minden más komponens olvashatja a VFB-on keresztül.</p>
<!--
```plantuml
@startuml
DummySensor -> VirtualFunctionBus: registerComponent
loop
    VirtualFunctionBus -> DummySensor: Process
    activate DummySensor
    DummySensor -> World: Get Circle

    DummySensor -> DummySensor: Calculate distance from Circle
    DummySensor -> DummyPacket: Store distance
    deactivate DummySensor
end

header
DummySensor sequence diagram
endheader
@enduml
```
-->
<p><img src="plantuml/dummy_sensor_sequence.svg" alt="" /></p>
<p>Ez lejátszódik minden iterációban, így a kör és a vezérelt autó mindenkori helyzete szerinti távolságot fogja tartalmazni a <em>DummyPacket</em>.</p>
<!-- Az alábbi ábra a *DummySensor* szenpontjából fontos osztályok kapcsolatát mutatja. -->
<h3 id="osztálydiagramok"><a class="header" href="#osztálydiagramok">Osztálydiagramok</a></h3>
<!--
```plantuml
@startuml
abstract class GameBase {
    + int TicksPerSecond
    + long CurrentTick
    - DispatcherTimer _timer

    void DoTick()
    # {abstract} void Tick()
    + void Start()
    + void Stop()
}

class VirtualFunctionBus {
    - SystemComponent[] components
    - IReadOnlyDummyPacket DummyPacket
    + int getIReadOnlyDummyPacket()
    + void setIReadOnlyDummyPacket()
    + void registerComponent(SystemComponent component)
}

abstract class SystemComponent {
    # VirtualFunctionBus virtualFunctionBus
    # SystemComponent(VirtualFunctionBus virtualFunctionBus)
    + {abstract} void Process()
}

class DummySensor {
   - DummyPacket dummyPacket
}

class DummyPacket {
    - int distanceX
    - int distanceY
    + void setDistanceX()
    + int getDistanceX()
    + void setDistanceY()
    + int getDistanceY()
}

interface IReadOnlyDummyPacket {
    + int getDistanceX()
    + int getDistanceY()
}

DummySensor <|-- SystemComponent
DummySensor *-- DummyPacket
DummyPacket <-- IReadOnlyDummyPacket

VirtualFunctionBus <|-- GameBase
VirtualFunctionBus *-- "many" SystemComponent
VirtualFunctionBus *-- "1" IReadOnlyDummyPacket

header
DummySensor class diagram
endheader
@enduml
```
-->
<p><img src="plantuml/dummy_sensor_class.svg" alt="" /></p>
<!--
```plantuml
@startuml
    interface ReactiveObject {
    }
    note right: This is required to update the View in the MVVM model.\nRaiseAndSetIfChanged() method must be used in the setters.

    class World << (S, #FF7700) Singleton >> {
        - int width
        - int height
        - WorldObject[] worldObjects
        - AutomatedCar controlledCar
        + int getWidth()
        + void setWidth()
        + int getHeight()
        + void setHeight()
        + void addObject()
        + AutomatedCar getControlledCar()
        + void setControlledCar()
    }

    abstract class WorldObject {
        - int x
        - int y
        - int zIndex
        - string filename
        + int getX()
        + void setX()
        + int getY()
        + void setY()
        + string getFilename()
        + void setFilename()
    }

    class Car {
        - int speed
        + int getSpeed()
        + void setSpeed()
    }

    class AutomatedCar {
        - VirtualFunctionBus virtualFunctionBus
        - DummySensor dummySensor
        + VirtualFunctionBus getVirtualFunctionBus()
        + void Start()
        + void Stop()
    }

    AutomatedCar <|-- Car
    Car <|-- WorldObject
    WorldObject <|-- ReactiveObject
    World *-- "many" WorldObject

header
AutomatedCar class diagram
endheader
@enduml
```
-->
<p><img src="plantuml/automatedcar_class.svg" alt="" /></p>
<h2 id="megjelenítés"><a class="header" href="#megjelenítés">Megjelenítés</a></h2>
<p>Az elkészítendő szoftver felhasználói felületének az alábbi vázlat felépítését kell követnie.</p>
<p><img src="images/gui_plan.png" alt="gui plan" /></p>
<p>A programablak bal oldalán a virtuális világ egy szeletét látjuk ezért felel a vizualizációs modul. A megjelenítés középpontja az mindenkor vezérelt autó (egocar). A világ minden eleméhez tartozik egy képfájl, ezen elemek megfelelő transzformációk (forgatás, skálázás) végrehajtása után kirajzolásra kerülne a CourseDisplayre.</p>
<p>Továbbá erre a részre kerülnek kirajzolásra a debuggoláshoz és teszteléshez használandó segédobjektumok opcionálisan bekapcsolható megjelenítése. Ide tartozik a szenzorok látómezeje, a világobjektumok „poligon váza”, valamint utóbbiak eseményre történő kiemelésének lehetősége.</p>
<p>A jobb oldalon a műszerfal található. A műszerfalon nincsenek vezérlőelemek, csak megjelenítés. Az összes kapcsoló a billentyűzettel állítható, a grafikus elemeknek nem kell pl. egérrel kapcsolhatónak lenniük.</p>
<p>A fordulatszám és a sebesség legyen egy analóg órával reprezentálva; a kormány elforgatás, a gáz- és fékpedál állása progressbar-okkal szemléltethető. Az irányjelző visszajelzője és a vezetéstámogató funkciók visszajelzői lámpaszerűek, a sebességváltó állása, és a debug értékek pl. kocsi pozíciója (x, y koordináta) lehet szöveges.
A buszon közölt „utoljára látott tábla” képét ki kell tudni rajzolni (a képek rendelkezésre állnak). Legyen elkülönítve a nincs tábla eset is.</p>
<p>A megjelenítéshez tetszőleges grafikus keretrendszer választható, alább a skeleton két változatban kerül bemutatásra.</p>
<h2 id="wpf-alapú-megjelenítés"><a class="header" href="#wpf-alapú-megjelenítés">WPF alapú megjelenítés</a></h2>
<p>Az ismert WPF alapú implementáció, amely egyenértékű a később taglalt Avalonia alapú megoldással. Mindkettő XAML alapú, MVVM modellű keretrendszer, előbbi Windows-os, utóbbi platform független.</p>
<p>A főablak két UserControlt tartalmaz, az egyik a CourseDisplay, a másik a Dashboard, azért lettek szétválasztva, hogy a két komponensen dolgozó csapatoknak ne kelljen egymás munkájába nyúlkálniuk.</p>
<p>Például, alább látható a műszerfal, amely egy <em>AutomatedCar</em> objektum megjelenítését végzi. Egészen pontosan a <em>World</em>-ben tárolt <code>controlledCar</code> objektumét. A <code>ControlledCar</code> tulajdonság egy referencia az éppen vezérelt autóra (elvben lehetne a világban több <code>AutomatedCar</code> példány és ezek között váltogathatnánk is. Ilyen esetben a <code>ControlledCar</code> mindeg az aktuálisra mutat, amelyet meg akarunk jeleníteni). A <em>DashboardView</em> a <em>DashboardViewModel</em>-en keresztül a <code>controlledCar</code>-hoz van kötve.</p>
<pre><code class="language-xml">&lt;ContentControl Name="Dashboard" Content="{Binding World.ControlledCar, Mode=OneWay}" &gt;
    &lt;ContentControl.ContentTemplate&gt;
        &lt;DataTemplate DataType="{x:Type models:AutomatedCar}"&gt;
            &lt;StackPanel&gt;
                ...
            &lt;/StackPanel&gt;
        &lt;/DataTemplate&gt;
    &lt;/ContentControl.ContentTemplate&gt;
&lt;/ContentControl&gt;
</code></pre>
<p>A példakód ezt biztosítja, a feladat a konkrét visszajelzőkhöz megfelelő felületi elemek definiálása.</p>
<h3 id="coursedisplay"><a class="header" href="#coursedisplay">CourseDisplay</a></h3>
<p>A teljes CourseDisplay lényegében egy <em>ItemsControl</em>, amely a világ <code>WorldObjects</code> tulajdonságához van kötve. Ezen belül található egy <em>Canvas</em>, amire a rajzolás történik, valamint egy <em>DataTemplate</em>, amely azt írja le, hogy egy <em>WorldObject</em> típusú objektumok hogyan kell kezelni. A világelemhez tartozó képet kell kirajzolni, így tartalmaz egy <em>Image</em>-et, amelynek forrása a <em>WorldObject</em> <code>Filename</code> tulajdonsága. A <em>Converter</em> attribútumon keresztül meg lehet hívni egy függvényt, amellyel akár befolyásolni lehet a rajzolást (transzformálás).</p>
<p>A <em>WorldObject</em> -az alkalmazás szempontjából- a világ minden elemének őse, de ennél specializáltabban is lehet definiálni <em>template</em>-eket. Az alábbi kódrészlet szétbontja <em>Circle</em> és <em>AutomatedCar</em> típusokra, előbbihez nem is képet tölt be, hanem közvetlenül rajzol a <em>Canvas</em>-re. Az utóbbi esetben egyrészt a fentivel megegyező módon betölt egy képet, valamit arra kirajzol egy poligont (ez a debug funkcióknál kell majd).</p>
<pre><code class="language-xml">&lt;ItemsControl Name="CourseDisplay"
    ItemsSource="{Binding WorldObjects, Mode=OneWay}"
    Width="{Binding Width, Mode=OneWay}"
    Height="{Binding Height, Mode=OneWay}"
    HorizontalAlignment="Left" VerticalAlignment="Top"
    &gt;

     &lt;ItemsControl.ItemContainerStyle&gt;
        &lt;Style TargetType="ContentPresenter"&gt;
            &lt;Setter Property="Canvas.Left" Value="{Binding X}"/&gt;
            &lt;Setter Property="Canvas.Top" Value="{Binding Y}"/&gt;
            &lt;Setter Property="Canvas.ZIndex" Value="{Binding ZIndex}"/&gt;
        &lt;/Style&gt;
    &lt;/ItemsControl.ItemContainerStyle&gt;

    &lt;ItemsControl.ItemsPanel&gt;
        &lt;ItemsPanelTemplate&gt;
            &lt;Canvas /&gt;
        &lt;/ItemsPanelTemplate&gt;
    &lt;/ItemsControl.ItemsPanel&gt;

    &lt;ItemsControl.Resources&gt;
        &lt;DataTemplate DataType="{x:Type models:Circle}"&gt;
            &lt;Canvas&gt;
                &lt;Ellipse Fill="black" Width="{Binding Width}" Height="{Binding Height}" Panel.ZIndex="10"/&gt;
            &lt;/Canvas&gt;
        &lt;/DataTemplate&gt;
        &lt;DataTemplate DataType="{x:Type models:AutomatedCar}"&gt;
            &lt;Canvas&gt;
                &lt;Image Width="{Binding Width}" Height="{Binding Height}"
                    Source="{Binding Filename, Converter={x:Static visualization:WorldObjectTransformer.Instance}}"/&gt;
                &lt;Polyline Stroke="red" Points="{Binding Geometry.Points, Mode=OneWay}" /&gt;
            &lt;/Canvas&gt;
        &lt;/DataTemplate&gt;
    &lt;/ItemsControl.Resources&gt;
&lt;/ItemsControl&gt;
</code></pre>
<p>A skeletonban esetben az objektum nem a képet tárolja, hanem a képfájl nevét (<code>Filename</code>, ez van a Source-hoz kötve), a fájlnévből pedig egy konverter segítségével kap a megjelenítés képet.</p>
<p>Ráadásul nem is tölti be minden esetben a képfájlokat, hanem gyorsító-tárazza azokat fájlnév alapján egy <code>Dictionary</code> segítségével. A <code>WorldObjectTransformer</code> singleton, hogy ez a mechanizmus megfelelően működhessen.</p>
<pre><code class="language-csharp">public class WorldObjectTransformer : IValueConverter
{
    private static Dictionary&lt;string, BitmapImage&gt; cache = new Dictionary&lt;string, BitmapImage&gt;();

    public static WorldObjectTransformer Instance { get; } = new WorldObjectTransformer();

    static BitmapImage GetCachedImage(string filename)
    {
        if (!cache.ContainsKey(filename))
        {
            var image = new BitmapImage(new Uri($"src/AutomatedCar/Assets/WorldObjects/{filename}", UriKind.Relative));
            image.Freeze();
            cache.Add(filename, image);
        }
        return cache[filename];
    }

    public object Convert(object value, Type targetType, object parameter, CultureInfo culture) =&gt;
        GetCachedImage((string)value);
}
</code></pre>
<p>Megfigyelhető továbbá, hogy az AutomatedCar template esetében nem csak a kép van kirajzolva, hanem egy poligon ez, ez az objektum poligon váza, amelyet pl. ütközésekhez kell majd felhasználni. Előbb a kép, majd rá a polyline kerül kirajzolásra. Az ilyen poligonok megjelenítése debug funkciókét a megjelenítés feladata. A rajzolás pedig egy logikai értékhez kapcsolható...</p>
<h4 id="pozicionálás"><a class="header" href="#pozicionálás">Pozicionálás</a></h4>
<p>Megfigyelhető, hogy  a fenti példán, hogy a <code>ItemsControl.ItemContainerStyle</code> rendelkezik az objektumok pozíciójáról. Ezt CSS-szerűen működő stílusokkal lehet megadni. Az ItemsControl elemei (a WorldObject-ek) <em>X</em>, <em>Y</em> és <em>ZIndex</em> tulajdonságához van kötve a <code>ContentPresenter</code> <em>Canvas</em> <em>Left</em>, <em>Top</em> és <em>ZIndex</em> attribútuma.</p>
<p>Az alábbi ábrán látható a futó alkalmazás: bal oldalt a kezdetleges CourseDisplay, jobb oldalt a kezdetleges Dashboard. Az autó az <code>(50, 50)</code> pozícióba van kirajzolva, a kör a <code>(400, 200)</code> koordinátákra (bal felső sarokkal értendő) ezek különbségét pedig kiszámolta a <em>DummySensor</em> és leolvasható a műszerfalról.</p>
<p><img src="images/avalonia_skeleton.png" alt="" /></p>
<h2 id="avalonia-alapú-megjelenítés"><a class="header" href="#avalonia-alapú-megjelenítés">Avalonia alapú megjelenítés</a></h2>
<p>Az <a href="http://avaloniaui.net/"><em>Avalonia</em> keretrendszer</a> által is használt <a href="http://avaloniaui.net/docs/quickstart/mvvm">MVVM modell</a>ben az objektumokhoz tartozik egy definiált a megjelenítés.</p>
<p><img src="http://avaloniaui.net/docs/quickstart/images/mvvm.png" alt="" /></p>
<p>Jelen esetben például a műszerfal egy <em>AutomatedCar</em> objektum megjelenítése. Egészen pontosan a <em>World</em>-ben tárolt <code>controlledCar</code> objektumé. A <em>DashboardView</em> a <em>DashboardViewModel</em>-en keresztül a <code>controlledCar</code>-hoz van kötve.</p>
<pre><code class="language-xml">&lt;ContentControl Name="Dashboard" Content="{Binding World.ControlledCar, Mode=OneWay}" &gt;
    &lt;ContentControl.ContentTemplate&gt;
        &lt;DataTemplate DataType="{x:Type models:AutomatedCar}"&gt;
            &lt;StackPanel&gt;
                ...
            &lt;/StackPanel&gt;
        &lt;/DataTemplate&gt;
    &lt;/ContentControl.ContentTemplate&gt;
&lt;/ContentControl&gt;
</code></pre>
<p>A példakód ezt biztosítja, a feladat a konkrét visszajelzőkhöz megfelelő felületi elemek definiálása.</p>
<h3 id="coursedisplay-1"><a class="header" href="#coursedisplay-1">CourseDisplay</a></h3>
<p>A teljes CourseDisplay lényegében egy <em>ItemsControl</em>, amely a világ <code>WorldObjects</code> tulajdonságához van kötve. Ezen belül található egy <em>Canvas</em>, amire a rajzolás történik, valamint egy <em>DataTemplate</em>, amely azt írja le, hogy egy <em>WorldObject</em> típusú objektumok hogyan kell kezelni. A világelemhez tartozó képet kell kirajzolni, így tartalmaz egy <em>Image</em>-et, amelynek forrása a <em>WorldObject</em> <code>Filename</code> tulajdonsága. A <em>Converter</em> attribútumon keresztül meg lehet hívni egy függvényt, amellyel befolyásolni lehet a rajzolást (transzformálás).</p>
<pre><code class="language-xml">&lt;ItemsControl Name="CourseDisplay"
    DataContext="{Binding World, Mode=OneWay}"
    Items="{Binding WorldObjects, Mode=OneWay}"
    Width="{Binding Width, Mode=OneWay}"
    Height="{Binding Height, Mode=OneWay}"
    HorizontalAlignment="Left" VerticalAlignment="Top"
    &gt;

    &lt;ItemsControl.ItemsPanel&gt;
        &lt;ItemsPanelTemplate&gt;
            &lt;Canvas/&gt;
        &lt;/ItemsPanelTemplate&gt;
    &lt;/ItemsControl.ItemsPanel&gt;

    &lt;ItemsControl.DataTemplates&gt;
        &lt;DataTemplate DataType="{x:Type models:WorldObject}"&gt;
            &lt;Image Width="{Binding Width}" Height="{Binding Height}"
                Source="{Binding Filename, Converter={x:Static visualization:WorldObjectTransformer.Instance}}"/&gt;
        &lt;/DataTemplate&gt;
    &lt;/ItemsControl.DataTemplates&gt;
&lt;/ItemsControl&gt;
</code></pre>
<p>A <em>WorldObject</em> -az alkalmazás szempontjából- a világ minden elemének őse, de ennél specializáltabban is lehet definiálni <em>template</em>-eket. Az alábbi kódrészlet szétbontja <em>Circle</em> és <em>AutomatedCar</em> típusokra, előbbihez nem is képet tölt be, hanem közvetlenül rajzol a <em>Canvas</em>-re. Az utóbbi esetben egyrészt a fentivel megegyező módon betölt egy képet, valamit arra kirajzol egy poligont (ez a debug funkcióknál kell majd).</p>
<pre><code class="language-xml">&lt;ItemsControl.DataTemplates&gt;
    &lt;DataTemplate DataType="{x:Type models:Circle}"&gt;
        &lt;Canvas&gt;
            &lt;Ellipse Fill="black" Width="{Binding Width}" Height="{Binding Height}" ZIndex="10"/&gt;
        &lt;/Canvas&gt;
    &lt;/DataTemplate&gt;
    &lt;DataTemplate DataType="{x:Type models:AutomatedCar}"&gt;
        &lt;Canvas&gt;
            &lt;Image Width="{Binding Width}" Height="{Binding Height}"
                Source="{Binding Filename, Converter={x:Static visualization:WorldObjectTransformer.Instance}}"/&gt;
            &lt;Polyline Stroke="{Binding Brush, Mode=OneWay}" Points="{Binding Geometry.Points, Mode=OneWay}" /&gt;
        &lt;/Canvas&gt;
    &lt;/DataTemplate&gt;
&lt;/ItemsControl.DataTemplates&gt;
</code></pre>
<h4 id="pozicionálás-1"><a class="header" href="#pozicionálás-1">Pozicionálás</a></h4>
<p>Megfigyelhető, hogy  a fenti példák nem rendelkeznek az objektumok pozíciójáról. Ezt CSS-szerűen működő stílusokkal lehet megadni. Az alábbi példa beszínezi zöldre a <em>CourseDisplay</em>-t, valamint a <em>WorldObject</em>-ek <em>Left</em> és <em>Top</em> értékeit beállítja a <em>WorldObject</em> X és Y értének megfelelően.</p>
<pre><code class="language-xml">&lt;UserControl.Styles&gt;
    &lt;Style Selector="ItemsControl#CourseDisplay"&gt;
        &lt;Setter Property="Background" Value="#97D1A2"/&gt;
    &lt;/Style&gt;
    &lt;Style Selector="ItemsControl#CourseDisplay &gt; ContentPresenter"&gt;
        &lt;Setter Property="Canvas.Left" Value="{Binding X, Mode=OneWay}"/&gt;
        &lt;Setter Property="Canvas.Top" Value="{Binding Y, Mode=OneWay}"/&gt;
        &lt;Setter Property="ZIndex" Value="{Binding ZIndex, Mode=OneWay}"/&gt;
    &lt;/Style&gt;
&lt;/UserControl.Styles&gt;
</code></pre>
<p>Az utóbbi verziót használva az alábbi ábrán látható a futó alkalmazás: bal oldalt a kezdetleges CourseDisplay, jobb oldalt a kezdetleges Dashboard. Az autó az <code>(50, 50)</code> pozícióba van kirajzolva, a kör a <code>(400, 200)</code> koordinátákra (bal felső sarokkal értendő) ezek különbségét pedig kiszámolta a <em>DummySensor</em> és leolvasható a műszerfalról.</p>
<p><img src="images/avalonia_skeleton.png" alt="" /></p>
<h4 id="forgatás"><a class="header" href="#forgatás">Forgatás</a></h4>
<p>Az autó forgatása is a pozicionáláshoz hasonló elven történik. Az alábbi példában közvetlenül az egyes elem Canvas-ához csatoljuk a transzformációs utasításokat. Ez azzal is jár, hogy egyszerre lehet transzformálni a képet és a poligont is. Több transzformáció esetén fontos a <code>TransformGroup</code> használata. Például forgatás (szögben) az elem egy változójához kötve. Valamint egy X,Y eltolás az előbbi példában.</p>
<pre><code class="language-xml">&lt;DataTemplate DataType="{x:Type models:AutomatedCar}"&gt;
    &lt;Canvas&gt;
        &lt;Canvas.RenderTransform&gt;
            &lt;TransformGroup&gt;
                &lt;RotateTransform Angle="{Binding Angle}" /&gt;
                &lt;TranslateTransform  X="54" /&gt;
                &lt;TranslateTransform  Y="120" /&gt;
            &lt;/TransformGroup&gt;
        &lt;/Canvas.RenderTransform&gt;
        &lt;Image Source="{Binding Filename, Converter={x:Static visualization:WorldObjectTransformer.Instance}}"/&gt;
        &lt;Polyline Stroke="{Binding Brush, Mode=OneWay}" Points="{Binding Geometry.Points, Mode=OneWay}" /&gt;
    &lt;/Canvas&gt;
&lt;/DataTemplate&gt;
</code></pre>
<p><img src="images/rotate.png" alt="" /></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="functions.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="functions.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="context-cards.js"></script>
        <script src="mermaid-init.js"></script>
        <script src="mermaid.min.js"></script>
        <script src="d3.5.16.0.js"></script>
        <script src="markmap-lib.transform.min.js"></script>
        <script src="markmap-lib.view.min.js"></script>
        <script src="markmap-init.js"></script>
        <script src="quizdown/quizdown.js"></script>
        <script src="quizdown/quizdown-init.js"></script>


    </div>
    </body>
</html>
