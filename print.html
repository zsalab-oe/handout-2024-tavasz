<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Jegyzet</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="Szoftverfejlesztés multinacionális vállalatoknál">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="description.html"><strong aria-hidden="true">1.</strong> Tárgyleírás</a></li><li class="chapter-item expanded "><a href="schedule.html"><strong aria-hidden="true">2.</strong> Ütemezés</a></li><li class="chapter-item expanded "><a href="literature.html"><strong aria-hidden="true">3.</strong> Felkészülést segítő anyagok</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="lectures/software_architecture.html"><strong aria-hidden="true">3.1.</strong> Software Architecture</a></li><li class="chapter-item "><a href="lectures/daily_work.html"><strong aria-hidden="true">3.2.</strong> Daily Work, Clean Code, Version Control</a></li><li class="chapter-item "><a href="lectures/agile_scrum_kanban.html"><strong aria-hidden="true">3.3.</strong> Agile, SCRUM, Kanban</a></li><li class="chapter-item "><a href="lectures/tdd.html"><strong aria-hidden="true">3.4.</strong> TDD, Unit Testing</a></li><li class="chapter-item "><a href="lectures/legacy_code.html"><strong aria-hidden="true">3.5.</strong> Legacy Code, SOLID</a></li><li class="chapter-item "><a href="lectures/review.html"><strong aria-hidden="true">3.6.</strong> Review</a></li><li class="chapter-item "><a href="lectures/ci.html"><strong aria-hidden="true">3.7.</strong> Continuous Integration</a></li><li class="chapter-item "><a href="mindmap.html"><strong aria-hidden="true">3.8.</strong> MindMap</a></li></ol></li><li class="chapter-item expanded "><a href="software.html"><strong aria-hidden="true">4.</strong> A feladat</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="sprints/sprints.html"><strong aria-hidden="true">4.1.</strong> Sprintek</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="sprints/sprint_1.html"><strong aria-hidden="true">4.1.1.</strong> Sprint 1</a></li><li class="chapter-item "><a href="sprints/sprint_2.html"><strong aria-hidden="true">4.1.2.</strong> Sprint 2</a></li></ol></li><li class="chapter-item "><a href="sprints_old/sprints.html"><strong aria-hidden="true">4.2.</strong> Sprintek [régi]</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="sprints_old/sprint_1.html"><strong aria-hidden="true">4.2.1.</strong> Sprint 1</a></li><li class="chapter-item "><a href="sprints_old/sprint_2.html"><strong aria-hidden="true">4.2.2.</strong> Sprint 2</a></li><li class="chapter-item "><a href="sprints_old/sprint_3.html"><strong aria-hidden="true">4.2.3.</strong> Sprint 3</a></li></ol></li><li class="chapter-item "><a href="demo.html"><strong aria-hidden="true">4.3.</strong> Demók</a></li><li class="chapter-item "><a href="sprints/convoy.html"><strong aria-hidden="true">4.4.</strong> Acceptance test</a></li></ol></li><li class="chapter-item expanded "><a href="working_environment.html"><strong aria-hidden="true">5.</strong> Munkakörnyezet</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="git.html"><strong aria-hidden="true">5.1.</strong> Git</a></li><li class="chapter-item "><a href="github.html"><strong aria-hidden="true">5.2.</strong> GitHub</a></li><li class="chapter-item "><a href="developing_tools.html"><strong aria-hidden="true">5.3.</strong> Fejlesztői eszközök</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="vs_code.html"><strong aria-hidden="true">5.3.1.</strong> Visual Studio Code</a></li><li class="chapter-item "><a href="intellij_rider.html"><strong aria-hidden="true">5.3.2.</strong> IntelliJ Rider</a></li><li class="chapter-item "><a href="intellij_idea.html"><strong aria-hidden="true">5.3.3.</strong> IntelliJ IDEA (Java)</a></li><li class="chapter-item "><a href="code_formatting.html"><strong aria-hidden="true">5.3.4.</strong> Kódformázás</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="csharp_style_guide.html"><strong aria-hidden="true">5.3.4.1.</strong> C#</a></li><li class="chapter-item "><a href="java_style_guide.html"><strong aria-hidden="true">5.3.4.2.</strong> Java</a></li></ol></li></ol></li><li class="chapter-item "><a href="workflow.html"><strong aria-hidden="true">5.4.</strong> Munkafolyamat</a></li></ol></li><li class="chapter-item expanded "><a href="implementation.html"><strong aria-hidden="true">6.</strong> Implementáció</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="virtual_world.html"><strong aria-hidden="true">6.1.</strong> Virtuális világ</a></li><li class="chapter-item "><a href="physics.html"><strong aria-hidden="true">6.2.</strong> Fizika</a></li><li class="chapter-item "><a href="sensors.html"><strong aria-hidden="true">6.3.</strong> Szenzorok</a></li><li class="chapter-item "><a href="functions.html"><strong aria-hidden="true">6.4.</strong> Vezetéstámogató funkciók</a></li><li class="chapter-item "><a href="reference_architecture.html"><strong aria-hidden="true">6.5.</strong> Referencia architektúra</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Jegyzet</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="szoftverfejlesztés-multinacionális-vállalatoknál"><a class="header" href="#szoftverfejlesztés-multinacionális-vállalatoknál">Szoftverfejlesztés multinacionális vállalatoknál</a></h1>
<p>A tárgy keretében a hallgatók lehetőséget kapnak megtapasztalni egy multinacionális környezetben történő szoftverfejlesztés mikéntjét és kihívásait. A félév során a hallgatók egy, vezetéstámogató rendszerek működésének demonstrációjára szolgáló játék fejlesztésén keresztül megismerhetik a Scrum Agile metodológiát, kipróbálhatják a Test Driven Developmentet, elsajátíthatják a Clean Code írásának alapelveit, tapasztalatot szerezhetnek a jó Code Review végzésében, továbbá elméleti ismeretet szereznek a Software Craftsmanshipről, Agile-ról általában, a Continuous Integration-ről.</p>
<p>A tárgy kettős felépítésű - minden alkalommal elméleti előadáson mutat be egy új ismeretanyagot, amit aztán a hallgatók a gyakorlatba ültethetnek a saját csapatukon belül. A félév során kis létszámú (3-6 fős) csapatokra bontva három sprintet kell teljesíteni, minden sprintben működő szoftvert szállítani, amit a hallgatók terveznek, implementálnak, integrálnak és verifikálnak majd csapatonként mutatják be saját közreműködésüket. Ez teljes félév során órán kívüli elköteleződést és felelősségvállalást kíván a csapat (és a kurzus) sikere iránt - az értékelés jelentős részét a gyakorlati munka adja. A tárgyhoz alapszintű verziókezelési ismeretek megléte javasolt.</p>
<p>A tantárgy célja, hogy a hallgatók olyan tapasztalatot szerezzenek, amely egy tipikus multinacionális környezetben előfordul: verziókezelés (git) és feladatmenedzsment (GitHub), párhuzamos és komponens alapú szoftverfejlesztés, megrendelő fókusz, határidős fejlesztések, proaktivitás, kommunikációs és (ön)szervező készség, függőségek és blokkoló tényezők feloldása, megoldása.</p>
<h1 id="mottó"><a class="header" href="#mottó">Mottó</a></h1>
<blockquote>
<p>A designer knows he has achieved perfection not when there is nothing left to add, but when there is nothing left to take away.</p>
<p><a href="https://en.wikiquote.org/wiki/Antoine_de_Saint_Exup%C3%A9ry">Antoine de Saint-Exupéry</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Ütemezés"><a class="header" href="#Ütemezés">Ütemezés</a></h1>
<p>Az órák csütörtökönként a BA.F.06-ben vannak (távoktatásban, MS Teams-en), neptun szerint 08:00-10:35 között előadás és 10:45-11:30 között gyakorlat. (Ezek aránya valamint közte a szünet az aktuális előadásanyag és az igények szerint módosulhat). A „gyakorlat” nem labor, hanem sokkal inkább konzultáció!</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: right">hét</th><th style="text-align: center">dátum</th><th style="text-align: center">előadás</th><th style="text-align: center">gyakorlat</th></tr></thead><tbody>
<tr><td style="text-align: right">1.</td><td style="text-align: center">02. 15.</td><td style="text-align: center">Bevezető, áttekintés</td><td style="text-align: center">feladat és a munkafolyamat átfogó ismertetése, avalonia tutorial</td></tr>
<tr><td style="text-align: right">2.</td><td style="text-align: center">02. 22.</td><td style="text-align: center">Napi munka, verziókezelés</td><td style="text-align: center">git, GitHub, IDE ismertetés, warmup feladat ismertetése</td></tr>
<tr><td style="text-align: right">3.</td><td style="text-align: center">02. 29.</td><td style="text-align: center">Software Architecture I.</td><td style="text-align: center">csapatsorsolás, Sprint Planning, Design előkészítése</td></tr>
<tr><td style="text-align: right">4.</td><td style="text-align: center">03. 07.</td><td style="text-align: center">Software Architecture II.</td><td style="text-align: center">Work Breakdown Structure (WBS) és design bemutatása</td></tr>
<tr><td style="text-align: right">5.</td><td style="text-align: center">03. 14.</td><td style="text-align: center">Agile, SCRUM, Kanban</td><td style="text-align: center">konzultáció</td></tr>
<tr><td style="text-align: right">6.</td><td style="text-align: center">03. 21.</td><td style="text-align: center">Verification &amp; validation</td><td style="text-align: center">konzultáció</td></tr>
<tr><td style="text-align: right">7.</td><td style="text-align: center">03. 28.</td><td style="text-align: center">Rektori szünet</td><td style="text-align: center">konzultáció</td></tr>
<tr><td style="text-align: right">8.</td><td style="text-align: center"><strong>04. 04.</strong></td><td style="text-align: center"><strong>1. demo</strong></td><td style="text-align: center">retrospektív, Sprint Planning, Design előkészítése</td></tr>
<tr><td style="text-align: right">9.</td><td style="text-align: center">04. 11.</td><td style="text-align: center">Continuous Integration</td><td style="text-align: center">Work Breakdown Structure (WBS) és design bemutatása</td></tr>
<tr><td style="text-align: right">10.</td><td style="text-align: center">04. 18.</td><td style="text-align: center">Review culture</td><td style="text-align: center">konzultáció</td></tr>
<tr><td style="text-align: right">11.</td><td style="text-align: center">04. 25.</td><td style="text-align: center">Legacy code</td><td style="text-align: center">konzultáció</td></tr>
<tr><td style="text-align: right">12.</td><td style="text-align: center">05. 02.</td><td style="text-align: center">ASPICE in nutshell v. Guest presentation</td><td style="text-align: center">konzultáció</td></tr>
<tr><td style="text-align: right">13.</td><td style="text-align: center"><strong>05. 09.</strong></td><td style="text-align: center">Összefoglalás, <strong>2. demo</strong></td><td style="text-align: center">retrospektív, tárgy feedback</td></tr>
<tr><td style="text-align: right">14.</td><td style="text-align: center"><strong>05. 16.</strong></td><td style="text-align: center"><strong>Zárthelyi dolgozat</strong></td><td style="text-align: center"></td></tr>
</tbody></table>
</div>
<h2 id="házi-feladatok"><a class="header" href="#házi-feladatok">Házi feladatok</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Határidő (hét)</th><th>feladat</th></tr></thead><tbody>
<tr><td>2</td><td><a href="https://docs.avaloniaui.net/docs/tutorials/todo-list-app">Avalonia Tutorial teljesítése</a></td></tr>
<tr><td>3</td><td>Warmup feladat</td></tr>
<tr><td>4</td><td>design dokumentumok bemutatása (statikus és dinamikus)</td></tr>
</tbody></table>
</div>
<h2 id="gantt-diagram"><a class="header" href="#gantt-diagram">Gantt diagram</a></h2>
<div class="mermaid">
    gantt
    dateFormat  YYYY-MM-DD
    axisFormat  %m-%d
    title 2023/24 tanév II.félév
    Bemutatkozás :milestone, 2024-02-15, 1d
    section Avalonia
        Avalonia-tutorial: active, avalonia-tutorial, 2024-02-15, 1w
    section Warm-up
        Warm-up :active, warmup, 2024-02-22, 1w
    Csapat sorsolás :milestone, after warmup, 1d
    section Sprint 1
        Sprint 1 :active, sprint1, after warmup, 5w
    Demo 1 :milestone, after sprint1, 1d
    section Sprint 2
        Sprint 2 :active, sprint2, after sprint1, 5w
    Demo 2 :milestone, after sprint2, 1d
    Zárthelyi :milestone, 2024-05-16, 1d
    click sprint1 href "./sprint_1.html"
    click sprint2 href "./sprint_2.html"
</div>
<!--
# Házi feladat - 1. hét

1. GitHub fiók létrehozása
    * ha még nincs
2. 11 JDK telepítése, mivel a szoftvert Java nyelven kell elkészíteni
    * ha nincs fönt
3. Fejlesztőkörnyezet telepítése és beállítása
    * IntelliJ IDEA az ajánlott és támogatott eszköz
4. Git és GitHub oktatóanyagok elolvasása
    * ha vannak hiányosságok
    * az órán nincs idő szájbarágósan git használatot oktatni, erre vannak interaktív oktatófelületek
    * ez mindenkinek egyéni felelőssége, ám ha konkrét kérdések merülnek fel, akkor ezekre természetesen kitérünk
5. Git repó klónozása
6. Kód futtatása a futtató- és a fejlesztőkörnyezet beállításainak tesztelése céljából
7. A jegyzet és az abban taglalt segédanyagok megismerése
8. Az elkészítendő szoftver átgondolása (lásd readme), statikus és dinamikus modell elkészítése komponens szinten
    * Ennek terjedelme (az órái példa alapján): egy absztrakciós szint a négyfelé bontás (kb. user story szint), és egy az ez alatti egyel, minden komponens még egy kibontása, kb. egyenrangú komponensek létrehozására - osztály szintre nem mennék le, még ha a végén ezekből akár osztály is lesz. Szóval kettő struktúra, kettő dinamikus viselkedést leíró diagram, egy magasabb és egy alacsonyabb absztrakciós szinten. Hogy konkrétan hány building block, azt mindenkinek "érzésre" kell megállapítania, ezért szubjektív az architektúra.
    * Ez egy egyéni feladat, hiszen még nincsenek csapatok. Az elkészítéshez javasolt eszközök: MS Visio, https://www.draw.io/.
    * Az elkészült diagramoknak a következő órán bemutatható állapotban kell lenniük.
-->
<h1 id="demók"><a class="header" href="#demók">Demók</a></h1>
<p>A félév során a csapatok két alkalommal prezentálják az elvégzett munkát. A „demók” az <em>elkészült</em> szoftver megrendelőnek való bemutatását szimulálják. Nem a kódra vagyunk kíváncsiak, hanem működés közben szeretnénk látni, hogy a szoftver teljesíti feladatban foglalt követelményeket.
A bemutatás során, a <code>master</code> branchre befogadott kódot vesszük figyelembe, minden egyéb <em>„nem készült el határidőre”</em>, azaz értékelhetetlen.</p>
<p><a href="demo.html">Bővebben...</a></p>
<h1 id="zárthelyi"><a class="header" href="#zárthelyi">Zárthelyi</a></h1>
<p>Ismert, Moodle-ös teszt, 50 kérdéssel, erre 70 perc áll majd a rendelkezésre. Minden kérdéshez 4 válaszlehetőség, amelyek közül pontosan egy a helyes. (Vannak „az alábbiak közül melyik NEM helyes” felépítésű kérdések is.) A rendelkezésre álló idő alatt kérdéseket tetszőleges alkalommal felül lehet vizsgálni, módosítani a teszt „lezárása” után azonnal kiértékelésre is kerül.</p>
<h1 id="jegy-kialakítása"><a class="header" href="#jegy-kialakítása">Jegy kialakítása</a></h1>
<ol>
<li>
<p>gyakorlati jegy (sprintek átlaga) × 0.7 + ZH jegy × 0.3</p>
</li>
<li>
<p>Ha nincs gyakorlati teljesítmény, akkor a félév elégtelen, függetlenül attól, hogy a ZH hogy sikerült.</p>
</li>
<li>
<p>Mivel a sprintekre csapatok kapnak jegyet, mindenki kitölt egy csapattárs értékelő kérdőívet arról, hogy a csapaton belüli munka miképpen oszlott meg.</p>
</li>
</ol>
<p>A ZH százalék jegyre számítását az alábbi intervallumokkal végezzük:</p>
<div class="table-wrapper"><table><thead><tr><th>tól</th><th>ig</th><th>jegy</th></tr></thead><tbody>
<tr><td>0</td><td>49</td><td>1</td></tr>
<tr><td>50</td><td>59</td><td>2</td></tr>
<tr><td>60</td><td>69</td><td>3</td></tr>
<tr><td>70</td><td>79</td><td>4</td></tr>
<tr><td>80</td><td>100</td><td>5</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="felkészülést-segítő-anyagaok"><a class="header" href="#felkészülést-segítő-anyagaok">Felkészülést segítő anyagaok</a></h1>
<h2 id="ajánlott-irodalom"><a class="header" href="#ajánlott-irodalom">Ajánlott irodalom</a></h2>
<ol>
<li>The Software Craftsman: Professionalism, Pragmatism, Pride – Robert C. Martin</li>
<li>The Clean Coder: A Code of Conduct for Professional Programmers – Robert C. Martin</li>
<li>Clean Code: A Handbook of Agile Software Craftsmanship – Robert C. Martin</li>
<li>Working Effectively with Legacy Code - Michael Feathers</li>
<li>TDD by Example – Kent Beck</li>
<li>XP Explained – Kent Beck</li>
</ol>
<h2 id="online-anyagok-fejezetenként"><a class="header" href="#online-anyagok-fejezetenként">Online anyagok fejezetenként</a></h2>
<ul>
<li><a href="./lectures/agile_scrum_kanban.html">Agile, SCRUM, Kanban</a></li>
<li><a href="./lectures/daily_work.html">Daily Work, Clean Code, Version Control</a></li>
<li><a href="./lectures/tdd.html">TDD, Unit Testing</a></li>
<li><a href="./lectures/legacy_code.html">Legacy Code, SOLID</a></li>
<li><a href="./lectures/review.html">Review</a></li>
<li><a href="./lectures/ci.html">Continuous Integration</a></li>
<li><a href="./lectures/software_architecture.html">Software Architecture</a></li>
<li><a href="https://www.lhpes.com/blog/what-is-aspice-in-automotive">aSpice alapok</a></li>
</ul>
<h2 id="javasolt-felkészülési-módszer"><a class="header" href="#javasolt-felkészülési-módszer">Javasolt (fel)készülési módszer</a></h2>
<p>Mivel a diákat nem adjuk ki, célszerű jegyzetelni: <strong>címszavakat</strong>, <strong>fogalmakat</strong> leírni, gondolatmenetet rögzíteni (bár ehhez is kaptok kész anyagot az alábbi mindmap tekintetében). Nem a diát kell lekörmölni (annak ellenére sem, hogy azokat nem kaphatjátok meg), annak nincs értelme! Óra után (az óra hetében), ezekre rákeresni (pl. Google), valamint elolvasni az itteni anyagokat. A hivatkozott linkek mögötti tartalom olyan anyagmennyiséget jelent, amelyet a ZH előtti estén nem lehet feldolgozni.</p>
<h2 id="mindmap"><a class="header" href="#mindmap">Mindmap</a></h2>
<p>A témakörök „mindmap” formájú összefoglalása <a href="mm/szfmv.mm">letölthető itt</a>, megnyitáshoz a <a href="http://freemind.sourceforge.net/wiki/index.php/Main_Page">Freemind</a> nevű javás eszköz szükséges.
Vagy közvetlenül <a href="mm/szfmv.html">innen megnyitható</a> a HTML-re fordított változata.</p>
<h2 id="címszavak"><a class="header" href="#címszavak">Címszavak</a></h2>
<p>Címszavak (különösebb sorrend nélkül) amelyek az elméleti anyagot több-kevésbé lefedik. Ha valakinek ezeket a fogalmakat nem tudja kifejteni (nem tiszta mit jelent), akkor célszerű megkérdezni a Googlet vagy a Wikit. ;)</p>
<p><a href="https://en.wikipedia.org/wiki/Agile_software_development" data-wiki-lang="en" data-wiki-title="Agile software development">agile</a>,
<a href="https://en.wikipedia.org/wiki/Agile_software_development#The_Agile_Manifesto">agile manifesto</a>,
<a href="https://en.wikipedia.org/wiki/Software_craftsmanship" data-wiki-lang="en" data-wiki-title="Software craftsmanship">software craftmanship</a>,
<a href="https://en.wikipedia.org/wiki/Scrum_(software_development)" data-wiki-lang="en" data-wiki-title="Scrum (software development)">SCRUM</a>,
<a href="https://en.wikipedia.org/wiki/User_story" data-wiki-lang="en" data-wiki-title="User story">user story</a>,
backlog (<a href="https://en.wikipedia.org/wiki/Scrum_(software_development)#Product_backlog">product backlog</a> vs. <a href="https://en.wikipedia.org/wiki/Scrum_(software_development)#Sprint_backlog">sprint backlog</a>; ki szerkeszti?),
task (hossza, elemei),
<a href="https://en.wikipedia.org/wiki/Scrum_(software_development)#Sprint">sprint</a> (hossza),
<a href="https://en.wikipedia.org/wiki/Scrum_(software_development)#Sprint_review">sprint review</a>,
<a href="https://en.wikipedia.org/wiki/Scrum_(software_development)#Sprint_planning">sprint planning</a>,
<a href="https://en.wikipedia.org/wiki/Burn_down_chart" data-wiki-lang="en" data-wiki-title="Burn down chart">burndown chart</a>,
<a href="https://en.wikipedia.org/wiki/Scrum_(software_development)#Scrum_of_scrums">scrum of scrums</a>,
<a href="https://en.wikipedia.org/wiki/Business_value" data-wiki-lang="en" data-wiki-title="Business value">business value</a>,
story point,
<a href="https://en.wikipedia.org/wiki/Stand-up_meeting" data-wiki-lang="en" data-wiki-title="Stand-up meeting">standup</a> (hossza, mikor van, ki vesz rajta részt, 3 kérdés),
blocking issue,
<a href="https://en.wikipedia.org/wiki/Scrum_(software_development)#Sprint_retrospective">retro(spective)</a>,
<a href="https://en.wikipedia.org/wiki/Scrum_(software_development)#Backlog_refinement">backlog refinement</a> (aka backlog grooming),
demo,
daily cycle,
clean code,
traceability (eszkaláció),
<a href="https://en.wikipedia.org/wiki/Version_control" data-wiki-lang="en" data-wiki-title="Version control">version control</a> (elosztott vs. centralizált),
<a href="https://en.wikipedia.org/wiki/Code_refactoring" data-wiki-lang="en" data-wiki-title="Code refactoring">refactoring</a>,
review (informal, walkthrough, technical, inspection),
<a href="https://en.wikipedia.org/wiki/Pair_programming" data-wiki-lang="en" data-wiki-title="Pair programming">pair programming</a>,
scrum team tagjai: <a href="https://en.wikipedia.org/wiki/Scrum_(software_development)#Scrum_master">scrum master</a>, <a href="https://en.wikipedia.org/wiki/Scrum_(software_development)#Product_owner">product owner</a>, <a href="https://en.wikipedia.org/wiki/Scrum_(software_development)#Development_team">development team</a>,
<a href="https://en.wikipedia.org/wiki/Cross-functional_team" data-wiki-lang="en" data-wiki-title="Cross-functional team">cross functional team</a>,
self-organizing team,
stakeholder,
<a href="https://en.wikipedia.org/wiki/Kanban_(development)" data-wiki-lang="en" data-wiki-title="Kanban (development)">kanban</a>,
scrumban,
<a href="https://en.wikipedia.org/wiki/Waterfall_model" data-wiki-lang="en" data-wiki-title="Waterfall model">waterfall</a>,
<a href="https://en.wikipedia.org/wiki/V-Model_(software_development)" data-wiki-lang="en" data-wiki-title="V-Model (software development)">v-model</a>,
<a href="https://en.wikipedia.org/wiki/Scrum_(software_development)#Scrum_of_scrums">scrum of scrums</a> (ambassador),
<a href="https://en.wikipedia.org/wiki/Test-driven_development" data-wiki-lang="en" data-wiki-title="Test-driven development">Test-driven development</a>,
(software) unit,
<a href="https://en.wikipedia.org/wiki/Unit_testing" data-wiki-lang="en" data-wiki-title="Unit testing">unit testing</a> (arrange, act, assert, annihilate),
test suite,
test case,
<a href="https://en.wikipedia.org/wiki/Quality_assurance" data-wiki-lang="en" data-wiki-title="Quality assurance">quality assurance</a>,
<a href="http://vinaikopp.com/2016/02/09/about_code_katas/">coding kata</a>,
<a href="https://en.wikipedia.org/wiki/Code_golf" data-wiki-lang="en" data-wiki-title="Code golf">code golf</a>,
<a href="https://en.wikipedia.org/wiki/Legacy_code#Modern_interpretations">legacy code</a>,
<a href="https://en.wikipedia.org/wiki/Code_smell" data-wiki-lang="en" data-wiki-title="Code smell">code smell</a>,
rotting code,
dependency reduction,
seams,
<a href="https://en.wikipedia.org/wiki/Continuous_integration" data-wiki-lang="en" data-wiki-title="Continuous integration">Continuous integration</a>,
<a href="https://en.wikipedia.org/wiki/Test_automation" data-wiki-lang="en" data-wiki-title="Test automation">Test automation</a>,
<a href="https://en.wikipedia.org/wiki/Continuous_deployment" data-wiki-lang="en" data-wiki-title="Continuous deployment">Continuous deployment</a>,
minimized context switch,
<a href="https://en.wikipedia.org/wiki/DevOps" data-wiki-lang="en" data-wiki-title="DevOps">DevOps</a>,
coding dojo,
<a href="https://en.wikipedia.org/wiki/SOLID" data-wiki-lang="en" data-wiki-title="SOLID">SOLID priciples</a>,
clean code,
<a href="https://en.wikipedia.org/wiki/Scrum_(software_development)#Definition_of_done_(DoD)">definition of done</a>,
milestone,
deadline,
mocking (dummy, stub, spy, mock, fake),
requirement,
<a href="https://en.wikipedia.org/wiki/Requirements_engineering" data-wiki-lang="en" data-wiki-title="Requirements engineering">requirement engineering</a>,
centralized version control,
<a href="https://en.wikipedia.org/wiki/Distributed_version_control" data-wiki-lang="en" data-wiki-title="Distributed version control">distributed version control</a>,
traceability, finding, bug fixing, optimizing, feature envy,
<a href="https://en.wikipedia.org/wiki/KISS_principle" data-wiki-lang="en" data-wiki-title="KISS principle">KISS</a>,
<a href="https://en.wikipedia.org/wiki/Programming_complexity" data-wiki-lang="en" data-wiki-title="Programming complexity">code complexity</a>,
<a href="https://en.wikipedia.org/wiki/Cyclomatic_complexity" data-wiki-lang="en" data-wiki-title="Cyclomatic complexity">cyclomatic complexity</a>,
<a href="https://en.wikipedia.org/wiki/Regression_testing" data-wiki-lang="en" data-wiki-title="Regression testing">regression test</a>,
<a href="https://thenewstack.io/deployment-strategies">deployment strategies/shadow deploy</a>,
teszt stratégiák (top-down, bottom-up, sandwich, big-bang, risky-hardest),
<a href="https://en.wikipedia.org/wiki/Black-box_testing" data-wiki-lang="en" data-wiki-title="Black-box testing">black-box testing</a>,
<a href="https://en.wikipedia.org/wiki/White-box_testing" data-wiki-lang="en" data-wiki-title="White-box testing">white-box testing</a>,
<a href="https://en.wikipedia.org/wiki/Gray_box_testing" data-wiki-lang="en" data-wiki-title="Gray box testing">gray-box testing</a>,
<a href="https://en.wikipedia.org/wiki/Daily_build" data-wiki-lang="en" data-wiki-title="Nightly build">nightly build</a>,
<a href="https://en.wikipedia.org/wiki/Hardware-in-the-loop_simulation" data-wiki-lang="en" data-wiki-title="Hardware-in-the-loop simulation">hardware in the loop (HIL)</a>,
<a href="http://redpine.com.tr/software-in-the-loop-sil.html">software in the loop (SIL)</a>,
<a href="https://en.wikipedia.org/wiki/SMART_criteria" data-wiki-lang="en" data-wiki-title="SMART criteria">SMART objectives</a>,
<a href="https://en.wikipedia.org/wiki/Technical_debt" data-wiki-lang="en" data-wiki-title="Technical debt">technical debt</a>,
<a href="https://en.wikipedia.org/wiki/Cost_estimation_in_software_engineering" data-wiki-lang="en" data-wiki-title="Effort estimation">effort estimation</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="software-architecture"><a class="header" href="#software-architecture">Software Architecture</a></h1>
<!-- toc -->
<h2 id="growing-software"><a class="header" href="#growing-software">Growing software</a></h2>
<p>Linux kernel - number of lines of code (forrás: <a href="https://en.wikipedia.org/wiki/Linux_kernel">Wikipedia</a>)</p>
<p><img src="lectures/../images/linux_kernel_loc.png" alt="" title="Linux kernel - number of lines of code" /></p>
<ul>
<li><a href="https://www.linux.com/news/why-linuxs-biggest-ever-kernel-release-is-really-no-big-deal/">Why Linux’s biggest ever kernel release is really no big deal</a>
<ul>
<li>Linux 5.8 features over 14,000 non-merge commits, some 800,000 new lines of code, and added around a hundred new contributors.</li>
</ul>
</li>
</ul>
<p><img src="https://s.yimg.com/ny/api/res/1.2/up437vRgY_hH6IXyJKtnMA--~A/YXBwaWQ9aGlnaGxhbmRlcjtzbT0xO3c9NjUwO2g9NjAx/http://globalfinance.zenfs.com/en_us/Finance/US_AFTP_SILICONALLEY_H_LIVE/Googles_services_are_powered_by-af07bc22a8b413a9049fd5c7514120be" alt="" /></p>
<ul>
<li><a href="https://www.informationisbeautiful.net/visualizations/million-lines-of-code/">Teljesebb összehasonlítás</a></li>
</ul>
<p><img src="https://media-exp1.licdn.com/dms/image/C5612AQH7gNeeKaTNmw/article-inline_image-shrink_1000_1488/0?e=1603929600&amp;v=beta&amp;t=ATCHNcp6I4KDurgt0Iy_zaM3Kt0tdgDa5FUHfuDH2eI" alt="" /></p>
<ul>
<li><a href="https://www.linkedin.com/pulse/20140626152045-3625632-car-software-100m-lines-of-code-and-counting">Az autóipar tekintetében</a></li>
</ul>
<h3 id="the-more-the-better"><a class="header" href="#the-more-the-better">The more, the better?</a></h3>
<blockquote>
<p>if we wish to count lines of code, we should not regard them as "lines produced" but as "lines spent"</p>
<p>E.W. Dijkstra <a href="https://www.cs.utexas.edu/users/EWD/transcriptions/EWD10xx/EWD1036.html">EWD 1036</a></p>
</blockquote>
<hr />
<blockquote>
<p>Every line of code written comes at a price: maintenance. To avoid paying for a lot of code, we build reusable software. The problem with code re-use is that it gets in the way of changing your mind later on.</p>
<p>tef - <a href="https://programmingisterrible.com/post/139222674273/write-code-that-is-easy-to-delete-not-easy-to">Write code that is easy to delete, not easy to extend</a></p>
</blockquote>
<h2 id="complex-software"><a class="header" href="#complex-software">Complex Software</a></h2>
<p><img src="https://miro.medium.com/max/1248/0*hZLEb6SYbTH8n3l8.png" alt="" /></p>
<ul>
<li><a href="https://www.simplethread.com/software-complexity-killing-us/">Software Complexity Is Killing Us</a></li>
<li><a href="https://carlalexander.ca/what-is-software-complexity/">What is software complexity and how can you manage it?</a></li>
</ul>
<h3 id="how-to-measure---cyclomatic-complexity"><a class="header" href="#how-to-measure---cyclomatic-complexity">How to measure? - Cyclomatic complexity</a></h3>
<blockquote>
<p><em>Cyclomatic complexity</em> measures the number of linearly independent paths through the method, which is determined by the number and complexity of conditional branches. A low cyclomatic complexity generally indicates a method that is easy to understand, test, and maintain. The cyclomatic complexity is calculated from a control flow graph of the method and is given as follows:</p>
<p>cyclomatic complexity = the number of edges - the number of nodes + 1</p>
<p>where a node represents a logic branch point and an edge represents a line between nodes.</p>
<p>The rule reports a violation when the cyclomatic complexity is more than 25.</p>
<p><a href="https://docs.microsoft.com/hu-hu/visualstudio/code-quality/ca1502-avoid-excessive-complexity?view=vs-2015&amp;redirectedfrom=MSDN">CA1502: Avoid excessive complexity</a></p>
</blockquote>
<!-- ![](https://carlalexander.ca/app/uploads/2018/02/control-graph-paths.png) -->
<h3 id="issues-with-cyclomatic-complexity"><a class="header" href="#issues-with-cyclomatic-complexity">Issues with cyclomatic complexity</a></h3>
<ul>
<li>Not every statement is equal
<ul>
<li><code>if</code>, <code>while</code>, <code>for</code> and <code>case</code> statements considered as identical</li>
</ul>
</li>
<li>Nesting
<ul>
<li>it doesn’t account for nesting</li>
</ul>
</li>
</ul>
<h3 id="npath-complexity"><a class="header" href="#npath-complexity">NPATH complexity</a></h3>
<blockquote>
<p>The NPath complexity of a method is the number of acyclic execution paths through that method. A threshold of 200 is generally considered the point where measures should be taken to reduce complexity.</p>
<p><a href="http://phpmd.org/rules/codesize.html#npathcomplexity">NPathComplexity</a></p>
</blockquote>
<blockquote>
<p>Consider writing a unit test and you have a function with an NPath complexity of 16. This means that if you need want 100% code coverage you need to test for 16 possible outcomes and that would end up in pretty messy tests.</p>
<p>Niklas Modess - <a href="https://modess.io/npath-complexity-cyclomatic-complexity-explained/">NPath complexity and cyclomatic complexity explained</a></p>
</blockquote>
<!-- ```java
//Cyclomatic Complexity = 3. Npath Complexity = 4.
public int compare(a, b) {
  if (a > b) {
    return a;
  } else {
    return b;
  }
}
```

Above code can be rewritten as below:

```java
//Cyclomatic Complexity = 2. Npath Complexity = 2.
public int compare(a, b) {
  if (a > b) {
    return a;
  }
  return b;
}
``` -->
<ul>
<li><a href="https://audiolion.github.io/python/2016/10/17/reducing-cyclomatic-complexity.html">Reducing Cyclomatic Complexity with Python</a></li>
<li><a href="https://modess.io/npath-complexity-cyclomatic-complexity-explained/">NPath complexity and cyclomatic complexity explained</a></li>
</ul>
<!-- - [Simplify your Python Code: Automating Code Complexity Analysis with Wily](https://towardsdatascience.com/simplify-your-python-code-automating-code-complexity-analysis-with-wily-5c1e90c9a485) -->
<h3 id="complex-vs-complicated"><a class="header" href="#complex-vs-complicated">Complex vs. complicated</a></h3>
<p>Michael Bykovski: <a href="https://medium.com/better-programming/simple-vs-complicated-vs-complex-vs-chaos-737b5964849d">Simple vs. Complicated vs. Complex vs. Chaotic</a></p>
<h3 id="complexity-accidental-vs-essential"><a class="header" href="#complexity-accidental-vs-essential">Complexity: Accidental vs. Essential</a></h3>
<blockquote>
<p><strong>Accidental Complexity</strong> is something that can be simplified by a new idea, design, technique, procedure or approach. <strong>Essential Complexity</strong> is something that can't be simpler or something that loses value when it becomes simpler. Identifying the difference between accidental and essential complexity is a fundamental design technique.</p>
<p>John Spacey - <a href="https://simplicable.com/new/accidental-complexity-vs-essential-complexity">Complexity: Accidental vs. Essential</a></p>
</blockquote>
<h2 id="what-is-software-architecture"><a class="header" href="#what-is-software-architecture">What is Software Architecture</a></h2>
<blockquote>
<p>"Architecture" is a term that lots of people try to define, with little agreement. There are two common elements: One is the highest-level breakdown of a system into its parts; the other, decisions that are hard to change.</p>
<p>Martin Fowler - Patterns of Enterprise Application Architecture</p>
</blockquote>
<blockquote>
<p>All architecture is design but not all design is architecture. Architecture represents the significant design decisions that shape a system, where significant is measured by cost of change.</p>
<p>Grady Booch</p>
</blockquote>
<blockquote>
<p>In most successful software projects, the expert developers working on that project have a shared understanding of the system design. This shared understanding is called ‘architecture.’ This understanding includes how the system is divided into components and how the components interact through interfaces. These components are usually composed of smaller componnets, but the architecture only includes the components and interfaces that are understood by all the developers.</p>
<p>Ralph Johnson, XP mailing list</p>
</blockquote>
<ul>
<li><a href="https://www.developerfusion.com/article/84899/what-is-software-architecture/">What is Software Architecture?</a></li>
<li><a href="https://medium.com/docplanner-tech/the-goals-of-software-architecture-a3b0a0edeb0b">The goals of Software Architecture</a></li>
</ul>
<h2 id="miért-kell-ez"><a class="header" href="#miért-kell-ez">Miért kell ez?</a></h2>
<blockquote>
<p>Architecture is the decisions that you wish you could get right early in a project</p>
<p>-- Ralph Johnson</p>
</blockquote>
<ul>
<li>https://gbksoft.com/blog/why-you-need-a-software-architect-for-your-project/</li>
<li>https://www.martinfowler.com/articles/designDead.html#SoIsDesignDead</li>
<li>https://www.codeproject.com/Articles/1064240/Introduction-to-Software-Architecture</li>
</ul>
<h2 id="hogyan-lesz-egy-ilyenünk"><a class="header" href="#hogyan-lesz-egy-ilyenünk">Hogyan lesz egy ilyenünk?</a></h2>
<!-- goals requiremets contstraint -->
<ul>
<li><a href="https://medium.com/@mbue/practical-tips-on-software-architecture-design-part-one-1c6bb0167157">Practical Tips on Software Architecture Design, Part One</a></li>
<li><a href="https://medium.com/@mbue/practical-tips-on-software-architecture-design-part-two-37c2b61d7b6d">Practical Tips on Software Architecture Design, Part Two</a></li>
</ul>
<h3 id="architecture-decision-records"><a class="header" href="#architecture-decision-records">Architecture decision records</a></h3>
<ul>
<li><a href="https://github.blog/2020-08-13-why-write-adrs/">Why Write ADRs</a></li>
<li><a href="https://github.com/joelparkerhenderson/architecture_decision_record">néhány ADR sablon</a></li>
</ul>
<p>Alább látható a Michael Nygard féle sablon: <a href="https://cognitect.com/blog/2011/11/15/documenting-architecture-decisions">Documenting Architecture Decisions</a></p>
<pre><code class="language-markdown"># ADR template by Michael Nygard

This is the template in [Documenting architecture decisions - Michael Nygard](http://thinkrelevance.com/blog/2011/11/15/documenting-architecture-decisions).
You can use [adr-tools](https://github.com/npryce/adr-tools) for managing the ADR files.

In each ADR file, write these sections:

# Title

## Status

What is the status, such as proposed, accepted, rejected, deprecated, superseded, etc.?

## Context

What is the issue that we're seeing that is motivating this decision or change?

## Decision

What is the change that we're proposing and/or doing?

## Consequences

What becomes easier or more difficult to do because of this change?
</code></pre>
<h2 id="design-principles"><a class="header" href="#design-principles">Design Principles</a></h2>
<p><img src="https://user-images.githubusercontent.com/6892666/65833569-bb34fc00-e29f-11e9-8516-79cbd9f8f07b.png" alt="" /></p>
<ul>
<li><a href="https://khalilstemmler.com/articles/software-design-architecture/full-stack-software-design/">How to Learn Software Design and Architecture</a>
<ul>
<li>fenti kép forrása</li>
</ul>
</li>
<li><a href="lectures/./legacy_code.html#SOLID">SOLID</a></li>
<li><a href="https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it">YAGNI</a>
<ul>
<li>"You aren't gonna need it"</li>
<li>
<blockquote>
<p>Always implement things when you actually need them, never when you just foresee that you need them.</p>
<p>Ron Jeffries</p>
</blockquote>
</li>
<li>TDD</li>
</ul>
</li>
</ul>
<h3 id="4c-complete-compliant-clear-concise"><a class="header" href="#4c-complete-compliant-clear-concise">4C: Complete, Compliant, Clear, Concise</a></h3>
<ul>
<li><a href="https://www.govwebworks.com/2017/05/01/four-cs-for-flawless-agile-business-requirements/">Four Cs for Flawless Agile Business Requirements</a></li>
<li>https://www.mojotech.com/blog/the-4cs-a-code-review-mnemonic/</li>
</ul>
<!-- ###

if two developer should think of the same answer for theri separete question, independently, it belongs in architecture

requirement engineering vs. software architecture
problématér beli definíció vs. probléma és megoldás között lépked, egyre alacsonyabb szintű problémát generálva oldja meg a magas szintűt

risk management: elemezzük a kockázatokat, kitaláljuk, hogy hogyan kezelnénk, majd minden módosítsnál felülértékeljük.

min 2 alternatíve leírva és átgondolva, hogy miért nem azokat választottuk
miért kérdésre a válaszra

https://sceweb.uhcl.edu/helm/RationalUnifiedProcess/process/modguide/md_sad.htm#Architectural%20Goals%20and%20Constraints -->
<h3 id="rob-pikes-5-rules-of-programming"><a class="header" href="#rob-pikes-5-rules-of-programming"><a href="https://en.wikipedia.org/wiki/Rob_Pike" data-wiki-lang="en" data-wiki-title="Rob Pike">Rob Pike</a>'s 5 Rules of Programming</a></h3>
<ol>
<li>You can't tell where a program is going to spend its time. Bottlenecks occur in surprising places, so don't try to second guess and put in a speed hack until you've proven that's where the bottleneck is.</li>
<li>Measure. Don't tune for speed until you've measured, and even then don't unless one part of the code overwhelms the rest.</li>
<li>Fancy algorithms are slow when n is small, and n is usually small. Fancy algorithms have big constants. Until you know that n is frequently going to be big, don't get fancy. (Even if n does get big, use Rule 2 first.)</li>
<li>Fancy algorithms are buggier than simple ones, and they're much harder to implement. Use simple algorithms as well as simple data structures.</li>
<li>Data dominates. If you've chosen the right data structures and organized things well, the algorithms will almost always be self-evident. Data structures, not algorithms, are central to programming.</li>
</ol>
<p>Pike's rules 1 and 2 restate Tony Hoare's famous maxim "Premature optimization is the root of all evil." Ken Thompson rephrased Pike's rules 3 and 4 as "When in doubt, use brute force.". Rules 3 and 4 are instances of the design philosophy KISS. Rule 5 was previously stated by Fred Brooks in The Mythical Man-Month. Rule 5 is often shortened to "write stupid code that uses smart objects".</p>
<p><a href="http://users.ece.utexas.edu/~adnan/pike.html">forrás</a></p>
<h3 id="zen-of-python1"><a class="header" href="#zen-of-python1">Zen of Python[^1]</a></h3>
<blockquote>
<p>The Zen of Python is a collection of 19 "guiding principles" for writing computer programs that influence the design of the Python programming language. [^2]</p>
</blockquote>
<ol>
<li>Beautiful is better than ugly.</li>
<li>Explicit is better than implicit.</li>
<li>Simple is better than complex.</li>
<li>Complex is better than complicated.</li>
<li>Flat is better than nested.</li>
<li>Sparse is better than dense.</li>
<li>Readability counts.</li>
<li>Special cases aren't special enough to break the rules.</li>
<li>Although practicality beats purity.</li>
<li>Errors should never pass silently.</li>
<li>Unless explicitly silenced.</li>
<li>In the face of ambiguity, refuse the temptation to guess.</li>
<li>There should be one-- and preferably only one --obvious way to do it.</li>
<li>Although that way may not be obvious at first unless you're Dutch.</li>
<li>Now is better than never.</li>
<li>Although never is often better than <em>right</em> now.</li>
<li>If the implementation is hard to explain, it's a bad idea.</li>
<li>If the implementation is easy to explain, it may be a good idea.</li>
<li>Namespaces are one honking great idea -- let's do more of those!</li>
</ol>
<ul>
<li>[^1] <a href="https://www.python.org/dev/peps/pep-0020/">PEP 20</a></li>
<li>[^2] <a href="https://en.wikipedia.org/wiki/Zen_of_Python">wiki://Zen of Python</a></li>
</ul>
<h3 id="zen-of-zyg3"><a class="header" href="#zen-of-zyg3">Zen of Zyg[^3]</a></h3>
<ul>
<li>Communicate intent precisely.</li>
<li>Edge cases matter.</li>
<li>Favor reading code over writing code.</li>
<li>Only one obvious way to do things.</li>
<li>Runtime crashes are better than bugs.</li>
<li>Compile errors are better than runtime crashes.</li>
<li>Incremental improvements.</li>
<li>Avoid local maximums.</li>
<li>Reduce the amount one must remember.</li>
<li>Focus on code rather than style.</li>
<li>Resource allocation may fail; resource deallocation must succeed.</li>
<li>Memory is a resource.</li>
<li>Together we serve the users.</li>
</ul>
<p>[^3] https://ziglang.org/documentation/0.8.0/#Zen</p>
<h3 id="the-23-gang-of-four-design-patterns"><a class="header" href="#the-23-gang-of-four-design-patterns">The 23 Gang of Four Design Patterns</a></h3>
<p><a href="http://www.blackwasp.co.uk/GofPatterns.aspx">Teljes összefoglaló</a>, ahol mindegyikhez van magyarázat, UML diagram és C# kód.</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody>
<tr><td><img src="lectures/../images/c.png" alt="" /></td><td><a href="http://www.blackwasp.co.uk/AbstractFactory.aspx">Abstract Factory</a></td><td><img src="lectures/../images/s.png" alt="" /></td><td><a href="http://www.blackwasp.co.uk/Facade.aspx">Facade</a></td><td><img src="lectures/../images/s.png" alt="" /></td><td><a href="http://www.blackwasp.co.uk/Proxy.aspx">Proxy</a></td></tr>
<tr><td><img src="lectures/../images/s.png" alt="" /></td><td><a href="http://www.blackwasp.co.uk/Adapter.aspx">Adapter</a></td><td><img src="lectures/../images/c.png" alt="" /></td><td><a href="http://www.blackwasp.co.uk/FactoryMethod.aspx">Factory Method</a></td><td><img src="lectures/../images/b.png" alt="" /></td><td><a href="http://www.blackwasp.co.uk/Observer.aspx">Observer</a></td></tr>
<tr><td><img src="lectures/../images/s.png" alt="" /></td><td><a href="http://www.blackwasp.co.uk/Bridge.aspx">Bridge</a></td><td><img src="lectures/../images/s.png" alt="" /></td><td><a href="http://www.blackwasp.co.uk/Flyweight.aspx">Flyweight</a></td><td><img src="lectures/../images/c.png" alt="" /></td><td><a href="http://www.blackwasp.co.uk/Singleton.aspx">Singleton</a></td></tr>
<tr><td><img src="lectures/../images/c.png" alt="" /></td><td><a href="http://www.blackwasp.co.uk/Builder.aspx">Builder</a></td><td><img src="lectures/../images/b.png" alt="" /></td><td><a href="http://www.blackwasp.co.uk/Interpreter.aspx">Interpreter</a></td><td><img src="lectures/../images/b.png" alt="" /></td><td><a href="http://www.blackwasp.co.uk/State.aspx">State</a></td></tr>
<tr><td><img src="lectures/../images/b.png" alt="" /></td><td><a href="http://www.blackwasp.co.uk/ChainOfResponsibility.aspx">Chain of Responsibility</a></td><td><img src="lectures/../images/b.png" alt="" /></td><td><a href="http://www.blackwasp.co.uk/Iterator.aspx">Iterator</a></td><td><img src="lectures/../images/b.png" alt="" /></td><td><a href="http://www.blackwasp.co.uk/Strategy.aspx">Strategy</a></td></tr>
<tr><td><img src="lectures/../images/b.png" alt="" /></td><td><a href="http://www.blackwasp.co.uk/Command.aspx">Command</a></td><td><img src="lectures/../images/b.png" alt="" /></td><td><a href="http://www.blackwasp.co.uk/Mediator.aspx">Mediator</a></td><td><img src="lectures/../images/b.png" alt="" /></td><td><a href="http://www.blackwasp.co.uk/TemplateMethod.aspx">Template Method</a></td></tr>
<tr><td><img src="lectures/../images/s.png" alt="" /></td><td><a href="http://www.blackwasp.co.uk/Composite.aspx">Composite</a></td><td><img src="lectures/../images/b.png" alt="" /></td><td><a href="http://www.blackwasp.co.uk/Memento.aspx">Memento</a></td><td><img src="lectures/../images/b.png" alt="" /></td><td><a href="http://www.blackwasp.co.uk/Visitor.aspx">Visitor</a></td></tr>
<tr><td><img src="lectures/../images/s.png" alt="" /></td><td><a href="http://www.blackwasp.co.uk/Decorator.aspx">Decorator</a></td><td><img src="lectures/../images/c.png" alt="" /></td><td><a href="http://www.blackwasp.co.uk/Prototype.aspx">Prototype</a></td><td></td><td></td></tr>
</tbody></table>
</div><!-- ![](../images/design_patterns.png "The Gang of Four Design Patterns") -->
<p><img src="lectures/../images/design_patterns_legend.png" alt="" /></p>
<h3 id="topologies"><a class="header" href="#topologies">Topologies</a></h3>
<p><a href="https://www.codeproject.com/Articles/1064240/Introduction-to-Software-Architecture">Introduction to Software Architecture</a></p>
<h4 id="layered-architechture"><a class="header" href="#layered-architechture">Layered Architechture</a></h4>
<p><img src="http://1.bp.blogspot.com/-TbA8p6DWYJc/Uc0zYwSG_iI/AAAAAAAAAag/cPytbL6oeM4/s800/layered.png" alt="" /></p>
<ul>
<li><a href="http://serena-yeoh.blogspot.com/2013/06/layered-architecture-for-net.html">Layered Architecture: Introduction</a></li>
<li><a href="http://serena-yeoh.blogspot.com/2014/01/layered-architecture-components.html">Layered Architecture: Component Interactions</a></li>
</ul>
<h4 id="message-bus-architecture"><a class="header" href="#message-bus-architecture">Message Bus Architecture</a></h4>
<p><img src="https://www.codeproject.com/KB/architecture/1064240/message-bus.gif" alt="" /></p>
<h4 id="server-client-architecture"><a class="header" href="#server-client-architecture">Server-Client Architecture</a></h4>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/c9/Client-server-model.svg/1200px-Client-server-model.svg.png" alt="" /></p>
<h2 id="c4-model"><a class="header" href="#c4-model">C4 model</a></h2>
<ul>
<li><a href="https://c4model.com/">The C4 model for visualising software architecture</a>
<ul>
<li>Context, Containers, Components and Code</li>
</ul>
</li>
<li><a href="https://www.infoq.com/articles/C4-architecture-model/">The C4 Model for Software Architecture</a></li>
</ul>
<h3 id="level-1-system-context-diagram"><a class="header" href="#level-1-system-context-diagram">Level 1: System Context diagram</a></h3>
<blockquote>
<p>Shows the software system you are building and how it fits into the world in terms of the people who use it and the other software systems it interacts with.</p>
<p>Simon Brown - <a href="https://www.infoq.com/articles/C4-architecture-model/">The C4 Model for Software Architecture</a></p>
</blockquote>
<h3 id="level-2-container-diagram"><a class="header" href="#level-2-container-diagram">Level 2: Container diagram</a></h3>
<blockquote>
<p>Zooms into the software system, and shows the containers (applications, data stores, microservices, etc.) that make up that software system. Technology decisions are also a key part of this diagram.</p>
<p>Simon Brown - <a href="https://www.infoq.com/articles/C4-architecture-model/">The C4 Model for Software Architecture</a></p>
</blockquote>
<h3 id="level-3-component-diagram"><a class="header" href="#level-3-component-diagram">Level 3: Component diagram</a></h3>
<blockquote>
<p>Zooms into an individual container to show the components inside it. These components should map to real abstractions (e.g., a grouping of code) in your codebase.</p>
<p>Simon Brown - <a href="https://www.infoq.com/articles/C4-architecture-model/">The C4 Model for Software Architecture</a></p>
</blockquote>
<h3 id="level-4-code"><a class="header" href="#level-4-code">Level 4: Code</a></h3>
<blockquote>
<p>Finally, if you really want or need to, you can zoom into an individual component to show how that component is implemented.</p>
<p>Simon Brown - <a href="https://www.infoq.com/articles/C4-architecture-model/">The C4 Model for Software Architecture</a></p>
</blockquote>
<p><img src="https://c4model.com/img/c4-overview.png" alt="" /></p>
<h2 id="versioning"><a class="header" href="#versioning">Versioning</a></h2>
<h3 id="semantic-versioning"><a class="header" href="#semantic-versioning">Semantic Versioning</a></h3>
<p><img src="https://jontejada.com/blog/assets/semver02.png" alt="" /></p>
<ul>
<li><a href="https://semver.org">website</a></li>
<li><a href="https://snarky.ca/why-i-dont-like-semver/">Why I don't like SemVer anymore</a>
<ul>
<li>blogposzt az árnyoldalairól</li>
</ul>
</li>
</ul>
<h3 id="calendar-versioning"><a class="header" href="#calendar-versioning">Calendar Versioning</a></h3>
<ul>
<li>"<em>CalVer</em> is a versioning convention based on your project's release calendar, instead of arbitrary numbers."</li>
<li>YYYY.MINOR.MICRO</li>
<li><a href="https://calver.org">website</a></li>
</ul>
<h3 id="zerover-0-based-versioning"><a class="header" href="#zerover-0-based-versioning">ZeroVer: 0-based Versioning</a></h3>
<ul>
<li>"Your software's major version should never exceed the first and most important number in computing: zero."</li>
<li>e.g.: <strong>0.4.1</strong></li>
<li><a href="https://0ver.org">website</a></li>
</ul>
<!-- godbolt.org -->
<!-- https://nerds-den.com/how-to-design-software-that-you-can-be-proud-of/ -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="daily-work"><a class="header" href="#daily-work">Daily Work</a></h1>
<!-- toc -->
<h2 id="communication"><a class="header" href="#communication">Communication</a></h2>
<ul>
<li>A Remote communication strategies kifejezetten hasznos a <a href="https://learn.gitlab.com/all-remote/remote-playbook">GitLab távmunka kézikönyvéből</a>
<ul>
<li>18-26. oldal</li>
</ul>
</li>
</ul>
<blockquote>
<p>I am only responsible for what I said, not for what you understood</p>
</blockquote>
<p>Igaz ez? Miért nem?</p>
<p>Számítsd bele, hogy a másik nem ugyanazzokkal az előismeretekkel rendelkezik, nem ugyanazzal a fogalomkészlettel, terminológiával, esetleg anyanyalvvel.</p>
<ul>
<li><a href="https://www.lullabot.com/articles/effective-communication-part-1-greasing-the-wheels">A Software Developer’s Guide to Project Communication: Part 1</a>
<ul>
<li>a <a href="https://www.lullabot.com/articles/effective-communication-part-2-crossing-the-streams">2. rész</a> is ajánlott</li>
</ul>
</li>
<li><a href="http://www.agilemodeling.com/essays/communication.htm">Communication on Agile Software Teams</a></li>
</ul>
<h2 id="requirement-engineering"><a class="header" href="#requirement-engineering">Requirement Engineering</a></h2>
<ul>
<li><a href="https://www.inflectra.com/Ideas/Whitepaper/Principles-of-Requirements-Engineering.aspx">Principles of Requirements Engineering</a></li>
<li>Egy több részes cikk sorozat a Requirements Engineering-ről:
<ul>
<li><a href="https://medium.com/omarelgabrys-blog/requirements-engineering-introduction-part-1-6d49001526d3">Introduction (Part 1)</a></li>
<li><a href="https://medium.com/omarelgabrys-blog/requirements-engineering-elicitation-analysis-part-2-a02db801f135">Elicitation &amp; Analysis (Part 2)</a></li>
<li><a href="https://medium.com/omarelgabrys-blog/requirements-engineering-elicitation-analysis-part-5-2dd9cffafae8">Requirements Specification (Part 3)</a></li>
<li><a href="https://medium.com/omarelgabrys-blog/requirements-engineering-requirements-validation-part-6-29778d7bde24">Requirements Validation (Part 4)</a></li>
</ul>
</li>
<li><a href="https://enfocussolutions.com/requirements-engineering-vs-business-analysis/">Requirements Engineering vs. Business Analysis</a></li>
</ul>
<hr />
<ul>
<li><a href="http://www.agileforall.com/wp-content/uploads/2012/01/Story-Splitting-Flowchart.pdf">HOW TO SPLIT A USER STORY</a>
<ul>
<li>PDF, 1 oldal, flowchart</li>
<li><a href="https://www.humanizingwork.com/the-humanizing-work-guide-to-splitting-user-stories/">Bővebben</a></li>
</ul>
</li>
</ul>
<h2 id="coding"><a class="header" href="#coding">Coding</a></h2>
<!-- ![](https://miro.medium.com/max/978/1*jFw7ZZMoVcsEYM_fS33DBA.gif) -->
<p><img src="lectures/../images/tdd.png" alt="" title="TDD mantra: red, green, refactor" /></p>
<p>A TDD-ről részletesen a <a href="lectures/tdd.html">TDD fejezetben</a>.</p>
<h3 id="cserkész-szabály"><a class="header" href="#cserkész-szabály">Cserkész szabály</a></h3>
<blockquote>
<p>Always leave the campground cleaner than you found it</p>
<p>-- Robert C. Martin (Uncle Bob)</p>
</blockquote>
<ul>
<li><a href="https://codeburst.io/leave-the-code-cleaner-than-the-way-you-have-found-it-58c8e4ab3e83">Leave the code cleaner than the way you have found it!</a></li>
</ul>
<h2 id="clean-code"><a class="header" href="#clean-code">Clean Code</a></h2>
<blockquote>
<p>Always code as if the guy who ends up maintaining your code will be a violent psychopath who knows where you live. Code for readability. <a href="https://groups.google.com/forum/#!msg/comp.lang.c++/rYCO5yn4lXw/oITtSkZOtoUJ">source</a></p>
</blockquote>
<p>A viccet félretéve az egész lényege az érthetőség és a karbantarthatóság. Két hét múlva is meg kell értened a saját kódod és nem csak neked.</p>
<!--Elég vázlatos [összefoglalása](https://github.com/lastRoot/notes/wiki/Clean-Code-Rules-in-Java)-->
<h3 id="meaningful-names"><a class="header" href="#meaningful-names">Meaningful Names</a></h3>
<p>Az alábbiak Robert C. Martin Clean Code című könyvénből a 2. fejezet (Meaningful Names) alfejezet címei, az idézetek is onnan valók.</p>
<ul>
<li>Use Intention-Revealing Names
<ul>
<li>
<blockquote>
<p><code>int d; // elapsed time in days</code></p>
</blockquote>
</li>
<li>
<blockquote>
<p><code>int elapsedTimeInDays;</code></p>
</blockquote>
</li>
</ul>
</li>
<li>Avoid Disinformation</li>
<li>Make Meaningful Distinctions
<ul>
<li>
<blockquote>
<p>It is not sufficient to add number series or noise words, even though the compiler is satisfied. If names must be different, then they should also mean something different.</p>
</blockquote>
</li>
</ul>
</li>
<li>Use Pronounceable Names
<ul>
<li>
<blockquote>
<p>If you can’t pronounce it, you can’t discuss it without sounding like an idiot. “Well, over here on the bee cee arr three cee enn tee we have a pee ess zee kyew int, see?”</p>
</blockquote>
</li>
<li>Külön szempont ez nem angol anyanelyvűeknél, némely szavakat bonyolultabb kiejtenünk</li>
</ul>
</li>
<li>Use Searchable Names
<ul>
<li>
<blockquote>
<p>Single-letter names can ONLY be used as local variables inside short methods. <em>The length of a name should correspond to the size of its scope.</em></p>
</blockquote>
</li>
</ul>
</li>
<li>Avoid Mental Mapping
<ul>
<li>
<blockquote>
<p>Readers shouldn’t have to mentally translate your names into other names they already know.</p>
</blockquote>
</li>
<li>
<blockquote>
<p>clarity is king</p>
</blockquote>
</li>
</ul>
</li>
<li>Avoid Encodings
<ul>
<li>a modern IDE-k esetében már teljesen fölösleges típus vagy szerepjelöléseket tenni a nevekbe</li>
</ul>
</li>
<li>Pick One Word per Concept</li>
<li>Don’t Pun or use humor</li>
<li>Add Meaningful Context
<ul>
<li>
<blockquote>
<p>Imagine that you have variables named firstName, lastName, street, houseNumber, city, state, and zipcode. Taken together it’s pretty clear that they form an address. But what if you just saw the state variable being used alone in a method?</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<hr />
<p>Nincs megjelölve forrás, de <a href="http://bensmith.io/20-tips-for-better-naming">ez az összefogleló</a> is ezen a fejezeten alapszik.</p>
<h3 id="functions"><a class="header" href="#functions">Functions</a></h3>
<p>Az alábbiak Robert C. Martin Clean Code című könyvénből a 3. fejezetén alapulnak.</p>
<ul>
<li>A hossza legyen a lehető legrövidebb (akár 2-4 sor, bár személy szerint azt néha túlzásnak tartom)</li>
<li>Do One Thing</li>
<li>Use Descriptive Names
<ul>
<li>egy metódus valamit <em>csinál</em>, tehát kezdődjön igével, pl. <code>increaseSpeed</code></li>
<li>a nevéből legyen egyértelmű, hogy mit csinál</li>
<li>
<blockquote>
<p>Robert C. Martin <a href="https://www.informit.com/articles/article.aspx?p=1323426">The Inverse Scope Law of Function Names</a>: The longer the scope of a function, the shorter its name should be. Functions that are called locally from a few nearby places should have long descriptive names, and the longest function names should be given to those functions that are called from just one place.</p>
</blockquote>
</li>
</ul>
</li>
<li>Function Arguments
<ul>
<li>Lehetőleg ne használj 3-nál több paramétert</li>
<li>
<blockquote>
<p>Flag arguments are ugly [...] loudly proclaiming that this function does more than one thing.</p>
</blockquote>
</li>
</ul>
</li>
<li>Have No Side Effects
<ul>
<li>
<blockquote>
<p><a href="https://en.wikipedia.org/wiki/Side_effect_(computer_science)">Wikipédiából</a>: an operation, function or expression is said to have a side effect if it modifies some state variable value(s) outside its local environment, that is to say has an observable effect besides returning a value (the main effect) to the invoker of the operation.</p>
</blockquote>
</li>
<li>
<blockquote>
<p>Side effects are lies. Your function promises to do one thing, but it also does other hidden things.</p>
</blockquote>
</li>
</ul>
</li>
<li>Prefer Exceptions to Returning Error Codes
<ul>
<li>a korábbiakból már adódik, hogy miért jobb egy FileNotFoundException mint egy ERRCODE_26375</li>
</ul>
</li>
</ul>
<h3 id="comments"><a class="header" href="#comments">Comments</a></h3>
<blockquote>
<p>One of the more common motivations for writing comments is bad code. We write a module and we know it is confusing and disorganized. We know it’s a mess. So we say to ourselves, “Ooh, I’d better comment that!” No! You’d better clean it!</p>
<p>-- Robert C. Martin: Clean Code, pp 55.</p>
</blockquote>
<ul>
<li>Gyakori a kód strukturálása kommentekkel, ilyenkor célszerű függvényeket használni inkább</li>
<li>Kerülendő a TODO és a FIXME a kommentekben, ez azt jelenti, hogy nem vagy készen</li>
<li>Kommentezni ajánlott viszont -szerintem- a domain specifikus részeket, amelyek megértését nem feltétlenül lehet elvárni egy fejlesztőtől. Pl. egy fizikai számítás.</li>
<li>Továbbá nem haszontalan a dokumentációs kommentezés pl. Javadoc, kivéve ha egy <code>increaseSpeed</code> metódus kommentje annyi, hogy <em>"this method increases the speed"</em>, sokkal többet mondana az, hogy mennyivel, milyen korlátok között stb. amelyek révén aztán hasznos lesz a generált API dokumentáció anélkül, hogy a kódba kellene nézni.</li>
</ul>
<!--
- https://www.freecodecamp.org/news/code-comments-the-good-the-bad-and-the-ugly-be9cc65fbf83/
- [When Good Comments Go Bad](https://blog.codinghorror.com/when-good-comments-go-bad/)
-->
<hr />
<center>
    <img src="http://cdn.ttgtmedia.com/ITKE/uploads/blogs.dir/8/files/2008/07/goodcomments.jpg" width="320px" />
</center>
<hr />
<p><img src="https://miro.medium.com/max/1400/0*g6BXiTlE5fsgAFyI.png" alt="" /></p>
<h2 id="verziókezelők"><a class="header" href="#verziókezelők">Verziókezelők</a></h2>
<p><img src="http://smutch.github.io/VersionControlTutorial/_images/vc-xkcd.jpg" alt="" /></p>
<h3 id="mi-a-verziókezelő"><a class="header" href="#mi-a-verziókezelő">Mi a verziókezelő?</a></h3>
<blockquote>
<p>Version control, a.k.a. revision control / source code management, is basically a system for recording and managing changes made to files and folders. It is commonly used to manage source code, however, it is also well suited to tracking changes to any kind of file which contains mostly text.</p>
<p>-- <a href="http://smutch.github.io/VersionControlTutorial/pages/0-intro.html#what-is-version-control">forrás</a></p>
</blockquote>
<p>Az ember hajlamos ad-hoc módon is verziózni a munkáját, pl.<sup class="footnote-reference"><a href="#1">1</a></sup>:</p>
<p><img src="http://smutch.github.io/VersionControlTutorial/_images/intro1.png" alt="" /></p>
<p>Több szolgáltatás és szoftver alapból tartalmaz verziókövetést, pl. a Dropbox, Google Drive, stb. is verziózza a feltöltött állományokat; az MS Word még <a href="https://support.microsoft.com/en-us/office/combine-document-revisions-f8f07f09-4461-4376-b041-89ad67412cfe?ui=en-us&amp;rs=en-us&amp;ad=us">merge-elni is tudja az egyes verziókat</a>.</p>
<p>Michael Ernst <a href="https://homes.cs.washington.edu/~mernst/advice/version-control.html">összefoglalója alapján</a>:</p>
<ul>
<li><strong>Version control enables multiple people to simultaneously work on a single project.</strong> Each person edits his or her own copy of the files and chooses when to share those changes with the rest of the team. Thus, temporary or partial edits by one person do not interfere with another person's work.</li>
<li>Version control also enables one person you to use multiple computers to work on a project, so it is valuable even if you are working by yourself.</li>
<li><strong>Version control integrates work done simultaneously by different team members.</strong> In most cases, edits to different files or even the same file can be combined without losing any work. In rare cases, when two people make conflicting edits to the same line of a file, then the version control system requests human assistance in deciding what to do.</li>
<li><strong>Version control gives access to historical versions of your project.</strong> This is insurance against computer crashes or data lossage. If you make a mistake, you can roll back to a previous version. You can reproduce and understand a bug report on a past version of your software. You can also undo specific edits without losing all the work that was done in the meanwhile. For any part of a file, you can determine when, why, and by whom it was ever edited.</li>
</ul>
<h3 id="mit-érdemes-verziókezelni"><a class="header" href="#mit-érdemes-verziókezelni">Mit érdemes verziókezelni</a></h3>
<blockquote>
<p>"In practice, everything that has been created manually should be put in version control, including programs, original field observations, and the source files for papers."</p>
<p>-- Best Practices for Scientific Computing; Wilson et al. 2012 (<a href="https://arxiv.org/abs/1210.0530">arXiv:1210.0530</a>)</p>
</blockquote>
<p>Az ehhez a jegyzethez készített ábrák és azok forrása is verziókezelés alatt van, ezek a <code>.png</code> és <code>.dia</code> állományok a <code>/src/images/</code> mappában, utóbbiak valójában egy <a href="https://wiki.gnome.org/Apps/Dia">diagramszerkesztő alkalmazás</a> XML alapú forrásfájljai.</p>
<!--
### Verziókezelési modellek

- Lock-Modify-Unlock
- Copy-Modify-Merge
-->
<ul>
<li><a href="https://tortoisesvn.net/docs/nightly/TortoiseSVN_en/tsvn-basics-versioning.html">Ez az írás</a> összefoglalja a verziókezelési modelleket (Lock-Modify-Unlock, Copy-Modify-Merge), <a href="https://homes.cs.washington.edu/~mernst/advice/version-control.html">emez pedig</a> összehasonlítja a centralizált és az elosztott verziókezelőket.</li>
<li><a href="https://git-scm.com/book/en/v2/Getting-Started-About-Version-Control">About Version Control</a>
<ul>
<li>a Git könyv első fejezete, rövid összefoglaló</li>
</ul>
</li>
<li>gyakorlati oldalról lást <a href="lectures/../git.html">Git</a> fejezet</li>
</ul>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>http://smutch.github.io/VersionControlTutorial/pages/0-intro.html#what-is-version-control</p>
</div>
<h3 id="centralizált-verziókezelő"><a class="header" href="#centralizált-verziókezelő">Centralizált verziókezelő</a></h3>
<p><img src="https://homes.cs.washington.edu/~mernst/advice/version-control-fig2.png" alt="centralized_version_control" /></p>
<h3 id="elosztott-verziókezelő"><a class="header" href="#elosztott-verziókezelő">Elosztott verziókezelő</a></h3>
<p><img src="https://homes.cs.washington.edu/~mernst/advice/version-control-fig3.png" alt="distributed_version_control" /></p>
<h3 id="branching"><a class="header" href="#branching">Branching</a></h3>
<ul>
<li><a href="https://git-scm.com/book/en/v2/Git-Branching-Basic-Branching-and-Merging">Git Branching - Basic Branching and Merging</a></li>
<li><a href="lectures/../git.html#interakt%C3%ADv-online-oktat%C3%B3-anyagok">Gyakorlati oktatóanyagok</a></li>
</ul>
<p>A félév során a <a href="https://guides.github.com/introduction/flow/">GitHubFlow</a>-t használjuk, részletek a <a href="lectures/../github.html#branching-model">GitHub fejezetben</a>.</p>
<!-- ![](https://www.rittmanmead.com/blog/content/images/2017/01/gitflow.png) -->
<!--

#### További írások a témában

* [The Definitive Guide to Forks and Branches in Git](https://www.pluralsight.com/blog/software-development/the-definitive-guide-to-forks-and-branches-in-git)
* [a simple git branching model](https://gist.github.com/jbenet/ee6c9ac48068889b0912)
* [OneFlow – a Git branching model and workflow](https://www.endoflineblog.com/oneflow-a-git-branching-model-and-workflow#oneflow-advantages)
* [Comparing Workflows](https://www.atlassian.com/git/tutorials/comparing-workflows)
* [Git branching and forking in the enterprise: why fork?](https://www.atlassian.com/blog/git/git-branching-and-forking-in-the-enterprise-why-fork)
* [Using the Fork-and-Branch Git Workflow](https://blog.scottlowe.org/2015/01/27/using-fork-branch-git-workflow/)
* [Stackoverflow / Forking vs. Branching in GitHub](https://stackoverflow.com/a/34343080/4737417)
* [A succesful Git branching model considered harmful](https://barro.github.io/2016/02/a-succesful-git-branching-model-considered-harmful/)
* [Escape from Merge Hell: Why I Prefer Trunk-Based Development Over Feature Branching and GitFlow](https://stxnext.com/blog/2018/02/28/escape-merge-hell-why-i-prefer-trunk-based-development-over-feature-branching-and-gitflow/) -->
<h3 id="commit-üzenetek"><a class="header" href="#commit-üzenetek">Commit üzenetek</a></h3>
<p><img src="https://www.explainxkcd.com/wiki/images/d/de/git_commit.png" alt="xkcd 1296" /></p>
<p>A <a href="https://chris.beams.io/posts/git-commit/">How to Write a Git Commit Message</a> egy hosszabb, példákkal illusztrált írás a jó commit üzenetekről, amely <a href="https://chris.beams.io/posts/git-commit/#seven-rules">hét szabályban</a> foglalja össze, hogy mire kell figyelni. Ezt egészíteném ki egy nyolcadikkal.</p>
<ol>
<li><a href="https://chris.beams.io/posts/git-commit/#separate">Separate subject from body with a blank line</a></li>
<li><a href="https://chris.beams.io/posts/git-commit/#limit-50">Limit the subject line to 50 characters</a></li>
<li><a href="https://chris.beams.io/posts/git-commit/#capitalize">Capitalize the subject line</a></li>
<li><a href="https://chris.beams.io/posts/git-commit/#end">Do not end the subject line with a period</a></li>
<li><a href="https://chris.beams.io/posts/git-commit/#imperative">Use the imperative mood in the subject line</a></li>
<li><a href="https://chris.beams.io/posts/git-commit/#wrap-72">Wrap the body at 72 characters</a>
<ul>
<li>ez a legkevésbé fontos</li>
</ul>
</li>
<li><a href="https://chris.beams.io/posts/git-commit/#why-not-how">Use the body to explain what and why vs. how</a></li>
<li><strong>Reference the issue!</strong></li>
</ol>
<h4 id="miért-fontos-a-8-pont"><a class="header" href="#miért-fontos-a-8-pont">Miért fontos a 8. pont?</a></h4>
<p>Valójában (bizonyos szempontból) az issue behivatkozása a legfontosabb, méghozzá a <strong>visszakövethetőség</strong> (traceability) miatt.</p>
<p><img src="lectures/../images/traceability_via_commit.png" alt="" /></p>
<p>Minden módosítás (a verziókövető rendszerben) rendelkezik egy azonosítóval, amelyhez társul, hogy ki és mikor végezte el a módosítást. Valamit egy üzenet, amely -- jó esetben -- leírja, hogy mi volt ez a módosítás. A visszakövethetőség egy adott szintig tehát szerves része a verziókövető rendszereknek.</p>
<p>A módosítások azonban nem csak úgy ötletszerűen történnek, hanem valamilyen feladat által meghatározott célból. Pl. jelenítsd meg a műszerfalon az autó pillanatnyi sebességét (feature), vagy javítsd ki pixel/s -&gt; km/h átváltást, mert kerekítési hiba miatt értelmetlen érték jelenik meg (bugfix).</p>
<p>Ugyanakkor a feladatok (task) sem csak úgy lógnak a levegőben, jellemzően kapcsolódnak egy user story-hoz (különösen a feature-ök), de biztosan kapcsolódnak egy sprinthez (hiszen beütemezték a megoldását valamikorra), van felelősük, határidejük, stb. Úgy általában van véve egy kontextusuk. Az issue (más néven task) tartalmazza az adott feladat pontos részleteit, az issue/task trackerben akár a megoldás teljes vitafolyamata megtalálható. Pl. ki hogyan akarta implementálni, milyen érvek és ellenérvek merültek fel az egyes implementációs lehetőségek mellett/ellen, hogyan jutott a fejlesztőcsapat konszenzusra, vagy ki hagyta jóvá az adott módosítást, ki döntött arról, hogy melyik sprintbe kerüljön be, stb.</p>
<p>A visszakövethetőség nem csak addig a pontig érdekes és fontos, hogy ki írta át a változó típusát (pl.), hanem a teljes tervezési/döntés folyamatig visszamenőleg.</p>
<p>Mi van akkor ha a döntés egy face-to-face meetingen (pl. standup), skype konferenciahíváson vagy egyéb nem írásos formában történt?
(A szó elszáll, írás megmarad...)</p>
<p>Ebben az esetben, az issue kiváló hely arra, hogy írásban is rögzítve legyenek az elhangzottak. Pl. YYYY-MM-DD-ei megbeszélés alapján az XY library segítségével fogom implementálni az analóg fordulatszámkijelzőt. Akár explicit írásos jóváhagyást is lehet kérni...</p>
<h4 id="további-iskolák"><a class="header" href="#további-iskolák">További „iskolák”</a></h4>
<ul>
<li>Az <a href="https://github.com/angular/angular/blob/master/CONTRIBUTING.md#commit">AngularJS Git Commit Message Conventions</a> a commit üzenet fejlécét a <code>&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</code> szabály szerint követeli meg.
<ul>
<li>ahol <a href="https://github.com/angular/angular/blob/master/CONTRIBUTING.md#type">típus</a> lehet build, ci, docs, feat, fix, perf, refactor, style vagy test</li>
<li>valójában a 1., 4. és 5. pontot ez is megköveteli; a 3.-al pont szembemegy, aminek oka, hogy a tárgy típusmegjelöléssel kezdődik, nem a tárgy szövegével</li>
<li>a tárgy és törzs sorhosszára 100 karakteres limitet ad, szemben a fenti hagyományos (akár úgy is lehet érteni, hogy elavult) terminálméretekre szabott korlátaival</li>
</ul>
</li>
<li>Egy másik, az Angularéhoz nagyon hasonló a <a href="http://conventionalcommits.org/">Conventional Commits</a></li>
<li>Ezek előnye lehet -megfelelő tooling mellett- pl. az automatizált changlelog generálás
<ul>
<li>nálunk nincs ilyesmire beállított eszköz</li>
</ul>
</li>
</ul>
<h4 id="mire-jó-még-a-commit-üzenet"><a class="header" href="#mire-jó-még-a-commit-üzenet">Mire jó még a commit üzenet?</a></h4>
<p>Például arra is alkalmas, hogy <a href="https://help.github.com/en/github/managing-your-work-on-github/linking-a-pull-request-to-an-issue#linking-a-pull-request-to-an-issue-using-a-keyword">lezárjunk vele egy issue-t</a>. Ha a commit üzenet törzse tartalmazza a <em>close</em>, <em>closes</em>, <em>closed</em>, <em>fix</em>, <em>fixes</em>, <em>fixed</em>, <em>resolve</em>, <em>resolves</em> vagy <em>resolved</em> utasítások egyikét, akkor a GH automatikusan zárja az issue-t amint az a fő ágba (master) került. Pl.</p>
<pre><code>Fix px/s -&gt; km/h conversion #28

Fixes #28
</code></pre>
<h3 id="mikor-commit-oljunk"><a class="header" href="#mikor-commit-oljunk">Mikor commit-oljunk?</a></h3>
<p>A fentiekből már látszik, hogy az egésznek akkor van értelme, ha egy-egy commit egy jól megválasztott mértékű módosítást rögzít. Az a megközelítés, hogy a munkanap végén nyomok egy commitot valami olyasféle üzenettel, hogy <code>Changes on YYYY-MM-DD</code> nem nagyon szolgálja a visszakövethetőséget.</p>
<p>Egy taszk hossza 1-4 óra (főállású fejlesztőre értelmezve), de fontos, hogy egy megszakítás nélkül elvégezhető feladat legyen. Ez azt jelenti, hogy egy taszk egyenlő egy committal? Nem. Egy taszk megoldása természetesen több commitból is állhat.</p>
<p>A <a href="https://dev.to/gonedark/when-to-make-a-git-commit">When to make a Git Commit</a> poszt<sup class="footnote-reference"><a href="#1">1</a></sup> alapján (is), azt mondanám, hogy akkor érdemes commitolni, ha:</p>
<ol>
<li>Befejeztem egy egységnyi munkát.</li>
<li>Olyan módosítást végeztem, amit esetleg visszavonnék.</li>
</ol>
<p>Az egységnyi munka módosított sorok és fájlok tekintetében rendkívül változó lehet. Egy bugfix pl. állhat egyetlen karakter módosításából, de egy refaktorálás során egy metódus átnevezése járhat tucatnyi fájl módosításával (ahol az adott metódus használva volt). Ugyanakkor a metódusátnevezés után biztosan érdemes lehet commitolni, egyéb módosítást már nem csapnék hozzá.</p>
<p>Ha a commit üzenetbe azt írnád, hogy <code>Rename foobar method and fix typo in the comment #42</code> már biztosan két külön commitra lenne szükséged.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>a hozzá tartozó kommenteket is érdemes átfutni</p>
</div>
<h2 id="review"><a class="header" href="#review">Review</a></h2>
<ul>
<li><a href="lectures/./review.html">Review fejezet</a></li>
</ul>
<h3 id="a-tárgy-során"><a class="header" href="#a-tárgy-során">A tárgy során</a></h3>
<p><img src="lectures/../images/proc3.png" alt="review process" /></p>
<!--## Java kódformázás-->
<div style="break-before: page; page-break-before: always;"></div><h2 id="waterfall"><a class="header" href="#waterfall">Waterfall</a></h2>
<img src="lectures/../images/waterfall.png" class="img-right">
<ul>
<li>Sequential design process</li>
<li>Next stage can be started after finishing the previous</li>
<li>After finishing a step, cannot go back to previous</li>
</ul>
<!-- vertical -->
<h2 id="waterfall-pros"><a class="header" href="#waterfall-pros">Waterfall: pros</a></h2>
<ul>
<li>Customer can have clear expectation about the final product</li>
<li>Employee turnover does not influence project due to strong documentation</li>
<li>Simple, easy to use model</li>
</ul>
<!-- vertical -->
<h2 id="waterfall-cons"><a class="header" href="#waterfall-cons">Waterfall: cons</a></h2>
<ul>
<li>Customer can have clear expectation about the final product</li>
<li>Employee turnover does not influence project due to strong documentation</li>
<li>Simple, easy to use model</li>
</ul>
<!-- vertical -->
<!-- .slide: data-visibility="hidden" -->
<h2 id="waterfall-vs-agile"><a class="header" href="#waterfall-vs-agile">Waterfall Vs. Agile</a></h2>
<ul>
<li><a href="https://www.guru99.com/waterfall-vs-agile.html">Waterfall Vs. Agile: Must Know Differences</a>
<ul>
<li>A többi fejezet is ajánlott</li>
</ul>
</li>
<li><a href="https://www.seguetech.com/waterfall-vs-agile-methodology/">Waterfall vs. Agile: Which is the Right Development Methodology for Your Project?</a></li>
</ul>
<!-- slide -->
<h2 id="v-model"><a class="header" href="#v-model">V-Model</a></h2>
<img src="lectures/../lectures/images/v_model.drawio.png" class="img-right">
<ul>
<li><a href="https://www.guru99.com/v-model-software-testing.html">V-Model in Software Testing</a></li>
</ul>
<!-- slide -->
<h2 id="complex-project"><a class="header" href="#complex-project">Complex Project</a></h2>
<img src="lectures/../lectures/images/complex_project.drawio.png" class="img-right">
<ul>
<li><strong>Complex projects</strong> are where requirements and technology are not agreed.</li>
<li>Flexibility and frequent feedback loops are needed here.</li>
</ul>
<!-- slide -->
<h2 id="the-agile-manifesto"><a class="header" href="#the-agile-manifesto">The Agile Manifesto</a></h2>
<!-- .slide: class="slide-quote" -->
<blockquote>
<p>We are uncovering better ways of developing software by doing it and helping others do it. Through this work we have come to value:</p>
<ul>
<li><strong>Individuals and interactions</strong> over processes and tools</li>
<li><strong>Working software</strong> over comprehensive documentation</li>
<li><strong>Customer collaboration over</strong> contract negotiation</li>
<li><strong>Responding to change over</strong> following a plan</li>
</ul>
<p>That is, while there is value in the items on the right, we value the items on the left more.</p>
<p><cite><a href="https://www.agilealliance.org/agile101/the-agile-manifesto/">forrás</a></cite></p>
</blockquote>
<!-- vertical -->
<!-- .slide: data-visibility="hidden" -->
<ul>
<li><a href="https://www.agilealliance.org/agile101/12-principles-behind-the-agile-manifesto/">The following 12 Principles are based on the Agile Manifesto.</a></li>
<li><a href="https://www.agilealliance.org/agile101/subway-map-to-agile-practices/">Külön érdekes a szoftverfejlesztési metodológiákat metrótérképszerűen összefoglaló ábra</a></li>
</ul>
<!-- vertical -->
<h2 id="agile-principles"><a class="header" href="#agile-principles">Agile Principles</a></h2>
<ul>
<li>Frequent delivery</li>
<li>Test early, test often</li>
<li>Small, incremental releases</li>
<li>Development team makes their own decisions</li>
<li>Direct communication between customer and development team</li>
</ul>
<!-- vertical -->
<h2 id="best-practices-for-agile"><a class="header" href="#best-practices-for-agile">Best Practices for Agile</a></h2>
<ul>
<li>Test-Driven Development (TDD)</li>
<li>Regular refactoring</li>
<li>Continuous integration</li>
<li>Simple design</li>
<li>Pair programming</li>
</ul>
<!-- slide -->
<h2 id="scrum"><a class="header" href="#scrum">SCRUM</a></h2>
<blockquote>
<p>A framework within which people can address complex adaptive problems, while productively and creatively delivering products of the highest possible value.</p>
</blockquote>
<ul>
<li>Not a process or technique, rather a framework</li>
<li>Based on empirical process theory</li>
<li>Empiricism assumes that knowledge comes from experience</li>
<li>Iterative, incremental approach</li>
<li>Consists of
<ul>
<li>Scrum Team/Roles</li>
<li>Events</li>
<li>Artifacts</li>
<li>Rules</li>
</ul>
</li>
</ul>
<!-- -->
<ul>
<li><a href="https://www.scrumguides.org/docs/scrumguide/v2016/2016-Scrum-Guide-US.pdf">The Scrum Guide (PDF, 17 pages)</a></li>
<li><a href="https://manifesto.co.uk/scrum-practice-daily-scrum/">Scrum in practice: the daily Scrum</a></li>
</ul>
<!-- slide -->
<h2 id="scrum-team--roles"><a class="header" href="#scrum-team--roles">Scrum Team &amp; Roles</a></h2>
<img src="lectures/../lectures/images/scrum_communication_modell.drawio.png" class="img-right">
<ul>
<li>Self-organizing</li>
<li>Cross-functional</li>
<li>Maximizes opportunities for feedback</li>
</ul>
<!-- -->
<ul>
<li>Roles:
<ul>
<li>Product Owner (PO)</li>
<li>Development Team</li>
<li>Scrum Master</li>
</ul>
</li>
<li><a href="https://www.scrumhub.com/scrum-guide/team-roles/">Further reading</a></li>
</ul>
<!-- vertical -->
<h2 id="product-owner"><a class="header" href="#product-owner">Product Owner</a></h2>
<ul>
<li>Responsible for optimizing the value of the work the Development Team does</li>
<li>Clarifies product backlog items</li>
<li>Product backlog items can only be prioritized by PO</li>
<li>Decisions made by PO is respected by everyone in the entire organization</li>
</ul>
<!-- vertical -->
<!-- .slide: data-visibility="hidden" -->
<ul>
<li><a href="https://www.romanpichler.com/blog/the-product-owner-responsibilities/">The Agile Product Owner Responsibilities</a></li>
</ul>
<!-- vertical -->
<h2 id="development-team"><a class="header" href="#development-team">Development Team</a></h2>
<ul>
<li>Self-organizing team – makes its own decisions how to turn Product Backlog into potentially releasable functionalities</li>
<li>Cross-functional team – team has all skills needed turn Product Backlog into potentially releasable functionalities</li>
<li>No titles inside team</li>
<li>No subteams inside team</li>
<li>Size can be between 3 and 9</li>
</ul>
<!-- vertical -->
<h2 id="cross-functional-team"><a class="header" href="#cross-functional-team">Cross-functional team</a></h2>
<p><img src="lectures/../images/cross_functional.png" alt="" /></p>
<p>Akkor tud egy csapat „cross-functional” lenni, ha minden tagja kellőképpen érti a csapat feladatát, így a tagok képesek egymást helyettesíteni. A fenti ábra a csapattagok tudását szemlélteti. Az első esetben csupán elenyésző általános tudással rendelkező emberekről van szó, akik egy nagyon szűk területet ismernek. A <em>cross-functional team</em> esetében is megvan az egyes tagok specifikus tudása ám az kevésbé nyúlik túl a csapat általános ismeretein és kevésbé specifikusabb is.</p>
<!-- vertical -->
<h2 id="scrum-master"><a class="header" href="#scrum-master">Scrum Master</a></h2>
<img src="https://vectorified.com/images/scrum-master-icon-32.png" class="img-right">
<ul>
<li>Responsible for Scrum to be understood in scrum team</li>
<li>Facilitates scrum events</li>
<li>Removes impediments from development team</li>
<li>Coaches development team for self-organization</li>
<li>Coaches organization in Scrum adaptation</li>
<li>Not the „boss” of development team</li>
<li>Servant leader of the team</li>
<li>Can be one team member or common Scrum Master for several teams</li>
</ul>
<p><a href="https://www.youtube.com/watch?v=P6v-I9VvTq4">Scrum Master - Funny movie about The Power of Scrum</a></p>
<!-- slide -->
<h2 id="scrum-events"><a class="header" href="#scrum-events">Scrum Events</a></h2>
<img src="lectures/../lectures/images/scrum_sprint.drawio.png" height="320">
<ul>
<li>Time boxed events
<ul>
<li>there is a maximal time allowed to keep</li>
</ul>
</li>
<li>Regular meetings
<ul>
<li>minimizes the need for other not defined meetings</li>
</ul>
</li>
</ul>
<!-- vertical -->
<h2 id="sprint"><a class="header" href="#sprint">Sprint</a></h2>
<ul>
<li>Time-boxed for one month or less</li>
<li>During the sprint a potentially releasable product increment shall be created</li>
<li>Consists of
<ul>
<li>Sprint Planning</li>
<li>Daily Scrums (Standup)</li>
<li>Development work</li>
<li>Sprint Review</li>
<li>Sprint Retrospective</li>
</ul>
</li>
<li>Each Sprint has a definition what has to be done</li>
<li>During Sprint no change can be made that influences the Sprint Goal</li>
<li>Can be terminated when Sprint Goal became obsolete</li>
<li><a href="https://www.scrumhub.com/scrum-guide/sprints/">Further reading</a></li>
</ul>
<!-- vertical -->
<h2 id="sprint-planning"><a class="header" href="#sprint-planning">Sprint Planning</a></h2>
<ul>
<li>The work that should be done in Sprint is planned in Sprint Planning</li>
<li>Eight hours for a one-month Sprint, for shorter Sprint it is less</li>
<li>Answers for two questions:
<ul>
<li>What will be delivered for the next Sprint?</li>
<li>How it will be done?</li>
</ul>
</li>
<li>Product Backlog is used as an input, Sprint Backlog (SB) is filled with items from Product Backlog (PB)</li>
<li>The number of selected items has to be decided only by development team</li>
<li>Product Owner helps to clarify Product Backlog items</li>
<li>Scrum Master facilitates the meeting when needed</li>
<li><a href="https://www.scrumhub.com/scrum-guide/estimations/">Further reading: Estimations</a></li>
</ul>
<!-- vertical -->
<h2 id="daily-scrum"><a class="header" href="#daily-scrum">Daily Scrum</a></h2>
<ul>
<li>Time-boxed to 15 minutes</li>
<li>Main goal is to synchronize activities between team members</li>
<li>Kept each day at the same time and same place to reduce complexity</li>
<li>Every team member participates and answers three questions:
<ul>
<li>What was done by himself/herself by last Daily Scrum?</li>
<li>What will be done by himself/herself till next Daily Scrum?</li>
<li>Are there any impediments that prevent the work?</li>
</ul>
</li>
<li>Scrum Master does not need to participate always, but
<ul>
<li>Ensures that all team members take part</li>
<li>Teaches development team to keep the time-box</li>
</ul>
</li>
<li><a href="https://www.scrumhub.com/scrum-guide/daily-standups/">Further reading</a></li>
</ul>
<!-- vertical -->
<h2 id="sprint-review"><a class="header" href="#sprint-review">Sprint Review</a></h2>
<ul>
<li>Kept at the end of the sprint</li>
<li>Time-boxed to four hour for one month sprint</li>
<li>Scrum Team and stakeholders attend</li>
<li>PO explains the PB items, that are „Done” or not „Done” to stakeholders</li>
<li>Development Team demonstrates the work and answers questions</li>
<li>Scrum Team gather feedback from stakeholders</li>
<li>All participants collaborates on what to do next</li>
</ul>
<!-- -->
<ul>
<li><a href="https://reqtest.com/development/how-to-succeed-at-a-sprint-demo/">Further reading: How to Succeed at a Sprint Demo</a></li>
</ul>
<!-- vertical -->
<h2 id="sprint-retrospective"><a class="header" href="#sprint-retrospective">Sprint Retrospective</a></h2>
<img src="lectures/../lectures/images/retro.drawio.png" class="img-right" width="400">
<ul>
<li>For the Scrum Team to inspect and improve itself</li>
<li>Three hour time-box after sprint review for one-month Sprint</li>
<li>Plan shall be created for implementing improvements of the way of working</li>
<li><a href="https://www.scrumhub.com/scrum-guide/retrospectives/">Further reading</a></li>
</ul>
<!-- slide -->
<h2 id="sprint-artifacts-product-backlog"><a class="header" href="#sprint-artifacts-product-backlog">Sprint Artifacts: Product Backlog</a></h2>
<ul>
<li>Ordered list of items needed for the product</li>
<li>Dynamically evolves</li>
<li>Property of Product Owner</li>
<li>PO is responsible for its content and prioritization</li>
<li><a href="https://www.scrumhub.com/scrum-guide/product-backlog/">Further reading</a></li>
</ul>
<!-- vertical -->
<h2 id="sprint-artifacts-sprint-backlog"><a class="header" href="#sprint-artifacts-sprint-backlog">Sprint Artifacts: Sprint Backlog</a></h2>
<ul>
<li>Selected PB items for a certain Sprint in Sprint Planning</li>
<li>Development Team is the owner</li>
<li>Estimates are made by Development Team</li>
</ul>
<!-- vertical -->
<h2 id="sprint-artifacts-product-increment"><a class="header" href="#sprint-artifacts-product-increment">Sprint Artifacts: Product Increment</a></h2>
<ul>
<li>Sum of all PB items completed</li>
<li>Has to meet the Definition of "Done"</li>
<li>A new increment is delivered after each Sprint</li>
</ul>
<!-- vertical -->
<h2 id="burndown-chart"><a class="header" href="#burndown-chart">Burndown Chart</a></h2>
<ul>
<li>Expresses the remaining effort for a time period</li>
<li>X axis: time left in the Sprint</li>
<li>Y axis: remaining effort for the Sprint measured in story points</li>
<li>Story points measures how "difficult" a user story is</li>
<li>Story points are estimated by Development Team</li>
<li><a href="https://www.scrumhub.com/scrum-guide/burndowns/">Further reading</a></li>
</ul>
<!-- vertical -->
<!-- .slide: data-visibility="hidden" -->
<p><a href="http://www.agileme.com.au/wiki/Sprint_Burndown_Chart">AgileMe - Sprint Burndown Chart</a></p>
<!-- vertical -->
<h2 id="artifact-transparency-definition-of-done"><a class="header" href="#artifact-transparency-definition-of-done">Artifact Transparency: Definition of Done</a></h2>
<img src="lectures/../lectures/images/checklist.drawio.png" class="img-right" height="350">
<ul>
<li>Checklist of activities needed for a product increment</li>
<li>List of activities such coding, unit testing, documentation, integration test, etc.</li>
<li>Has to be understood and followed by all team members</li>
</ul>
<!-- slide -->
<h2 id="scaling-scrum-scrum-of-scrums"><a class="header" href="#scaling-scrum-scrum-of-scrums">Scaling Scrum: Scrum of Scrums</a></h2>
<ul>
<li>Each Scrum Team delegates an "ambassador" who attends the Scrum of Scrums meeting</li>
<li>Ambassadors coordinate the work of multiple Scrum Teams</li>
<li>Meetings are not as frequent as Daily Scrum</li>
<li><a href="https://www.agilealliance.org/glossary/scrum-of-scrums/">Further reading</a></li>
</ul>
<img src="lectures/../lectures/images/scrum_of_scrums.drawio.png" class="fragment" height="300">
<!-- slide -->
<h2 id="kanban"><a class="header" href="#kanban">Kanban</a></h2>
<img src="lectures/../lectures/images/kanban.drawio.png" class="img-right">
<ul>
<li>Pull system</li>
<li>Eliminate waste</li>
<li>Decrease cycle time</li>
<li>Should be applied to current processes</li>
<li>Rules:
<ul>
<li>Visualize Workflow</li>
<li>Limit Work in Process</li>
<li>Measure and Improve Flow</li>
</ul>
</li>
</ul>
<!-- vertical -->
<h2 id="kanban-cont"><a class="header" href="#kanban-cont">Kanban cont.</a></h2>
<img src="lectures/../lectures/images/kanban.drawio.png" class="img-right">
<ul>
<li>Tasks move left to right</li>
<li>Choose the rightest top task to work with
<ul>
<li>to finish it as soon as possible</li>
</ul>
</li>
<li>within a column, the task at the top has the highest priority</li>
<li>task may contain
<ul>
<li>assignee</li>
<li>effort</li>
<li>etc.</li>
</ul>
</li>
<li>Further reading
<ul>
<li><a href="https://www.scrumhub.com/kanban-fundamentals/">Kanban Fundamentals</a></li>
</ul>
</li>
</ul>
<!-- vertical -->
<h2 id="scrum-vs-kanban"><a class="header" href="#scrum-vs-kanban">Scrum vs. Kanban</a></h2>
<div class="table-wrapper"><table><thead><tr><th></th><th>SCRUM</th><th>Kanban</th></tr></thead><tbody>
<tr><td>Cadence</td><td>Regular fixed length sprints</td><td>Continuous flow</td></tr>
<tr><td>Release methodology</td><td>At the end of each sprint if approved by the product owner</td><td>Continuous delivery or at the team's discretion</td></tr>
<tr><td>Roles</td><td>Product owner, scrum master, development team</td><td>No existing roles. Some teams enlist the help of an agile coach.</td></tr>
<tr><td>Change philosophy</td><td>Teams should strive to not make changes to the sprint forecast during the sprint. Doing so compromises learnings around estimation.</td><td>Change can happen at any time</td></tr>
</tbody></table>
</div><!-- slide -->
<!-- .slide: data-visibility="hidden" -->
<h2 id="scrumban"><a class="header" href="#scrumban">Scrumban</a></h2>
<ul>
<li><a href="https://www.agilealliance.org/what-is-scrumban/">What is Scrumban?</a></li>
</ul>
<!-- slide -->
<!-- .slide: data-visibility="hidden" -->
<h2 id="further-reading-about-scrum"><a class="header" href="#further-reading-about-scrum">Further reading about SCRUM</a></h2>
<!-- ![](http://2.bp.blogspot.com/-T9nVdkSCQMo/TrvwKPtRBDI/AAAAAAAAANQ/mWGv4EsmshY/s1600/scrum_process_big.jpg) -->
<ul>
<li><a href="https://www.scrumhub.com/scrum-guide/team-roles/">Team Roles</a></li>
<li><a href="https://www.scrumhub.com/scrum-guide/product-backlog/">Product Backlog</a></li>
<li><a href="https://www.scrumhub.com/scrum-guide/release-backlog/">Release Backlog</a></li>
<li><a href="https://www.scrumhub.com/scrum-guide/estimations/">Estimations</a></li>
<li><a href="https://www.scrumhub.com/scrum-guide/sprints/">Sprints</a></li>
<li><a href="https://www.scrumhub.com/scrum-guide/burndowns/">Burndowns</a></li>
<li><a href="https://www.scrumhub.com/scrum-guide/expectation-charts/">Expectation Charts</a></li>
<li><a href="https://www.scrumhub.com/scrum-guide/daily-standups/">Daily Standups</a></li>
<li><a href="https://www.scrumhub.com/scrum-guide/retrospectives/">Retrospectives</a></li>
</ul>
<!-- nem működik -->
<!-- ## Az Egyetem más tárgyhoz fejlesztett e-tananyaga SCRUM-hoz

- Elérhető [innen](http://innovacio.uni-obuda.hu/p/elearning/)
- Ebből az első két blokk (a „[Product owner](http://innovacio.uni-obuda.hu/p/elearning/course/77)” és a „[Scrum Master](http://innovacio.uni-obuda.hu/p/elearning/course/89)”) releváns, mindkettő 5-5 modul, modulonként egy ~50 oldalas prezentációval.
- Teljes más a struktúrája mint az SzFMV tárgynak, de kifejezetten hasznos részeket is tartalmaz mint pl. a Product owner / 4. modul: user story szétbontása
- A modulokhoz ellenőrző kérdések is vannak, ezek bár független a ZH kérdéseinkről, de a releváns fejezetek önellenőrzésére jók lehetnek -->
<!--
UNUSED
https://agilepearls.wordpress.com/category/agile-sw-methodology/
-->
<!-- slide -->
<!-- .slide: data-visibility="hidden" -->
<h2 id="quiz"><a class="header" href="#quiz">Quiz</a></h2>
<pre>
<div class="quizdown">
    ---
    shuffleQuestions: true
    shuffleAnswers: true
    ---

    ### Scrum does not have a role called "project manager".

    1. [x] True
    1. [ ] False

    ### Which statement best describes a Product Owner's responsibility?

    1. [x] Optimizing the value of the work the Development Team does.
    1. [ ] Directing the Development Team.
    1. [ ] Managing the project and ensuring that the work meets the commitments to the stakeholders.
    1. [ ] Keeping stakeholders at bay. 

    ### The Development Team should have all the skills needed to?

    1. [ ] Complete the project as estimated when the date and cost are committed to the Product Owner.
    1. [ ] Do all of the development work, except for specialized testing that requires additional tools and environments.
    1. [x] Turn the Product Backlog items it selects into an increment of potentially releasable product functionality.

    ### What are the two primary ways a Scrum Master keeps a Development Team working at its highest level of productivity?

    - [x] By facilitating Development Team decisions.
    - [x] By removing impediments that hinder the Development Team.
    - [ ] By starting and ending the meetings at the proper time.
    - [ ] By keeping high value features high in the Product Backlog.

    ### What is the main reason for the Scrum Master to be at the Daily Scrum?

    1. [ ] To make sure every team member answers the three questions.
    1. [x] He or she does not have to be there; he or she only has to ensure the Development Team has a Daily Scrum.
    1. [ ] To write down any changes to the Sprint Backlog, including adding new items, and tracking  progress on the burn-down.
    1. [ ]  To gather status and progress information to report to management.

    ### The purpose of a Sprint is to produce a done increment of working product.

    1. [x] True
    1. [ ] False

    ### The length of a Sprint should be:

    1. [ ] Short enough to keep the business risk acceptable to the Product Owner.
    1. [ ] Short enough to be able to synchronize the development work with other business events.
    1. [ ] No more than one calendar month.
    1. [x] All of these answers are correct.

    ### The time-box for a Daily Scrum is?

    1. [ ] The same time of day every day.
    1. [ ] Two minutes per person.
    1. [ ] 4 hours.
    1. [x] 15 minutes.
    1. [ ] 15 minutes for a 4 week sprint. For shorter Sprints it is usually shorter.

    ### Who is required to attend the Daily Scrum?

    1. [x] The Development Team.
    1. [ ] The Scrum team.
    1. [ ] The Development Team and Scrum Master.
    1. [ ] The Development Team and Product Owner.
    1. [ ] The Scrum Master and Product Owner.

    ### Which statement best describes Scrum?

    1. [ ] A complete methodology that defines how to develop software.
    1. [ ] A cookbook that defines best practices for software development.
    1. [x] A framework within which complex products in complex environments are developed.
    1. [ ] A defined and predictive process that conforms to the principles of Scientific Management.

    ### Which of the below are roles on a Scrum Team?

    - [x] Development Team
    - [ ] Users
    - [ ] Customers
    - [x] Product Owner
    - [x] Scrum Master

    ### The Product Backlog is ordered by:

    1. [ ] Size, where small items are at the top and large items are at the bottom.
    1. [ ] Risk, where safer items are at the top, and riskier items are at the bottom
    1. [ ] Least valuable items at the top to most valuable at the bottom.
    1. [ ] Items are randomly arranged.
    1. [x] Whatever is deemed most appropriate by the Product Owner.

    ### When might a Sprint be abnormally terminated?

    1. [ ] When it becomes clear that not everything will be finished by the end of the Sprint.
    1. [ ] When the Development Team feels that the work is too hard.
    1. [ ] When the sales department has an important new opportunity.
    1. [x] When the Sprint Goal becomes obsolete.

    ### Who has the final say on the order of the Product Backlog?

    1. [ ] The Stakeholders
    1. [ ] The Development Team
    1. [ ] The Scrum Master
    1. [x] The Product Owner
    1. [ ] The CEO

    ### The CEO asks the Development Team to add a "very important" item to a Sprint that is in progress. What should the Development Team do?

    1. [ ] Add the item to the current Sprint without any adjustments.
    1. [ ] Add the item to the current Sprint and drop an item of equal size.
    1. [ ] Add the item to the next Sprint.
    1. [x] Inform the Product Owner so he/she can work with the CEO.

</div>
</pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="test-driven-development"><a class="header" href="#test-driven-development">Test Driven Development</a></h1>
<!-- toc -->
<h2 id="tesztelés"><a class="header" href="#tesztelés">Tesztelés</a></h2>
<p>Az alábbi ábra mutatja a tesztelések eloszlását hagyományos és agilis fejlesztéseknél. Az egész lényege, hogy minél előbb és a fejlesztőhöz a lehető legközelebb derüljön ki a hiba, mert annál gyorsabb és olcsóbb annak javítása. Könnyen belátható, hogy egy leszállított terméket kell visszahívni az körülményesebb mintha a fejlesző a <em>run tests</em> gombra nyomva azonnal, helyben az adott kód részlet írása közben (amikor még az a kontextus van a fejében) kap egy képet arról, hogy mi nem jó.
De még midnig jobb ha pl. sprinten belül egy automatizált integrációs teszt fogja meg a hibát, stb.</p>
<p><img src="http://www.adapttransformation.com/wp-content/uploads/flippyramid.png" alt="test pyramids" /></p>
<h2 id="tdd"><a class="header" href="#tdd">TDD</a></h2>
<p><img src="https://miro.medium.com/max/988/0*rxhD9QmJ6dBghRj1." alt="" /></p>
<ul>
<li><a href="https://www.guru99.com/test-driven-development.html">What is Test Driven Development?</a></li>
<li><a href="http://agiledata.org/essays/tdd.html">Introduction to Test Driven Development (TDD)</a></li>
<li><a href="https://www.agilealliance.org/glossary/tdd">TDD</a></li>
<li><a href="http://butunclebob.com/ArticleS.UncleBob.TheThreeRulesOfTdd">TDD Laws</a>
<ul>
<li>Az eredeti egy refaktorált verziója <a href="http://www.javiersaldana.com/articles/tech/refactoring-the-three-laws-of-tdd">innen</a>:
<ol>
<li>Write production code only to make a failing unit test pass.</li>
<li>Write only enough of a unit test to fail.</li>
<li>Write only enough production code to make the failing unit test pass.</li>
</ol>
</li>
</ul>
</li>
<li><a href="https://en.wikipedia.org/wiki/Test-driven_development">TDD wikiről</a></li>
</ul>
<h2 id="tdd-cycle"><a class="header" href="#tdd-cycle">TDD cycle</a></h2>
<!-- ![](https://miro.medium.com/max/978/1*jFw7ZZMoVcsEYM_fS33DBA.gif) -->
<p><img src="lectures/../images/tdd.png" alt="" title="TDD mantra: red, green, refactor" /></p>
<blockquote>
<p>As the tests get more specific, the code gets more generic.</p>
<p>-- <a href="https://sites.google.com/site/unclebobconsultingllc/home/articles/as-the-tests-get-more-specific-the-code-gets-more-generic">Uncle Bob</a></p>
</blockquote>
<h2 id="red"><a class="header" href="#red">Red</a></h2>
<ul>
<li>tesztelj egyszerre egy dolgot</li>
<li>a teszt legyen nagyon egyszerű</li>
<li>folyamatosan növeld teszt(esetek) komplexitását</li>
<li><a href="lectures/./legacy_code.html#mocking">mockold a függőségeket</a></li>
</ul>
<h3 id="writing-unit-tests"><a class="header" href="#writing-unit-tests">Writing Unit Tests</a></h3>
<ul>
<li><a href="https://medium.com/@justborromeo/writing-unit-tests-for-dummies-e4282bbfef7c">Writing Unit Tests For Dummies</a></li>
<li><a href="http://www.vogella.com/tutorials/JUnit/article.html">Unit Testing with Junit</a></li>
</ul>
<h2 id="green"><a class="header" href="#green">Green</a></h2>
<ul>
<li>a lehető legegszerűbb kóddal felelj meg a teszt által támasztott követelménynek</li>
<li>nem baj ha csúnya, ebben a lépésben csak az számít, hogy a teszt ne bukjon</li>
<li>amint a teszt zöld (és másik sem bukik), ez a fázis kész</li>
</ul>
<h2 id="refactor"><a class="header" href="#refactor">Refactor</a></h2>
<ul>
<li><a href="https://martinfowler.com/books/refactoring.html">Refactoring by Martin Fowler</a></li>
<li><a href="https://web.archive.org/web/20170606150219/http://www.integralist.co.uk/posts/refactoring-techniques.html">Refactoring methods</a></li>
<li><a href="https://refactoring.com/catalog/">Refactoring methods</a></li>
<li><a href="http://www.methodsandtools.com/archive/archive.php?id=4">Refactoring Java Code</a></li>
<li><a href="https://www.targetprocess.com/blog/2009/11/refactoring-vs-rewrite/">Refactoring vs. Rewrite</a></li>
</ul>
<h3 id="transformation-priority-premise"><a class="header" href="#transformation-priority-premise">Transformation Priority Premise</a></h3>
<p>Beragadás esetén visszalépés, vagy másik módszert kell választani. A beragadás megelőzésére van a TPP.</p>
<ul>
<li><a href="https://blog.cleancoder.com/uncle-bob/2013/05/27/TheTransformationPriorityPremise.html">Robert C. Martin (Uncle Bob) írása</a>, összefoglalásul pedig a transformációk:
<ol>
<li>({} -&gt; nil) no code at all -&gt; code that employs nil</li>
<li>(nil -&gt; constant)</li>
<li>(constant -&gt; constant+) a simple constant to a more complex constant</li>
<li>(constant -&gt; scalar) replacing a constant with a variable or an argument</li>
<li>(statement -&gt; statements) adding more unconditional statements.</li>
<li>(unconditional -&gt; if) splitting the execution path</li>
<li>(scalar -&gt; array)</li>
<li>(array -&gt; container)</li>
<li>(statement -&gt; tail-recursion)</li>
<li>(if -&gt; while)</li>
<li>(expression -&gt; function) replacing an expression with a function or algorithm</li>
<li>(variable -&gt; assignment) replacing the value of a variable.</li>
</ol>
</li>
<li><a href="https://vimeo.com/97516288">Advanced TDD: The Transformation Priority Premise</a>
<ul>
<li>1 órás videó, Robert C. Martintól</li>
</ul>
</li>
</ul>
<h2 id="coding-dojo"><a class="header" href="#coding-dojo">Coding Dojo</a></h2>
<ul>
<li><a href="https://medium.com/@lucascaixeta/coding-dojo-4e0b1ea69735">Coding Dojo</a></li>
</ul>
<h2 id="egyéb-a-tdd-hez-lazábban-kapcsolódó-anyagok"><a class="header" href="#egyéb-a-tdd-hez-lazábban-kapcsolódó-anyagok">Egyéb a TDD-hez (lazábban) kapcsolódó anyagok</a></h2>
<ul>
<li>Behavior Driven Development
<ul>
<li>Ez a TDD kiterjesztése, lényege, hogy a megrendelővel (és nem is annyira egy menedzserrel, hanem sokkal inkább egy domain szakértőjével) való egyeztetés folyamán, egy strukturált, ám természetes nyelvi szöveggel leírt „szabályok” formájában kerül leírásra az elvárt működés. Ezek alapján aztán a fejlesztő <em>több tesztet is ír</em> (szemben a TDD-vel, ahogy egyszerre szigorúan egyet), majd a tesztek összességének megfelelő kódot ír</li>
<li><a href="https://www.toptal.com/freelance/your-boss-won-t-appreciate-tdd-try-bdd">TDD vs. BDD</a></li>
<li><a href="https://en.wikipedia.org/wiki/Behavior-driven_development">Wikipédia BDD cikke</a></li>
<li><a href="https://www.agilealliance.org/glossary/bdd/">Agile alliance összefoglalója a BDD-ről</a></li>
</ul>
</li>
<li><a href="http://tom.preston-werner.com/2010/08/23/readme-driven-development.html">Readme Driven Development</a>
<ul>
<li>Különösen ajánlom elolvasni, kb. egy oldal</li>
</ul>
</li>
<li><a href="http://www.methodsandtools.com/archive/archive.php?id=72">Acceptance Test Driven Development (ATDD)</a></li>
<li><a href="https://www.destroyallsoftware.com/talks/ideology">types vs. tests</a>
<ul>
<li>video ~21 min</li>
</ul>
</li>
<li><a href="https://dmerej.info/blog/post/trying-mypy/">I don't need types</a>
<ul>
<li>blogposzt a típusosságról</li>
</ul>
</li>
</ul>
<!--
https://diveintopython3.net/unit-testing.html
![](https://www.agilecoachjournal.com/wp-content/uploads/2014/01/AgileTestingPyramid2.jpg)
-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="legacy-code"><a class="header" href="#legacy-code">Legacy code</a></h1>
<p>Ez a fejezet gyakorlatilag teljes egészében Michael Feathers <em>Working Efficiently with Legacy Code</em> c. könyvén alapszik. <a href="https://www.slideshare.net/nashjain/working-effectively-with-legacy-code-presentation">Itt elérhető</a> egy prezentáció a szerzőtől.</p>
<!-- toc -->
<!--
- [Jeremy Thurgood „Surviving a Legacy Codebase” című prezentációja](https://jerith.github.io/pyconza2017-surviving-a-legacy-codebase/#/)
    - Ez egy `reveal.js` prezentáció, a fejezetek között a jobbra/balra nyilakkal, a fejezeteken belül a fel/le nyilakkal lehet lépkedni, vagy simán space-el végig lehet nyomogatni mint egy PowerPoint prezit.
    - Mivel egy Python konferencián hangzott el, ami pár sornyi kód szerepel benne, az Python-ul van.
-->
<h2 id="mi-a-legacy-code"><a class="header" href="#mi-a-legacy-code">Mi a Legacy Code?</a></h2>
<blockquote>
<p>Code without tests is bad code. It doesn’t matter how well written it is; it doesn’t matter how pretty or object-oriented or well-encapsulated it is. With tests, we can change the behavior of our code quickly and verifiably. Without them, we really don’t know if our code is getting better or worse.</p>
<p>-- Feathers, M. (2004). Working Effectively with Legacy Code: Preface</p>
</blockquote>
<ul>
<li><a href="https://dzone.com/articles/defining-legacy-code">További definíciók</a></li>
<li>Legacy Code
<ul>
<li><a href="http://programmers.stackexchange.com/questions/122014/what-are-the-key-points-of-working-effectively-with-legacy-code">What are the key points of Working Effectively with Legacy Code?</a></li>
<li><a href="http://www.slideshare.net/nashjain/working-effectively-with-legacy-code-presentation">Working Effectively With Legacy Code</a>
<ul>
<li>prezentáció</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="the-legacy-code-dilemma"><a class="header" href="#the-legacy-code-dilemma">The Legacy Code Dilemma</a></h3>
<blockquote>
<p>When we change code, we should have tests in place. To put tests in place, we often have to change code.</p>
<p>-- Feathers, M. (2004). Working Effectively with Legacy Code: Part I / Chapter 2</p>
</blockquote>
<h3 id="code-smells"><a class="header" href="#code-smells">Code Smells</a></h3>
<ul>
<li><a href="https://blog.codinghorror.com/code-smells/">Code Smells</a></li>
</ul>
<h2 id="changing-software"><a class="header" href="#changing-software">Changing Software</a></h2>
<blockquote>
<div class="table-wrapper"><table><thead><tr><th></th><th>adding a feature</th><th>fix a bug</th><th>refactor</th><th>optimizing</th></tr></thead><tbody>
<tr><td>structure</td><td>changes</td><td>changes</td><td>changes</td><td></td></tr>
<tr><td>functionality</td><td>changes</td><td></td><td></td><td></td></tr>
<tr><td>new funcionality</td><td></td><td>changes</td><td></td><td></td></tr>
<tr><td>resource usage</td><td></td><td></td><td></td><td>changes</td></tr>
</tbody></table>
</div>
<p>-- Feathers, M. (2004). Working Effectively with Legacy Code: WORK EFFECT LEG CODE p1. pp 6. Prentice Hall Professional.</p>
</blockquote>
<h2 id="the-legacy-code-algorithm"><a class="header" href="#the-legacy-code-algorithm">The legacy code algorithm</a></h2>
<ul>
<li><a href="https://bssw.io/items/working-effectively-with-legacy-code">Working Effectively with Legacy Code</a></li>
<li><a href="https://wikimatze.de/books/working-effectively-with-legacy-code/">Matthias Günther jegyzetei a „Working Effectively with Legacy Code” könyvből</a></li>
<li><a href="https://gist.github.com/jeremy-w/6774525">Jeremy W. Sherman jegyzetei a „Working Effectively with Legacy Code” könyvből</a></li>
</ul>
<h2 id="sensing--separation"><a class="header" href="#sensing--separation">Sensing &amp; Separation</a></h2>
<blockquote>
<ol>
<li>Sensing — We break dependencies to sense when we can’t access values our code computes.</li>
<li>Separation — We break dependencies to separate when we can’t even get a piece of code into a test harness to run.</li>
</ol>
<p>-- Feathers, M. (2004). Working Effectively with Legacy Code: Part I / Chapter 3</p>
</blockquote>
<h2 id="mocking"><a class="header" href="#mocking">Mocking</a></h2>
<ul>
<li><a href="http://blog.tremblay.pro/2017/09/mocks.html">Type of Mocks</a></li>
<li><a href="https://blog.pragmatists.com/test-doubles-fakes-mocks-and-stubs-1a7491dfa3da">Test Doubles — Fakes, Mocks and Stubs</a>
<ul>
<li>ez egy másik írás, bővebb, ábrákkal, Java kódokkal...</li>
</ul>
</li>
<li><a href="http://www.martinfowler.com/bliki/TestDouble.html">Test Doubles</a>
<ul>
<li>az úriember blogján egyébként rengeteg hasonló hosszúságú, elég releváns bejegyzés van</li>
</ul>
</li>
<li><a href="https://github.com/mockito/mockito/wiki/How-to-write-good-tests">How to write good tests</a></li>
</ul>
<h2 id="seams"><a class="header" href="#seams">Seams</a></h2>
<blockquote>
<p>A seam is a place where you can alter behavior in your program without editing in that place.</p>
<p>-- Feathers, M. (2004). Working Effectively with Legacy Code: Part I / Chapter 4</p>
</blockquote>
<ul>
<li><a href="https://medium.com/@biratkirat/working-effectively-with-legacy-code-changing-software-part-1-chapter-4-b997b78fc0a2">Nagyon rövid kivonata a Working Effectively with Legacy Code 1. rész / 4. fejezetének</a></li>
</ul>
<h1 id="solid"><a class="header" href="#solid">SOLID</a></h1>
<p><img src="https://devopedia.org/images/article/177/8101.1558682601.png" alt="" /></p>
<ul>
<li><a href="http://www.codemag.com/article/1001061">S.O.L.I.D. Software Development, One Step at a Time</a>
<ul>
<li>igen részletes írás</li>
</ul>
</li>
<li><a href="https://devopedia.org/solid-design-principles">SOLID Design Principles</a></li>
<li><a href="https://youtu.be/llGgO74uXMI">Core Design Principles for Software Developers by Venkat Subramaniam</a>
<ul>
<li>Hosszabb (2,5 órás) előadás, a <a href="https://www.youtube.com/watch?v=llGgO74uXMI&amp;feature=youtu.be&amp;t=3353">Single Responsibility</a> inenntől, ez olyan 25 perc</li>
</ul>
</li>
</ul>
<!--
- [**S**ingle-responsibility principle](https://en.wikipedia.org/wiki/Single-responsibility_principle)
- [**O**pen–closed principle](https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle)
- [**L**iskov substitution principle](https://en.wikipedia.org/wiki/Liskov_substitution_principle)
- [**I**nterface segregation principle](https://en.wikipedia.org/wiki/Interface_segregation_principle)
- [**D**ependency inversion principle](https://en.wikipedia.org/wiki/Dependency_inversion_principle)

https://softwareengineering.stackexchange.com/questions/122014/what-are-the-key-points-of-working-effectively-with-legacy-code
-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="review-1"><a class="header" href="#review-1">Review</a></h1>
<p><img src="https://i.pinimg.com/originals/e2/7e/30/e27e30d4a5664bc266aff8b03ccc4028.jpg" alt="" /></p>
<p>Az első két cikk inkább technikai, számokkal meg minden, a harmadik (ez kétrészes), sokkal inkább az emberi oldalt taglalja, igen jól!</p>
<ul>
<li><a href="https://smartbear.com/learn/code-review/what-is-code-review/">What is Code Review?</a></li>
<li><a href="https://smartbear.com/learn/code-review/best-practices-for-peer-code-review/">Best Practices for Code Review</a></li>
<li><a href="https://mtlynch.io/human-code-reviews-1/">How to Do Code Reviews Like a Human (Part One)</a>
<ul>
<li><a href="https://mtlynch.io/human-code-reviews-2/">Part Two</a></li>
</ul>
</li>
<li><a href="https://phauer.com/2018/code-review-guidelines/">Code Review Guidelines for Humans</a></li>
<li><a href="https://www.evoketechnologies.com/blog/code-review-checklist-perform-effective-code-reviews/">Code Review Checklist – To Perform Effective Code Reviews</a></li>
</ul>
<h2 id="review-típusok"><a class="header" href="#review-típusok">Review típusok</a></h2>
<ul>
<li><a href="http://tryqa.com/what-are-the-types-of-review/">What are the types of review?</a>
<ul>
<li>Nem említi az informálist</li>
</ul>
</li>
<li><a href="https://www.slideshare.net/Chandukar/istqb-foundation-chapter-3">Prezentáció a review typusokról, hasonlóan tárgyalja mint a Bosch-os</a>
<ul>
<li>a 27. diáig ajánlom</li>
</ul>
</li>
<li><a href="http://tryqa.com/what-is-formal-review/">Formális review részei</a></li>
</ul>
<h3 id="sorrendben"><a class="header" href="#sorrendben">Sorrendben</a></h3>
<ol>
<li>informal
<ul>
<li>Ez akár csak annyi, hogy megkérsz egy kollégát, hogy „nézz már rá erre picit, szerinted ez így jó?”, gyorsan tud valami visszajelzést adni, de semmi nyoma nem marad. A pair programming folyamatos informális review.</li>
</ul>
</li>
<li><a href="http://tryqa.com/what-is-walkthrough-in-software-testing/">walkthrough</a>
<ul>
<li>a GitHub-os review majdnem ezen a szinten van, visszakövethető módon dokumentált a GitHub felületének hála, bár nem egy meeting folyamán történik a review, hanem egyénileg, szigorú protokoll nélkül. (Vezetője sincs, bár lehetne úgy is csinálni.)</li>
</ul>
</li>
<li><a href="http://tryqa.com/what-is-technical-review-in-software-testing/">technical</a></li>
<li><a href="http://tryqa.com/what-is-inspection-in-software-testing/">inspection</a></li>
</ol>
<h3 id="Összefoglaló-táblázat-a-fentebbiek-alapján"><a class="header" href="#Összefoglaló-táblázat-a-fentebbiek-alapján">Összefoglaló táblázat a fentebbiek alapján</a></h3>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">type</th><th style="text-align: center">formality</th><th style="text-align: center">led by</th><th style="text-align: center">effort</th><th style="text-align: center">documentation</th></tr></thead><tbody>
<tr><td style="text-align: center">informal</td><td style="text-align: center">not formal</td><td style="text-align: center">noone</td><td style="text-align: center">minimal</td><td style="text-align: center">undocumented</td></tr>
<tr><td style="text-align: center">walkthrough</td><td style="text-align: center">not formal<sup class="footnote-reference"><a href="#1">1</a></sup></td><td style="text-align: center">authors</td><td style="text-align: center">very low</td><td style="text-align: center">normal, fault-finding</td></tr>
<tr><td style="text-align: center">technical</td><td style="text-align: center">less formal</td><td style="text-align: center">trained moderator, NOT the author</td><td style="text-align: center">moderate</td><td style="text-align: center">more detailed</td></tr>
<tr><td style="text-align: center">inspection</td><td style="text-align: center">most formal</td><td style="text-align: center">trained moderator</td><td style="text-align: center">high</td><td style="text-align: center">thorough; based on  standards, checklists</td></tr>
</tbody></table>
</div>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup></div>
<p>Sometimes it can be somewhat formal.</p>
<!--
https://www.cs.jhu.edu/~jorgev/cs106/bug.pdf
https://www.slideshare.net/philipmjohnson/06softwarereview
https://stackoverflow.com/questions/3533348/how-does-this-code-generate-the-map-of-india
https://www.tutorialspoint.com/software_testing_dictionary/code_walkthrough.htm
-->
<hr />
<!-- https://spectrum.ieee.org/aerospace/aviation/how-the-boeing-737-max-disaster-looks-to-a-software-developer -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="continuous-integration"><a class="header" href="#continuous-integration">Continuous Integration</a></h1>
<ul>
<li><a href="https://www.atlassian.com/continuous-delivery/continuous-integration">What is Continuous Integration</a></li>
<li><a href="https://martinfowler.com/articles/continuousIntegration.html">Continuous Integration</a></li>
</ul>
<p><img src="https://pepgotesting.com/wp-content/uploads/2015/02/CI.png" alt="" /></p>
<p>Ennek alapja a verziókövetés, a fejlesztő pusholja a módosításait a szerverre, amely lefordítja a kódot, lefuttatja a teszteket (és egyéb elemzéseket), ezek sikerességéről visszajelzést ad. Kicsit bővebben <a href="lectures/ci.html#ci-k%C3%B6rnyzet">itt</a>.</p>
<h2 id="interrupts"><a class="header" href="#interrupts">Interrupts</a></h2>
<p><img src="https://i0.wp.com/www.brightdevelopers.com/wp-content/uploads/2018/05/ProgrammerInterrupted.png?resize=267%2C1024&amp;ssl=1" alt="interrupt_comic" /></p>
<p><a href="https://www.brightdevelopers.com/the-cost-of-interruption-for-software-developers/">The Cost of Interruption for Software Developers</a></p>
<p>Az automatizálás csökkenti az interruptokat, a költségeket és azonnali visszajelzést ad!</p>
<h2 id="automation"><a class="header" href="#automation">Automation</a></h2>
<ul>
<li><a href="https://www.developerdotstar.com/mag/articles/automate_software_process.html">Automating Software Development Processes</a></li>
</ul>
<!--how does it work

version control
build automation
self-stesting-->
<h2 id="build-scripts"><a class="header" href="#build-scripts">Build scripts</a></h2>
<p>Az egész CI/CD lelke egy adag script, amelyben le vannak írva az automatizált lépések. Úgy mint...</p>
<ul>
<li>kód fordítása (make, maven, stb.)</li>
<li>bináris előállítása</li>
<li>statikus kódelemzés futtatása, pl. MISRA, Checkstyle</li>
<li>tesztlefedettség kiszámolását végző szoftver futtatása</li>
<li>riport generálás a feedbackhez a fejlesztőnek, menedzsmentnek, megrendelőnek</li>
<li>stb.</li>
<li>ezek futása lehet...
<ul>
<li>on demand: jellemzően a CI környezetekben kézzel is újra lehet futtatni egy adott <em>job</em>-ot</li>
<li>ütemezett: adott időben ütemezetten fusson (lásd nightly buildek). Pl. egy teljes rendszer teszt, amely akár órákon át is futhat, azt célszerű lehet szó szerint éjjel futtatni, és a reggeli munkakezdésre van egy riport arról, hogy az előző napi változtatások mit törtek el (pl.)</li>
<li>triggerelt: valamilyen esemény hatására fusson le. Pl. egy commit-ra, így minden pusholt commit-ra lefuthatnak a különböző szintű tesztek, statikus kódellenőrzés, stb.</li>
</ul>
</li>
</ul>
<h2 id="software-testing"><a class="header" href="#software-testing">Software Testing</a></h2>
<ul>
<li><a href="https://www.guru99.com/software-testing-introduction-importance.html">What is Software Testing? Introduction, Definition, Basics &amp; Types </a>
<ul>
<li>Végig lehet lépkedni az egyes fejezeteken, igen jól kimeríti a témát, olyan fejezetei is vannak, amire az előadás nem tért ki.</li>
<li>Több fejezetére specifikusan másutt is hivatkozok</li>
</ul>
</li>
</ul>
<h2 id="test-strategies"><a class="header" href="#test-strategies">Test Strategies</a></h2>
<p><img src="https://artoftesters.files.wordpress.com/2014/02/gbt11.jpg" alt="" /></p>
<ul>
<li><a href="https://artoftesters.wordpress.com/2014/02/03/black-vs-white-vs-gray-box-testing/">Black vs White vs Gray Box Testing</a></li>
<li><a href="https://www.guru99.com/white-box-testing.html">What is WHITE Box Testing? Techniques, Example, Types &amp; Tools</a></li>
</ul>
<h2 id="automated-testing"><a class="header" href="#automated-testing">Automated Testing</a></h2>
<p><img src="https://artoftesting.com/wp-content/uploads/2019/12/automation-testing-process.jpg" alt="" /></p>
<ul>
<li><a href="https://artoftesting.com/automation-testing">Automation Testing Tutorial</a></li>
<li><a href="https://www.atlassian.com/continuous-delivery/software-testing/types-of-software-testing">The different types of tests </a></li>
</ul>
<h2 id="integration-testing"><a class="header" href="#integration-testing">Integration Testing</a></h2>
<p><a href="https://www.guru99.com/integration-testing.html">Remek összeföglaló a témában</a>, amely kitér a megközelítésekre: Bottom-up, Top-down, Hybrid/Sandwich, Big Bang.</p>
<!--## Feature Testing -->
<h2 id="system-testing"><a class="header" href="#system-testing">System Testing</a></h2>
<ul>
<li><a href="https://www.guru99.com/system-testing.html">System testing</a></li>
<li><a href="https://christophergs.com/machine%20learning/2019/03/30/deploying-machine-learning-applications-in-shadow-mode/#what">shadow deploy</a></li>
</ul>
<h3 id="software-in-the-loop-sil"><a class="header" href="#software-in-the-loop-sil">Software-in-the-loop (SIL)</a></h3>
<p><img src="https://d3e3a9wpte0df0.cloudfront.net/wp-content/uploads/2018/09/Software-in-the-loop.png" alt="" /></p>
<p>forrás: <a href="https://www.intellias.com/three-ways-of-testing-adas-in-autonomous-cars-beyond-a-test-drive/">autonóm autofejlesztés tesztelése</a></p>
<h3 id="hardware-in-the-loop-hil"><a class="header" href="#hardware-in-the-loop-hil">Hardware-in-the-loop (HIL)</a></h3>
<p><img src="https://d3e3a9wpte0df0.cloudfront.net/wp-content/uploads/2018/09/Hardware-in-the-loop.png" alt="" /></p>
<p>forrás: <a href="https://www.intellias.com/three-ways-of-testing-adas-in-autonomous-cars-beyond-a-test-drive/">autonóm autofejlesztés tesztelése</a></p>
<h2 id="acceptance-testing"><a class="header" href="#acceptance-testing">Acceptance Testing</a></h2>
<ul>
<li><a href="http://softwaretestingfundamentals.com/acceptance-testing/">Acceptance Testing</a></li>
<li><a href="https://www.softwaretestinghelp.com/what-is-acceptance-testing/">What is Acceptance Testing</a></li>
</ul>
<h2 id="smart-objectives"><a class="header" href="#smart-objectives">SMART Objectives</a></h2>
<p><a href="https://en.wikipedia.org/wiki/SMART_criteria"><img src="http://1.bp.blogspot.com/-GFk16TOMYpg/Vobum9UYB5I/AAAAAAAADJE/W76uhsirM64/s1600/SMART-Goals.jpg" alt="" /></a></p>
<h1 id="continuous-deployment"><a class="header" href="#continuous-deployment">Continuous Deployment</a></h1>
<ul>
<li><a href="https://thenewstack.io/deployment-strategies/">Six Strategies for Application Deployment</a></li>
<li><a href="https://featureflags.io/2015/11/03/feature-flag-driven-development-by-justin-launchdarkly/">Feature Flag Driven Development</a>
<ul>
<li>
<blockquote>
<p>This article provides a broad and comprehensive overview of feature flag driven development, from gradual rollouts to A/B testing.</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h1 id="continuous-delivery"><a class="header" href="#continuous-delivery">Continuous Delivery</a></h1>
<ul>
<li><a href="https://www.linkedin.com/pulse/continuous-delivery-vs-traditional-release-model-szczepan-faber">Continuous delivery VS traditional release model</a></li>
</ul>
<h1 id="devops"><a class="header" href="#devops">DevOps</a></h1>
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/0/05/Devops-toolchain.svg/1200px-Devops-toolchain.svg.png" width="70%"/>
<ul>
<li><a href="https://theagileadmin.com/what-is-devops/">What Is DevOps?</a></li>
<li><a href="https://thenewstack.io/category/devops/">DevOps</a></li>
</ul>
<h1 id="alkalmazott-eszközök"><a class="header" href="#alkalmazott-eszközök">Alkalmazott eszközök</a></h1>
<p>A tárgyhoz használt tényleges eszközök, mondhatjuk, hogy a fentiek (egy részének) gyakorlati alkalmazása.</p>
<h2 id="ci-környzet"><a class="header" href="#ci-környzet">CI környzet</a></h2>
<p>Korábban <a href="https://travis-ci.org/">Travis CI</a>, újabban (mióta van) <a href="https://help.github.com/en/actions/getting-started-with-github-actions/about-github-actions">GitHub Actions</a>.</p>
<p>A commit(ok) pusholása esemény hatására elindul a build környezet, ez egy Ubuntu linux, amely tartalmazza a Java fejlesztői környezetet (JDK) és a fordítást menedzselő eszközt (Maven). Leklónozza a repót, kiválasztja a kérdéses branch-et, lefordítja a kódot, lefuttatja a teszteket, meghívja a statikus kódelemzőt és a tesztlefedettség elemzőt, az előállt riportokat elküldi az ezt nyilvántartó szolgáltatásoknak. Ha valamennyi teszt sikeres, akkor zöld jelzést ad. (A Jenkins időjárásikonokat használ historikusságot is figyelembe véve: sok egymást követő bukó teszt (viharfelhők) után egy sikeres még nem jelent azonnal napocskát...)</p>
<p><img src="lectures/../images/ci.png" alt="CI környezet" /></p>
<p>A Pull Request-ek elfogadásának feltétele a fordítható kód és a sikeres tesztek, de a statikus kódelemző és a tesztlefedettség elemző visszajelzése is megjelenik (automatizált review formájában). Ugyanilyen automatizált review-nak tekinthető az is, hogy van-e kódütközés.</p>
<p>Ezeken kívül a kollégák manuális review-ja is szükséges (2 approve), lásd review protokol.</p>
<h3 id="példák"><a class="header" href="#példák">Példák</a></h3>
<ul>
<li><a href="https://github.com/SzFMV2020-Tavasz/AutomatedCar-A/blob/master/.travis.yml">Nagyon egyszerű konfigurációs állomány Travis-hez</a></li>
<li><a href="https://github.com/SzFMV2020-Tavasz/AutomatedCar-A/blob/master/.github/workflows/maven.yml">Aktuális GitHub Actions konfiguráció</a></li>
</ul>
<h2 id="statikus-kódelemzés"><a class="header" href="#statikus-kódelemzés">Statikus kódelemzés</a></h2>
<p>A statikus kódelemzést Java nyelvhez a Checkstyle végzetre, C#-hoz a StyleCop, ez lokálisan (lásd fejlesztőeszközök fejezet) is működik, a változások követéséhez és mindenféle riport generálásához (első sorban a Pull Requestekhez) a <a href="https://www.codefactor.io/">CoceFactor.io</a> van bekötve. Ez össze van linkelve a GitHubbal repóval, a commit triggerre saját környezetben kicsekkolja az aktuális branchet, lefuttatja a Checkstyle-t (és adott esetben más elemzőket is), majd elkészíti a riportokat.</p>
<h2 id="tesztlefedettség"><a class="header" href="#tesztlefedettség">Tesztlefedettség</a></h2>
<p>A Java kódunk tesztekkel való lefedettségét Java nyelvhez a JaCoCo (Java Code Coverage) nevű szoftver számolta ki, C#-hoz a Coverlet. Szintén működik lokálisan is (lásd fejlesztőeszközök fejezet), a CodeFactorhoz hasonló online riportgeneráló amit a repónkhoz beállítottam az a <a href="https://codecov.io/">CodeCov</a>. Az előbbivel analóg módon működik.</p>
<h2 id="stale-bot"><a class="header" href="#stale-bot">Stale bot</a></h2>
<p>A <a href="https://probot.github.io/apps/stale/">stale bot</a> funkciója, hogy a magára hagyott hibajegyeket (issue) megjelöli „megrekedt” (stale) állapottal (címkével), ha adott ideig (nálunk 1 hét) nem volt vele kapcsolatos aktivitás. Ez alól kivételt képeznek a „user story” címkéjű issue-k.</p>
<p>A konfigurációja a repó <a href="https://github.com/SzFMV2020-Tavasz/AutomatedCar-A/blob/master/.github/stale.yml"><code>.github/stale.yaml</code></a> fájljában található.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mindmap-1"><a class="header" href="#mindmap-1">MindMap</a></h1>
<p>Összefoglaláshoz, gyors áttekintéshez használható, az előadásanyagot többé-kevésbé lefedő <em>mindmap</em>. Egérgörgővel nagyítható/távolítható és canvas-on belül szabadon mozgatható.</p>
<p><svg id="markmap-target" style="width: 100%; height: 75vh;"></svg></p>
<div id="markmap-source" hidden>
<pre><code># SzFMV


## Agile

- SCRUM
    - Roles
        - Scrum Master
            - Developer Representative
            - Impediment handler
            - Facilitator
            - Ensures calm and uninterrupted working
        - Product Owner
            - Customer Representative
            - Creates PB
            - Prioritizese PB
        - Developer
        - Team
            - Self-organizing
            - Cross-functional
    - Epic
        - User Story
            - Task
    - Events
        - Sprint Planning
        - Daily Standup
            - 3 questions
            - TimeBox
            - Always on the same time and at the same place
            - Standing up
        - Backlog Grooming
            - Refinement of User Story DoD
                - SMART goals
            - Effort estimation
        - Retrospective
        - Demo
        - Sprint Review
    - Artifacts
        - Sprint Backlog
        - Product Backlog
        - Sprint Goal
        - Definition of Done
        - Burndown Chart
        - Board
- Kanban
    - Continuous (not iterative)
    - No roles, no events
    - Board necessary - pick top right task
- Culture / Mindset
    - Agile Manifesto
        - Agile Principles
    - Iterative
    - Change handling
- Waterfall / V-Model
- Business Value

## Clean Code

- Communication
    - understanding what it does
- Style Guideline
    - Naming
        - Variables
            - Why?
    - Function
        - Short functions
        - Does one thing
    - Scope
        - Functions - one scope
        - Variables - Scope
- Self Documenting - No comments
- Code Smells
    - Long function
    - Too many parameters
    - God Class
    - Boolean parameter
    - Magic number
    - Circular dependency
    - Too complex (cyclomatic complexity)
- Refactoring
    - Boy scout mantra

## Review

- What?
    - Requirement
    - Architecture
    - Design
    - Work events
    - Code
    - Everything
    - Work product - not the developer
- Why?
    - Avoid errors
- Who?
    - Anyone who's competent in the topic
- Levels
    - Formal
        - Traceable
        - Documented
        - Rule Based
        - Type
            - Walkthrough
            - Inspection
            - Technical
        - Dedicated roles
            - Minute taker
            - Expert
            - Moderator
    - Informal
        - Over the shoulder
        - Pair Programming
- Finding
    - Severe / Major
        - must be changed
    - Suggestion / Minor
        - may be changed
    - Question
        - WTF?
    - Action
        - Ignore
        - Fix
        - Answer
        - Explain
        - Promote
- Debug Ducky

## Legacy Code

- SOLID
    - Design Principles
        - **S**ingle Responsibility
        - **O**pen-closed
        - **L**iskov's Substitution
        - **I**nterface Segregation
        - **D**ependency Inversion
- Code without tests
    - Gets better or worse?
- Sprout
    - method
    - class
- Avoid, rewrite
- Legacy Code Dilemma
    - Can't change the code without adding tests
    - Have to change the code to add tests
- Seams
    - Change the behaviour without changing the code
    - Object Seam
    - Linker Seam
    - Preprocessor
- Reason of change
    - Performance
        - Optimization
    - Functionality
        - Bugfix
        - New Feature
    - Structure
        - Refactoring
- Overestimation
    - Get the oppurtunity to reverse legacy

## Test Driven Development

- Software Unit
    - Function
    - Class
    - Module
- Test Suite
    - Test Case
        - Test
            - Single Assert
            - Logical, not semantical
    - Fast as hell
        - ms fast
        - Effectiveness
        - Flow
- AAA(A) Rule
    - Arrange
        - Set up system under test
        - Dependencies
        - Mocking
            - Database
            - Hardware
            - Mock object
                - Dummy
                - Stub
                - Fake
                - Mock
                - Spy
    - Act
        - Do the needful
    - Assert
        - Expected vs. Actual
        - Single Assert
    - (Annihilate)
        - Free resource
- Red -&gt; Green -&gt; Refactor
    - Write a failing test
    - Make the test pass
        - Code Golf
        - As little code as possible
    - Refactor
- Fastest feedback
- Safety net
- Getting stuck
    - Transformation Priorities
- Done
    - Potato mantra

## Continuous Integration

- Interrupt
    - Loosing hours of work
- Workload reduction
- Work automation
- Structure
    - Version Tracking
        - Best Practices
            - Syncronize often
            - Small changes
            - Merge often
            - Independent tasks
    - Continuous Integration Server
        - Automatic Build
            - Jobs / Pipelines
        - Automatic Integration
        - Automatic Test
        - Automatic Release
        - Automatic Deploy
    - Feedback to stakeholders
- Trigger
    - Nightly Build
        - time based
    - Trigger
        - Push
        - Pull Request
    - Manual
- DevOps
    - Developers
    - Operations
- Integration Strategy
    - Bottom-Up
    - Top-Down
    - Big-Bang
    - Ricky-Hardest
- Levels
    - Unit
    - Integration
    - Feature
    - System
    - Acceptance
    - Manual

## Architecture
</code></pre>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="célkitűzés"><a class="header" href="#célkitűzés">Célkitűzés</a></h1>
<p><a href="https://www.youtube.com/watch?v=Xbjdmw8D9-Y"><img src="https://img.youtube.com/vi/Xbjdmw8D9-Y/0.jpg" alt="Konvoj" /></a></p>
<p>A fenti videó a Hyundai promóciós videója az olyan vezetéstámogató rendszereiről, mint az adaptív sebességtartó automatika, az automata vészfékező vagy a sávtartó automatika. A cél a fenti videón bemutatott tesztet teljesítő funkciók implementálása egy leegyszerűsített, szimulált környezetben.</p>
<h1 id="szoftver-leírása"><a class="header" href="#szoftver-leírása">Szoftver leírása</a></h1>
<p>The program simulates the behavior of a passenger vehicle on the public road, equipped with driver assistance functions.</p>
<p>Equipped driver assistance functions are Parking Assist, Adaptive Cruise Control with Automated Emergency Braking and Lane Keeping Assistance with Traffic Sign Recognition, based on Ultra Sonic, Radar and Video sensors, respectively.</p>
<p>The inputs are categorized into two separate groups: user input, and configuration.</p>
<p>User input consists of the following elements:</p>
<ul>
<li>Throttle button - gradually increasing while pressed, on a 1s duration from 0-&gt;100%, if not pressed, returns to idle</li>
<li>Brake  button - gradually increasing while pressed, on a 0.5s duration from 0-&gt;100%, if not pressed, returns to idle</li>
<li>Gear Shift - Automated, P/R/N/D available for choosing with a rotary button</li>
<li>Steering Buttons - left, right, gradually increasing while pressed on a 1s duration from 0-&gt;100%, in idle returns to straight</li>
<li>Driver Assistance Function Main Switches - On/Off, flip switch, changes state on press</li>
<li>ACC: Set/Resume/Plus/Minus/Time Gap switches, activating the function, changing the chosen reference speed, changing the chosen distance to the target vehicle, respectively</li>
<li>PA: Indicators to activate parking spot search, confirmation button to trigger automated parking maneuver</li>
</ul>
<p>Configuration input consist of the following elements:</p>
<ul>
<li>Description of world in an XML file, in a predefined language</li>
<li>"Tiles" - building blocks of the simulated world, such as roads, trees, people, vehicles, buildings, etc.</li>
<li>Position and behavior of non-player vehicles and characters</li>
<li>Position of the player vehicle</li>
</ul>
<p>The system processes the input configuration, builds a world from the provided elements after processing the content of the XML file, creating a coordinate system and defining the distances, sizes and positions of the objects in that, places the non-player vehicles and the player in the world, and cyclically updates their position, interrupting or replacing the driver input with the calculated actuation requests from the Driver Assistance systems, whenever applicable. The output consists of two parts: first, the world with all its objects, displayed through a camera view, which centers on the player, and follows its movements, second the feedback about the current state of the vehicle, including the following data:</p>
<ul>
<li>Current speed</li>
<li>Current gas, brake pedal position</li>
<li>Current steering wheel angle</li>
<li>Current gear</li>
<li>Indicator status</li>
<li>ACC: Set Speed, Time Gap level, Object detected (boolean), main status(on/off/controlling)</li>
<li>AEB: on/off status, visual warning signal (Yellow: probable collision, Red: automated braking active)</li>
<li>Parking assist: available(yellow),searching for place(blinking yellow), spot found(green), parking (blinking green), off (no signal)</li>
<li>LKA/TSR: On/Off, detected speed limit, detected warning sign, controlling steering(green), lane marking not available(yellow)</li>
</ul>
<p>The driver assistance systems apply actuation requests to the steering, drivetrain(engine, transmission) or both, of the ego vehicle. Said subsystems decide if the actuation request of the player or the driver assistance system shall be executed. The actuation request is calculated from the information detectable by the sensor the DA systems depend on. The Video, Radar and Ultrasonic sensors have specified Fields of View, and view distance, detect a different subset of objects. From the provided object list - simulating the real world hardware detection of radar wave reflection, image processing, ultrasonic reflection - the "software" components evaluate the control relevant subset, and if the conditions are fulfilled (i.e. function activated and driving in lane, object in ego lane in front of vehicle, relative speed negative, distance reducing as time passes by) the function requests actuation (in the above example, requests speed reduction from the drivetrain).</p>
<p>The system decides between the concurrent drivetrain requests based on comfort and safety aspects. The system shall handle and detect collisions between the objects of the world. The simulation is approximating the real world physics, to provide a satisfying driving experience for the player, and an appropriate demonstration of the work of the driver assistance systems. On demand, the field of view of the sensors, and the detected control objects may be marked on the display for debug or demonstration.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sprintek"><a class="header" href="#sprintek">Sprintek</a></h1>
<p>A félév során minden csapat 2 sprintet teljesít, minden sprintre egy-egy user story-t kap. 3 csapat esetén így a teljes elkészítendő szoftver 6 részre van bontva. A csapatok feladata a user story-k megértése, felbontása egyhuzamban elvégezhető feladatokra (task), ezekhez felelőst és határidőt rendelve.</p>
<p>Szintén a csapatok feladat a feladatok közötti függőségek azonosítása és az erőforrások (idő, fejlesztő) oly módon történő beosztása, hogy a határidőre minden elkészüljön. Az egyes user story-k között nem csak sprinteken átívelő függőségek lehetnek, hanem sprinten belüliek is. Ilyen esetben az érintett csapattal egyeztetve kell az egyes (rész)feladatok prioritásait meghatározni.</p>
<p><img src="sprints/../images/team_user_stories_new.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1-sprint"><a class="header" href="#1-sprint">1. Sprint</a></h1>
<!-- toc -->
<h2 id="mozgatás-hajtáslánc-és-kormányzás"><a class="header" href="#mozgatás-hajtáslánc-és-kormányzás">Mozgatás: hajtáslánc és kormányzás</a></h2>
<p>A <em>mozgatás</em> modul felelőssége a vezérelt autó (egocar) mozgatása, mozgásának számítása. Ez magába foglalja a hajtáslánc és a kormányzás megvalósítását.</p>
<p>A modul a HMI-től kap bemenetet, mindenek előtt váltóállás, gáz- és fékpedálállás valamint kormányelfordulás. A váltó automata, ami azzal jár, hogy a HMI a négy állapot (P, R, N, D) egyikét közli.</p>
<ul>
<li><strong>P</strong>ark: Ez az egyik olyan állapot amiben a motor beindítható (a másik az N), ez a váltó alapállása, mechanikusan megszünteti az erőátvitelt. A valóságban nem helyettesíti kéziféket, de mivel azt nem kell implementálni a feladat során, lehet úgy tekinteni, hogy P-ben a kézifék is be van húzva. Az autó nem mozdul ebben az állásban.</li>
<li><strong>R</strong>everse: hátramenet</li>
<li><strong>N</strong>eutral: üres, ebben az állásban sem jut a motorerő tengelyekre, a motor nem gyorsíthatja az autót. Ha üresben gázt adunk, a motor felpörög, méghozzá jelentősen, mivel nincs ami ellene dolgozna. Ha az autónak volt lendülete, az még hajtja tovább.</li>
<li><strong>D</strong>rive: előremenet. A D-m belül definiálni kell 4-5 belső fokozatot (mint ahogy manuális váltónál is lenne), le kell programozni, hogy valamilyen fordulatszám értékeknél a váltó váltson. Ezen értékek meghatározásához lehet találni motorkarakterisztikákat (lehetőség szerint utcai autó kerüljön kiválasztásra, ne valami sportautó). A belső fokozatok a felhasználó interfész szempontjából transzparensek.</li>
</ul>
<p>A pedál állások [0-100] skálán érkeznek. 0: nincs lenyomva, 1: 1%-ig van lenyomva, 100: tövig (100%-ig) le van nyomva. Minél jobban le van nyomva a gázpedál, annál több teljesítményt kell a motornak kiadnia. A motor belső működését nem kell részletekbe menően implementálni, pláne nem egy belső égésű motorét, egy elektromos hajtáslánc egyszerűbb.
A szoftverben üzemanyag-fogyasztást (vagy akkumulátor töltöttséget) és hatótávokat nem kell kezelni.</p>
<p>A kormány jellemzően valamilyen áttétel segítségévél befolyásolja a kormányzott kerekek helyzetét. Ez ebben a szoftverben sokkal egyszerűbb is lehet. Ha 60°-ot tengelyelfordulást feltételezünk és a kormány „nulla” állásból +/- 60-at mozdulhat el, akkor lényegében 1:1-es „áttételünk” van.
Ha az input +/- 100-as skálán adja meg a kormányelfordulás mértékét, akkor azt kell a tengelyelfordulásra képzeni. A bemeneti skálával kapcsolatban a HMI csapattal kell egyeztetni.</p>
<p>A úgymond kimenete egy mozgásvektor, vagyis az, hogy a következő ciklusban az autó (referenciapontjának) X, Y koordinátáit mennyivel kell módosítani.
A pedálállás és a motor korábbi állapotának függvényében meghatározásra kerül a sebesség, a kormányállás valamint az egocar korábbi orientációjának függvényében meghatározásra kerül, hogy módosul-e az autó iránya, a kettő eredőjeként a teljes vektor.</p>
<p>A modullal kapcsolatban kihívás a hajtáslánc működésének és a mozgás és kanyarodás fizikájának megértése, implementálása. A fizika tekintetében sem kell elaprózni a dolgokat. Két erő elégséges: a motorerő mint gyorsítja a járművet (ez a gázpedállal szabályozható) és egy fékező erő, amelyet a fékpedállal lehet szabályozni, valamint ezen felül egy konstans fékező erőnek is lennie kell, tehát a fékező erő akkor sem nulla, ha a fékpedál állása nulla. Ez utóbbit mindegy minek nevezzük (légellenállás, csúszási-súrlódási erő, a kettő eredője, stb.), nem kell cicomázni, de legyen.</p>
<p>Külön feladat észben tartatni és célszerűen előre felkészülni arra, hogy a 3. sprintes vezetéstámogató modulok (LKA, AAC, AEB, PP) közvetlenül az egocar hajtásláncára és a kormányra hatnak. Fel kell készíteni a modult ilyen, „nem a HMI-ről” érkező inputok kezelésére is, amelyek ráadásul magasabb prioritásúak. Pl. ha a vészfékező rendszer „lenyomja” a fékpedált, akkor magasabb prioritással kell kezelni mint a HMI-ről érkező pedálállást.</p>
<h3 id="definition-of-done"><a class="header" href="#definition-of-done">Definition of Done</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
Az autó gázpedál állásától függően gyorsul</li>
<li><input disabled="" type="checkbox"/>
a fék- és gázpedál állapota a billentyű nyomva tartásának idejével szabályozható
<ul>
<li><input disabled="" type="checkbox"/>
fék- és gázpedál valamint a kormány sem binárisan működik, a billentyű nyomva tartás idejétől függ az input intenzitása
<ul>
<li>a fék- és gázpedál [0, 100] skálán (ℕ), a kormányelforgatás [-100, 100] skálán (ℤ) kerül meghatározásra</li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
fék- és gázpedál valamint a kormány is fokozatosan (1 másodperc) áll vissza alaphelyzetbe a billentyű felengedésével</li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
az automata váltó 4 állapota szabályozható
<ul>
<li>szekvenciális váltóról lévén szó, sorban állíthatók a fokozatok: P(ark), R(everse), N(eutral), D(rive)</li>
<li>alaphelyzet: P, „felváltás” után R, majd N, majd D. „Leváltás” ugyanez visszafele.</li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
A gyorsulás a „belső fokozatok” szerint kerül meghatározásra</li>
<li><input disabled="" type="checkbox"/>
Az autó a gázpedál felengedésével fokozatosan lassul, majd megáll</li>
<li><input disabled="" type="checkbox"/>
Az autó R válóállásban tolat</li>
<li><input disabled="" type="checkbox"/>
Felkészíteni a modult, hogy a vészfékező, az adaptív tempomat vagy a sávtartó automatika is küldhet inputot, melyek magasabb prioritásúak
<ul>
<li>vészfékező értelemszerűen fékezés inputot</li>
<li>az adaptív tempomat és a parkoló asszisztens gáz és fék inputot is</li>
<li>a sávtartó automatika a kormányállást módosítja</li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
Autó kanyarodásának biztosítása valóságos fordulókör szerint
<ul>
<li>ehhez szükséges extra tulajdonságok meghatározása</li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
A meghatározott mozgásvektor alapján az autó pozíciójának frissítése
<ul>
<li>ez az AutomatedCar osztály x,y koordinátáinak frissítését jelenti</li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
Tolatás során is valósághű kanyarodás történik</li>
</ul>
<h2 id="szenzorok-kamera-radar-ütközés-detektálás"><a class="header" href="#szenzorok-kamera-radar-ütközés-detektálás">Szenzorok (kamera, radar), ütközés detektálás</a></h2>
<p>A kamera modul felelőssége a sávtartó automatika <del>és táblafelismerő alapjául</del> szolgáló kamera szenzor implementációja. Mint minden szenzor, a kamera is érzékeli a világ egy szeletét és eléri a látóterében található objektumokat.
A valóságos és szimulált szenzorok működését részletesebben a <a href="sprints/../sensors.html"><em>Szenzorok</em></a> fejezet mutatja be.</p>
<p><img src="sprints/../images/camera.png" alt="" /></p>
<p>A <em>radar sensor</em> modul felelőssége az adaptív tempomat és az automata vészfékező alapjául szolgáló radar szenzor szimulációjának implementálása. Mint minden szenzor, az radar is érzékeli a világ egy szeletét és eléri a látóterében található objektumokat.
A valóságos és szimulált szenzorok működését részletesebben a <a href="sprints/../sensors.html"><em>Szenzorok</em></a> fejezet mutatja be.</p>
<p><img src="sprints/../images/radar.png" alt="Radar szenzor elhelyezése" /></p>
<!-- Az *ultrasonic sensor* modul felelőssége a parkoló automata alapjául szolgáló ultrahang szenzorcsomag szimulációjának implementálása. Mint minden szenzor, az ultrahang is érzékeli a világ egy szeletét és eléri a látóterében található objektumokat.
A valóságos és szimulált szenzorok működését részletesebben a [*Szenzorok*](../sensors.md) fejezet mutatja be.

A kamera és a radar szenzorhoz képest a legfőbb különbség, hogy ultrahang szenzorból 8 példány kerül az autóra.

![Ultrahang szenzorok elhelyezése](../images/ultrasonic.png) -->
<p>Mindkét modul bemenete a világmodell (<code>World</code> objektum), kimeneteit olyan világ objektumok gyűjteménye képezi, amelyek beleesnek a szenzor látóterébe. A világ objektumainak lekérdezésére létre kell hozni egy publikus metódust, amely 3 pontot vár (A szenzor látóterét 3 ponttal kel definiálni.) bemenetként és visszaadja a bele eső objektumokat. Ezekből kell még leválogatni szenzoronként a relevánsakat.
Minden szenzor látóterét 3 ponttal kell definiálni. A szenzor látómezejének 3 pontját folyamatosan frissíteni kell az autó pozíciójának függvényében. Vagyis az autó egyébként folyamatosan frissülő referenciapontjához képest kell definiálni.
A megjelenítés is felhasználja ezeket a pontokat a háromszög kirajzolására a debuggoláshoz.</p>
<!-- A táblafelismerőnek csak továbbítani kell minden látott táblát, az majd eldönti, hogy melyik miképp releváns a vezérelt autóra nézve. -->
<h3 id="alkalmazás"><a class="header" href="#alkalmazás">Alkalmazás</a></h3>
<p>A sávtartó automatikának meg kell tudni határozni a sávot (ebben segítenek az útelemek részét képező sávokat reprezentáló geometria objektumok). Tehát a világmodell már jól definiált módon rendelkezésre bocsátja a sávinformációkat, de ezeket olyan adatstruktúrába kell rendezni, amely megkönnyíti a sávtartó automata implementálását: a sávtartó automatikának arra lesz majd szüksége, hogy az autó közelít-e a sávját meghatározó felfestésekhez, a sáv határait. Alternatív megközelítésben, hogy mennyire távolodik el a sávközéptől.</p>
<p>A kihívás a radar komponenssel kapcsolatban, hogy nem elég egyszerűen csak visszaadni a látótérben található releváns objektumokat, hanem el kell tudni dönteni, hogy a jelenlegi haladási irányunkat tartva veszélyesek-e. Pl. pontosan előttünk halad (a sávban), vagy oldalról érkezik és keresztezi az utunkat. A legközelebbi releváns objektum az alábbi ábrán az 1-es, a 2-es nem.</p>
<p><img src="sprints/../images/radar_lanes_simple.png" alt="Azonos sávban haladó jármű" /></p>
<p>Itt arról van szó, hogy a a szenzor egy iterációjában megkapjuk a látótérbe került ütközhető objektumokat. Egy fa pl. jellegénél fogva statikus, tehát túlzottan sok figyelmet nem igényel, de ugyanúgy továbbítani kell mint egy autót. Az NPC autó esetében az adott iterációban ismert az autó helyzete, majd ezt össze kell vetni az előző iterációban ismert helyzetével. A kettőből meghatározható egy irányvektor és el lehet dönteni, hogy merre halad (ha halad egyáltalán), előttünk halad, vagy mellettünk (pl. másik sávban), stb. Az ACC az azonos sávban előttünk haladó autó sebességét veszi fel, ezért az autó haladási iránya fontos szempont.</p>
<p>Mindez értelemszerűen egy statikus objektum pl. fa esetében is működik, csak az nem mozog (mert nem Középföldén vagyunk).</p>
<h3 id="Ütközés-detektálás"><a class="header" href="#Ütközés-detektálás">Ütközés-detektálás</a></h3>
<p>Folyamatosan vizsgálni kell, hogy a vezérelt autó nekiütközött-e egy ütközhető objektumnak. Ennek vizsgálatához használható a világobjektumok poligon váza. Később majd az automatikus vészfékező modul feladat lesz, hogy ez ne következhessen be. Egy visszajelzést kell adni, amely debuggoláshoz szükséges.</p>
<h3 id="definition-of-done-1"><a class="header" href="#definition-of-done-1">Definition of Done</a></h3>
<p><strong>kamera</strong></p>
<ul>
<li><input disabled="" type="checkbox"/>
Elkészült 1 db, a szélvédő mögé elhelyezett kamera implementálása</li>
<li><input disabled="" type="checkbox"/>
A látószög és távolság által meghatározott területen kérje el a <strong>releváns</strong> objektumokat
<ul>
<li>külön, a sávtartó szempontjából releváns objektumok, az utak</li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
A háromszög koordinátái az autó helyzetétől függően folyamatosan frissülnek</li>
<li><input disabled="" type="checkbox"/>
A legközelebbi objektum legyen kiemelve (legyen beállítva a „highlighted” tulajdonság)</li>
</ul>
<p><strong>radar</strong></p>
<ul>
<li><input disabled="" type="checkbox"/>
Elkészült 1 db, az autó első lökhárítója mögött elhelyezett radar szenzor</li>
<li><input disabled="" type="checkbox"/>
A látószög (60°) és távolság (200m) által meghatározott területen kérjék el a <strong>releváns</strong> objektumokat</li>
<li><input disabled="" type="checkbox"/>
A háromszög koordinátái az autó helyzetétől függően folyamatosan frissülnek</li>
<li><input disabled="" type="checkbox"/>
Határozzák meg a legközelebbi, sávon belüli (lateral offset alapján) objektum helyzetét</li>
<li><input disabled="" type="checkbox"/>
Az automata vészfékező számára releváns objektumok (az autó középvonala felé halad, látjuk) kiválogatása és visszaadása</li>
<li><input disabled="" type="checkbox"/>
A legközelebbi objektum legyen kiemelve (legyen beállítva a „highlighted” tulajdonság)</li>
</ul>
<!-- **ultrahang**

- 8 db ultrahang szenzor, egyenként 3 méter látótávolsággal, 100° látószöggel
- A 8 darab háromszög koordinátái az autó helyzetétől függően folyamatosan frissülnek
- A látószög és távolság által meghatározott területen kérjék el a **releváns** objektumokat
- Határozzák meg a legközelebbi (ütközés szempontjából) objektum pozícióját, kiterjedését, távolságát
    - külön-külön minden egyes szenzor, majd a rá épülő funkcionalitás fog ezekkel tovább dolgozni, tehát célszerű biztosítani a példányonként legközelebbi objektum továbbadását -->
<p><strong>ütközés-detektálás</strong></p>
<ul>
<li><input disabled="" type="checkbox"/>
A vezérelt autó - tereptárgy ütközésének detektálása és esemény kiváltása</li>
<li><input disabled="" type="checkbox"/>
A vezérelt autó - NPC-vel való ütközésének detektálása és esemény kiváltása</li>
<li><input disabled="" type="checkbox"/>
Két objektum akkor ütközött amikor a poligon reprezentációjuk összeért, nem amikor a képfájlok fedik egymást
<ul>
<li>pl. autó a fa lombkoronája alatt, de még nem érte el a törzset</li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
Legyen valami visszajelzés felhasználói felületen arról, hogy ütközés történt (pl. alert dialog)</li>
</ul>
<h2 id="világ-benépesítése-mozgó-npc-objektumokkal"><a class="header" href="#világ-benépesítése-mozgó-npc-objektumokkal">Világ benépesítése mozgó NPC objektumokkal</a></h2>
<p>A modul felelőssége, hogy a kiinduló kódban rendelkezésre álló világot, amelyben már megjelennek a statikus objektumok, további dinamikus objektumokkal kell kiegészíteni. Ezek a nem játszható karakterek (NPC, <em>non player character</em>), amelyekre azért van szükség, hogy a 2. sprintes modulok tesztelhetők legyenek. Például a vészfékező rendszer nem üti el a gyalogost, vagy az adaptív tempomat igazítja az autó sebességét az előtte haladó autóéhoz.</p>
<p>A modul bemenete a világmodell, amely egyrészt elősegíti az implementálást azáltal, hogy a előre definiált helyett az osztályhierarchiában az NPC objektumok számára, másrészt a statikus objektumok, egészen pontosan az út elemek definiálják a pályát amelyen az NPC autónak haladnia kell a KRESZ szabályai szerint: nem tér át az út másik oldalára, nem hajt gyorsan.</p>
<p>A legkézenfekvőbb megoldás, hogy a világban, a világ koordinátáira építve felveszünk vezérpontokat, amelyek kijelölnek egy utat. Ezeket célszerű lehet nem a kódban, hanem valamilyen külső fájlban tárolni. Az NPC objektum pedig ezt az utat követni. Például a parkoló mellől indul az úton megy fölfele (csökken az y koordinátája) a kanyar előtt (x,y) világkoordinátákat elérve lelassul, (x,y)' koordináták elérése esetén elkezd kanyarodni, a sávból nem tér ki, majd (x,y)" koordinátáig halad a fönti egyenesen. És így tovább.</p>
<p><img src="sprints/../images/npc_route.png" alt="" /></p>
<p><img src="sprints/../images/npc_route_pedestrian.png" alt="" /></p>
<p>A mozgáshoz sebességet is kell társítani. Két vezérlőpont közötti egyenesen adott idő alatt kell az NPC-nek végighaladnia. Továbbá az egyes vezérlőpontokhoz forgatási műveletet is társítani kell. Ehhez egy mozgás leíró struktúra lesz szükséges, pl. az alábbi elnagyolt példa <a href="https://toml.io/en/">TOML</a> nyelven, de bármilyen megoldás választható (JSON, XML, YAML vagy teljesen egyedi formátum):</p>
<pre><code class="language-toml">[points]

[points.1]
x = 100
y = 200
rotation = 0
speed = 50 # px/s

[points.2]
x = 100
y = 100
rotation = 15
speed = 30 # px/s
</code></pre>
<p>A feladatban az igazi kihívás, hogy az NPC objektumok adaptálódjanak pályához. Az adaptálódást úgy lehet megkerülni, hogy mindkét pályához készül egy-egy útvonal. A <code>test_world</code> pályán egy gyalogos és minimum egy autó, az <code>oval</code> pályán pontosan egy, az óramutató járásával megegyező irányban haladó NPC kell, amely legyen a <code>car_3_black</code> azonosítójú.</p>
<p>Az NPC autónak nincs hajtáslánc modulja, nem szükséges olyan részletes mozgatás sem mint az vezérelt autónál, de azért a kanyarodás legyen több pontból/lépésben megoldva, hogy fokozatosan legyen az autó elforgatva a kanyarodás valósághű leképezése céljából.</p>
<p>Az <code>oval</code> pálya nagy, elnyújtott kanyarokat tartalmaz, hogy ne kelljen különösebben lassítani. A <code>test_world</code> jóval élesebb kanyarokból áll, ehhez igazítani kell az autó sebességét. Az <code>oval</code> pályán körbeérve a furgon erőteljesen, de valóságosan fékez. Nem 0 idő alatt áll meg. Legyen a lassulása 9m/s^2.</p>
<h3 id="definition-of-done-2"><a class="header" href="#definition-of-done-2">Definition of Done:</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
Objektumok előre definiált, értelmes helyen jelennek meg (autók úton, gyalogosok út mellett, a zebra környékén)</li>
<li><input disabled="" type="checkbox"/>
Objektumok előre szkriptelt útvonalat követnek</li>
<li><input disabled="" type="checkbox"/>
Gyalogosok az út mentén haladnak, zebrán áthaladnak, megfordulnak majd újra átkelnek az úton</li>
<li><input disabled="" type="checkbox"/>
Autók az utat - sávot - pontosan követik</li>
<li><input disabled="" type="checkbox"/>
NPC objektumok egymás mozgásállapotát nem változtatják meg
<ul>
<li>Egy NPC autó gyalogoson akár átmehet, nem kell ütközésnek minősíteni</li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
Legalább egy autó végigmegy a pályán a <code>test_world</code> pályán</li>
<li><input disabled="" type="checkbox"/>
Legalább egy gyalogos mozog és átkel egy zebrán a <code>test_world</code> pályán, a fenti ábrának megfelelően</li>
<li><input disabled="" type="checkbox"/>
Az <code>oval</code> pálya esetén az NPC objektum az óramutató járásával megegyező irányban megtesz egy kört, majd a STOP táblánál hirtelen megáll
<ul>
<li><input disabled="" type="checkbox"/>
nem szükséges folytatnia az útját, a másik pályán viszont folyamatosan köröz</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2-sprint"><a class="header" href="#2-sprint">2. Sprint</a></h1>
<!-- toc -->
<h2 id="vészfékező"><a class="header" href="#vészfékező">Vészfékező</a></h2>
<p>A modul felelőssége a radar szenzorra épülő <a href="sprints/../functions.html#auton%C3%B3m-v%C3%A9szf%C3%A9kez%C5%91-rendszer-automatic-emergency-brake---aeb">automata vészfékező rendszer</a> megvalósítása. A vészfékező kritikus biztonsági funkció, így nem kapcsolható ki manuálisan, de maximum 70 km/h sebességig működik. A működése két esetre bontható: ütközés statikus vagy dinamikus objektummal.</p>
<p>Az előbbi az egyszerűbb eset, mivel a veszélyt jelentő objektum pozíciója változatlan.</p>
<p><img src="sprints/../images/aeb_radar_static.png" alt="" /></p>
<p>El kell dönteni, hogy az autó az aktuális irányvektort figyelembe véve ütközni fog-e az objektummal. Ha igen, az autó ismert sebességét figyelembe véve kiszámolható, hogy ehhez mennyi időre van szükség és, hogy mekkora mértékű lassulás kell ehhez.</p>
<p>A radar visszaadja az autó előtt levő legközelebbi releváns objektum adatait (táv, sebesség), ezekkel lehet számolni. A távolságból és az autó sebességéből meghatározható, hogy milyen lassulást kell adni az autónak, hogy még megálljon, de ne lépje túl a \( 9 m/s^2 \)-et.</p>
<p>Ha az ütközés elkerülhető, vizuális figyelmeztetést kell elhelyezni a vezetőnek, hogy fékezzen. Ha nem reagál, azaz továbbra is ütközési pályán vagyunk és már csak vészfékezéssel kerülhető el az ütközés, akkor a hajtásláncnak vészfékezési inputot kell adni. Ez a maximálisan megengedett, \( 9 m/s^2 \)-es lassulást (ennél nagyobb lassulás veszélyes az utasokra), akkor</p>
<p>Ha más nem próbálgatással meg kell határozni, hogy adott sebességről egy maximális fékezési input (100% pedál állás) mennyi idő alatt fékezi állóra az autót.
A modul olyan triggerekkel vezérli az autót mint amilyenek a billentyűlenyomás kezelőtől jönnek (fékpedál állás).</p>
<p>Dinamikus objektumok esetében a vészfékezés elve azonos, de az ütközési pálya meghatározása összetettebb.</p>
<p><img src="sprints/../images/aeb_radar_pedestrian.png" alt="" /></p>
<p>Másik sávban szembe jövő autóra nem kell vészfékezést kiváltani, tehát el kell tudni dönteni, hogy abban az esetben nincs ütközési pálya.</p>
<p><img src="sprints/../images/radar_lanes_simple.png" alt="" /></p>
<h3 id="definition-of-done-3"><a class="header" href="#definition-of-done-3">Definition of Done</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
Elkerülhető ütközés esetén vizuális figyelmeztetés a sofőrnek</li>
<li><input disabled="" type="checkbox"/>
Ha a sofőr nem avatkozik közbe, automatikus fékezés (az utolsó pillanatban, ahol az ütközés még elkerülhető)</li>
<li><input disabled="" type="checkbox"/>
Az automatikus fékezés mértéke a sebességgel arányos, de nem lehet \( 9 m/s^2 \)-nél nagyobb</li>
<li><input disabled="" type="checkbox"/>
70 km/h felett figyelmeztetés, hogy az AEB nem tud minden helyzetet kezelni</li>
<li><input disabled="" type="checkbox"/>
A vezérelt autó nem üt el gyalogost, nem megy neki fának</li>
<li><input disabled="" type="checkbox"/>
Nem releváns objektumok esetében (fals pozitív) mint a szembejövő autó nem történik vészfékezés</li>
</ul>
<h2 id="sávtartó-automatika"><a class="header" href="#sávtartó-automatika">Sávtartó automatika</a></h2>
<p>A sávtartó automatika modul felelőssége a kamera szenzorra épülő <a href="sprints/../functions.html#s%C3%A1vtart%C3%B3-automatika-lane-keeping-assistant---lka"><em>Lane Keeping Assistant</em></a> funkció megvalósítása.</p>
<p>Ezt két alapvetően kétféleképpen lehet megoldani. Az egyik a sáv széleihez viszonyítva korrigál: ha az autó elérné a sáv szélét, akkor ellenkormányoz. A másik megoldás kiszámolja a sáv közepét és azon tartja az autót.</p>
<h3 id="1-sáv-széleinek-használata"><a class="header" href="#1-sáv-széleinek-használata">1. Sáv széleinek használata</a></h3>
<p>Itt azt lehet vizsgálni, hogy a vezérelt autó jövőbeli helyzetében metszi-e a sávot.</p>
<p><img src="sprints/../images/lka_a.png" alt="" /></p>
<h3 id="2-sávközép-használata"><a class="header" href="#2-sávközép-használata">2. Sávközép használata</a></h3>
<p>Itt a vezérelt autó középpontját lehet a sávközéphez igazítani.</p>
<p><img src="sprints/../images/lka_b.png" alt="" /></p>
<p>Csak a 45 foknál enyhébb kanyarodású úton kell működnie, ilyenkor a kocsi a sáv szemmel látható közepét követi. Az LKA működése egy enyhe sávon belüli cikázást eredményez.</p>
<p><img src="sprints/../images/lka_wave.png" alt="" /></p>
<p>Az automatika számára kezelhetetlen forgalmi szituációkban (pl. éles kanyar, kereszteződés) el kell engednie a vezérlést és ezt a vezető tudtára kell hoznia. Legyen hozzá vizuális figyelmeztetés a műszerfalon (pl. LKA visszajelző sárga). Ha újra olyan útszakasz következik, ahol a funkció használható, akkor arról szintén legyen tájékoztatás.
Ezen kívül természetesen a funkció ki- és bekapcsolható.</p>
<h3 id="definition-of-done-4"><a class="header" href="#definition-of-done-4">Definition of Done</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
A sávtartó automatika ki- és bekapcsolható
<ul>
<li><input disabled="" type="checkbox"/>
állapota a műszerfalon látható</li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
Vezetői beavatkozásra kikapcsol</li>
<li><input disabled="" type="checkbox"/>
45 foknál enyhébb kanyarodású úton a kocsi a sáv szemmel láthatóan a sáv közepén marad</li>
<li><input disabled="" type="checkbox"/>
Ha el kell engednie a kontrollt (az automatika számára kezelhetetlen forgalmi szituáció következik, pl. éles kanyar, kereszteződés), vizuális figyelmeztetést ad</li>
<li><input disabled="" type="checkbox"/>
Ha újra elérhető a funkció (pl. elhagytuk a kanyart) vizuális indikáció (a műszerfalon)</li>
</ul>
<h2 id="adaptív-tempomat"><a class="header" href="#adaptív-tempomat">Adaptív tempomat</a></h2>
<p>A modul felelőssége a radar szenzorra épülő <a href="sprints/../functions.html#adapt%C3%ADv-tempomat-adaptive-cruise-control---acc"><em>adaptív tempomat</em></a> vezetéstámogató funkció elkészítése. Ennek a funkciónak három felhasználói esetet kell lefednie.</p>
<ol>
<li>Felhasználó által beállított sebesség tartása</li>
<li>A táblafelismerő által közölt sebességkorlátozás betartása</li>
<li>Az előttünk haladó (NPC) autó sebességének felvétele és egy (időben definiált) beállított követési távolság tartása
<ul>
<li>Valójában ettől lesz adaptív</li>
</ul>
</li>
</ol>
<p>Az egyes ponthoz szükséges kezelőszervek már elkészültek az első sprintben és a funkcióhoz szükséges bemeneti értékek már a buszon keresztül elérhetőek. A modulnak szabályoznia kell a hajtásláncot, hogy ne léphesse túl a beállított sebességet. Ehhez olyan inputot kel biztosítania mintha az a billentyűzetről érkezne, de a tényleges vezetői input felülírja őket.</p>
<p>A kettes pont egy harmadik sprintes (tehát aktuálisan készülő funkciótól függ), azonban könnyen visszavezethető az első pontra. A közúti szabályozást magasabb prioritásúnak kell minősíteni. Tehát a felhasználó pl. beállít egy 70 km/h-ás célsebességet, majd érkezik egy kérés a táblafelismerőtől, hogy 50km/h a megengedett, akkor azt kell figyelembe venni.</p>
<p>A hármas pont egy második sprintes modultól, az NPC autók meglététől függ. Az előttünk haladó sebességéhez való igazodás a legmagasabb prioritású, hiszen hiába szeretne a vezető 70-el haladni, mikor a tábla szerint 50-nel lehet, de ha az előttünk haladó mindössze 40-el halad, akkor ahhoz kell igazodni, különben nekiütközünk.
Oda kell figyelni, hogy csak a sávban előttünk haladó autót vegye figyelembe, a szembejövőt ne.</p>
<p>A követési <em>távolság</em> időben történő megadása azt jelenti, hogy a beállított (pl.) 1 másodperces követés esetén akkora távolságot kell hagyni, hogy <strong>az aktuális sebességgel</strong> haladva 1 másodperc alatt megtett út legyen a távolság: 10 m/s (36 km/h) esetében 10 méter. Ezen érték beállítására már az első sprintben készült vezérlő.</p>
<p><img src="sprints/../images/acc.png" alt="" /></p>
<h3 id="definition-of-done-5"><a class="header" href="#definition-of-done-5">Definition of Done</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
Ki- és bekapcsolható</li>
<li><input disabled="" type="checkbox"/>
ACC: Állítható céltávolság (T jelű gombbal, körkörösen 0.8/1.0/1.2/1.4 másodperc)</li>
<li><input disabled="" type="checkbox"/>
ACC: Állítható célsebesség (+/- gombbal, 30-160, 10-es lépésközzel)</li>
<li><input disabled="" type="checkbox"/>
Bekapcsoláskor a célsebessége az aktuális sebesség, de a minimum célsebesség 30 km/h</li>
<li><input disabled="" type="checkbox"/>
Ha nincs saját sávban előttünk autó, akkor a vezérelt autó tartja a kiválasztott célsebességet</li>
<li>Ha a saját sávban található autó:
<ul>
<li><input disabled="" type="checkbox"/>
Ha az előttünk levő autó lassabb, akkor fel kell venni a sebességét</li>
<li><input disabled="" type="checkbox"/>
Ha gyorsabb, akkor tartja a kiválasztott sebességet</li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
Fékezésre kikapcsol</li>
<li><input disabled="" type="checkbox"/>
AEB beavatkozásra kikapcsol</li>
</ul>
<!-- - [ ] Ha sebesség korlátozást talál a buszon, azt alkalmazza új célsebességként, amíg a sofőr felül nem írja -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="sprintek-1"><a class="header" href="#sprintek-1">Sprintek</a></h1>
<p>A félév során minden csapat 3 sprintet teljesít, minden sprintre egy-egy user story-t kap. 4 csapat esetén így a teljes elkészítendő szoftver 12 részre van bontva. A csapatok feladata a user story-k megértése, felbontása egyhuzamban elvégezhető feladatokra (task), ezekhez felelőst és határidőt rendelve.</p>
<p>Szintén a csapatok feladat a feladatok közötti függőségek azonosítása és az erőforrások (idő, fejlesztő) oly módon történő beosztása, hogy a határidőre minden elkészüljön. Az egyes user story-k között nem csak sprinteken átívelő függőségek lehetnek, hanem sprinten belüliek is. Ilyen esetben az érintett csapattal egyeztetve kell az egyes (rész)feladatok prioritásait meghatározni.</p>
<p>A user story-k függőségi gráfja alább látható, sprintenként színezve.</p>
<p><img src="sprints_old/../images/dependencies_4_team.png" alt="" /></p>
<p>A következő ábrán pedig a user story-k a felelős csapatok alapján van színezve.</p>
<p><img src="sprints_old/../images/team_user_stories.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1-sprint-1"><a class="header" href="#1-sprint-1">1. Sprint</a></h1>
<h2 id="human-machine-interface-hmi-műszerfal-irányítás"><a class="header" href="#human-machine-interface-hmi-műszerfal-irányítás">Human Machine Interface (HMI): Műszerfal, irányítás</a></h2>
<p>A <em>HMI</em> modul felelőssége a vezérelt autó (egocar) kezelőszerveinek és visszajelzőinek megvalósítása. Bemeneti jelként kezelnie kell tehát a billentyűeseményeket, le kell őket fordítani az autó vezérlőszerveire, valamint a műszerfalon meg kell jeleníteni az egocar állapotát leíró értékeket.</p>
<p>A modul kihívása a „bináris állapotú” billentyűesemények „fokozatossá tétele”. A gáz- és fékpedál nyomvatartásának idejét kell leképezni a pedál lenyomás mértékére és egy adott idő alatt kell ennek 100%-ra jutnia. A hajtáslánc a pedálok lenyomásának mértékét használja majd a gyorsítás - és úgy általában az elmozdulás mértékének - meghatározásához.
A pedálokhoz hasonlóan a kormány elfordítása sem bináris, ugyanúgy a billentyűlenyomás idejének felhasználásával kell számolni. Ezek skáláját a hajtásláncért modullal egyeztetve kell meghatározni (pl. pedálállás lenyomás 0-100 között).</p>
<p>A szimulált autó automata váltóval rendelkezik, így a váltó <em>P</em>, <em>R</em>, <em>N</em>, <em>D</em> állapotait is is közvetíteni kell a hajtáslánc felé.</p>
<p>A műszerfalnak az alábbi vázlathoz hasonlóan kell felépülnie. A programablak bal oldalán a virtuális világ egy szeletét látjuk ezért felel, a vizualizációs modul. A jobb oldalon a műszerfal található. A műszerfalon nincsenek vezérlőelemek, csak megjelenítés. Az összes kapcsoló a billentyűzettel állítható, a grafikus elemeknek nem kell pl. egérrel kapcsolhatónak lenniük.</p>
<p><img src="sprints_old/images/gui_plan_dashboard.png" alt="gui_plan" /></p>
<p>A fordulatszám és a sebesség legyen egy analóg órával reprezentálva; a kormány elforgatás, a gáz- és fékpedál állása progressbar-okkal szemléltethető. Az irányjelző visszajelzője és a vezetéstámogató funkciók visszajelzői lámpaszerűek, a sebességváltó állása, és a debug értékek pl. kocsi pozíciója (x, y koordináta) lehet szöveges.</p>
<p>Az utoljára látott tábla -csak úgy mint a többi vezetéstámogató funkció- ugyan csak a 3. sprintben lesz kihasználva, de már most biztosítani kell a visszajelzését. A buszon közölt „utoljára látott tábla” képét ki kell tudni rajzolni (a képek rendelkezésre állnak). Legyen elkülönítve a nincs tábla eset is.</p>
<h3 id="definition-of-done-6"><a class="header" href="#definition-of-done-6">Definition of Done</a></h3>
<ul>
<li>a fék- és gázpedál állapota szabályozható</li>
<li>fék- és gázpedál valamint a kormány sem binárisan működik, a billentyű nyomva tartás idejétől függ az input intenzitása</li>
<li>fék- és gázpedál valamint a kormány is fokozatosan áll vissza alaphelyzetbe a billentyű felengedésével</li>
<li>az automata váltó 4 állapota szabályozható
<ul>
<li>szekvenciális váltóról lévén szó, sorban állíthatók a fokozatok: P(ark), R(everse), N(eutral), D(rive)</li>
<li>alaphelyzet: P, „felváltás” után R, majd N, majd D. „Leváltás” ugyanez visszafele.</li>
</ul>
</li>
<li>ACC: Állítható céltávolság (T jelű gombbal, körkörösen 0.8/1.0/1.2/1.4 másodperc)</li>
<li>ACC: Állítható célsebesség (+/- gombbal, 30-160, 10-es lépésközzel)</li>
<li>Lane Keeping bekapcsolás</li>
<li>Parkig pilot bekapcsolás</li>
<li>irányjelző (jobb, bal) kapcsolható</li>
<li>egyszerre több billentyű is használható
<ul>
<li>kanyarodni és gázt adni/fékezni minimum kell tudni egyszerre</li>
</ul>
</li>
<li>Megjelenik a fordulatszám mint „analóg óra”</li>
<li>Megjelenik a sebesség mint „analóg óra”</li>
<li>Megjelenik a kormányállás
<ul>
<li>akár elforgatott kormánykerékként, de minimum szövegként</li>
</ul>
</li>
<li>Megjelenik a gáz, fék állapota (progressbar)</li>
<li>Megjelenik a sebességváltó állása (szövegesen)</li>
<li>Irányjelző visszajelző (egy-egy nyíl kirajzolva)</li>
<li>Kocsi pozíció megjelenítése (x, y koordináta debug céllal, szövegesen)</li>
<li>Vezetéstámogató funkciók visszajelzései
<ul>
<li>ACC idő és sebesség limit</li>
<li>parking pilot és a lane keeping rendszerek állapot visszajelzése</li>
</ul>
</li>
<li>az utolsó látott tábla megjelenítése
<ul>
<li>interfész biztosítása, az utolsó látott tábla beállítására</li>
</ul>
</li>
<li>F1 billentyű lenyomására üzenetablak megjelenítése a vezérlőbillentyűket felsoroló súgóval</li>
</ul>
<h2 id="világmodell-kialakítása"><a class="header" href="#világmodell-kialakítása">Világ(modell) kialakítása</a></h2>
<p>A <em>világmodell</em> modul felelőssége a játék virtuális terének felépítése, az abban található elemek Objektum Orientált elveknek megfelelő hierarchiába szervezése, a virtuális tér elemeivel való interakciót biztosító (publikus) metódusok implementálása.</p>
<p>A modul bemenete a világ statikus elemeit tartalmazó állomány, amely XML és JSON formátumban is rendelkezésre áll. Ez a leíró fájl azonban csupán az objektumok síkbeli helyzetét, elforgatását és típusát tartalmazza. A modul felelőssége a többi modul igényeivel összhangban az objektumok további tulajdonságokkal történő felruházása. Például a rajzolást megkönnyítő <em>Z index</em> vagy az objektum térbeli kiterjedését szolgáló poligon definiálása.</p>
<p>A modullal kapcsolatos legfontosabb kihívás, hogy más csapatoktól érkező igényeket is teljesíteni kell, és „mindenki ezekre vár”. Így különösen fontos kezelni a sprinten belüli határidőket és prioritásokat. Például a deszerializált világobjektumok az első pillanattól kezdve szükségesek a megjelenítésért felelős csapat számára.
Valamint, hogy minden tervezési döntés érinti a többi csapatot is, még ha ők ennek nincsenek is mindig tudatában.</p>
<ul>
<li>Mielőbb el kell dönteni, hogy milyen koordináta-rendszerben dolgozik majd a modell.
Teljesen járható út, hogy a modell, az input állományban található koordináta-rendszer egy az egyeben alkalmazásra kerül, ebből adódóan minden számolás abban történik, csak a megjelenítés transzformálja át. (A teljes világ nem fog kiférni a képernyőre.)</li>
<li>El kell dönteni, hogy mi legyen az objektumok referenciapontja. A megjelenítés során forgatni kell az objektumokat, a <a href="sprints_old/virtual_world.html#az-%C3%BAt-elemek-viszony%C3%ADt%C3%A1si-pontjai">forgatási pont</a> nem egyezik meg a referenciaponttal, de a megjelenítésnek szükséges.</li>
<li>A világ objektumokhoz poligonokat kell társítani, ezek szolgálnak majd az ütközés valamint a látótérbe kerülés eldöntésére.</li>
<li>Fontos továbbá, hogy ezek a poligonok nem a képfájl szélei. A fa esetében csupán a törzsének lehet nekimenni, nem a lombkoronának, ezért a modellt ekképpen kell megalkotni! A törzsnek használható egy szabályos hasáb az egyszerűség kedvéért.
<ul>
<li><img src="sprints_old/images/tree_collidable.png" alt="" /></li>
</ul>
</li>
<li>Az autó is egyszerűsíthető, nem kell a grafikai elemet teljes mértékben követni.
<ul>
<li><img src="sprints_old/images/car_simplified_polygon_model.png" alt="" /></li>
</ul>
</li>
<li>A kanyarodó útelemeknél is lehet egyszerűsítést használni.
<ul>
<li><img src="sprints_old/images/90left_polygon.png" alt="" /></li>
</ul>
</li>
<li>A szűréshez használt háromszög esetében a poligonokat kell figyelembe venni, pl. fa törzse, tábla rúdja, de nem csak az „ütközhető” objektumokat kell tudni visszaadni, hanem az útelemeket is. A 2. sprintben a szenzorok majd válogatnak, hogy mire van szükségük ezekből.
<ul>
<li><img src="sprints_old/images/model_interface.png" alt="" /></li>
</ul>
</li>
<li>A poligonok megrajzolásához használható a <a href="https://www.robots.ox.ac.uk/~vgg/software/via/">VGG Image Annotator</a>, amely <a href="https://www.robots.ox.ac.uk/~vgg/software/via/via.html">böngészőből is működik</a> és a megrajzolt polygont JSON-ben le lehet menteni.
<ul>
<li>Korábbi félév során @ArchiCat és @konyarilaszlo ezt már megtette, elérhető a <a href="sprints_old/resources/worldobject_polygons.json">worldobject_polygons.json</a> állományban.</li>
</ul>
</li>
<li>A poligonok definiálásához célszerű a <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.desktop/java/awt/geom/package-summary.html">java.awt.geom</a> névteret használni. Ezek <code>intersects</code> könnyedén eldönthető, hogy egy objektum a szenzor látóterében van-e (amennyiben a szenzor is egy ilyen poligon).</li>
<li>A statikus objektumokon kívül a világ modell részét kell képezzék dinamikus, mozgó objektumok is.</li>
</ul>
<p>A tervezés során nem elegendő csupán az első sprint (meglehetősen szűk) követelményit figyelembe venni, hanem célszerű ezen túl a későbbi sprintek során valamennyi <em>user story</em>-ban felbukkanó követelmény kezelése. Természetesen nem elvárás a „jövőbe látás”, de törekedni kell minden logikusan előrelátható követelmény kezelésére.</p>
<h3 id="definition-of-done-7"><a class="header" href="#definition-of-done-7">Definition of Done</a></h3>
<ul>
<li>Útelemeket, fákat, táblákat egyéb statikus objektumokat leíró állományok feldolgozása (deszerializálása)
<ul>
<li>kicsi pálya (test_world) és elemeinek megfelelő kezelése</li>
<li>nagy pálya (test_world_1kmx1km) és elemeinek megfelelő kezelése</li>
<li>ovális pálya (oval) és elemeinek megfelelő kezelése</li>
</ul>
</li>
<li>Objektummodell implementálása világ leírására
<ul>
<li>A skeleton World objektuma a tartalmazza a felépített világot, pl. egy heterogén WorldObjects gyűjteményben</li>
</ul>
</li>
<li>Objektumok kiterjedését biztosító poligonok beolvasása</li>
<li>Minden feldolgozott objektum rendelkezzen pozíció, referencia, orientáció, típusadatokkal
<ul>
<li>legyen olyan tulajdonság is, amellyel egyszerűen kiválogatható, hogy valaminek neki lehet menni (pl. fa) vagy nem (úttest)</li>
</ul>
</li>
<li>A modell legyen felkészítve az input fájlból kiolvasott „statikus” objektumokon túl mozgó („dinamikus”) objektumok kezelésére is, amelyek kódból lesznek példányosítva
<ul>
<li>vezérelt autó, NPC (non-player-character) autó, gyalogos</li>
</ul>
</li>
<li>A modell tegyen különbséget azon objektumok között amelyeknek egy jármű nekimehet és amelyeknek nem (fa vs. útelem)</li>
<li>A modell kezeljen „z-index”-et, hogy a kirajzolás során biztosítható legyen, hogy mely elemet kell előtt kirajzolni a „kitakarások” végett</li>
<li>A modell biztosítson egy publikus metódust, amellyel a világ objektumai szűrhetőek. A metódus bemenete 3 pont, amely meghatároz egy háromszög (szenzor látótér), a metódus válogassa ki azokat a világ objektumokat, amelyeket a szenzor „lát”, amelyekkel a háromszög érintkezik</li>
<li>A modell tegye elérhetővé a feldolgozott referenciapontokat, és a poligonokat is tulajdonságokon keresztül</li>
<li>A modell a beolvasott elforgatási mátrixot dolgozza föl, váltsa át elforgatási szögre és tegye elérhető egy tulajdonságon keresztül</li>
</ul>
<h2 id="mozgatás-hajtáslánc-és-kormányzás-1"><a class="header" href="#mozgatás-hajtáslánc-és-kormányzás-1">Mozgatás: hajtáslánc és kormányzás</a></h2>
<p>A <em>mozgatás</em> modul felelőssége a vezérelt autó (egocar) mozgatása, mozgásának számítása. Ez magába foglalja a hajtáslánc és a kormányzás megvalósítását.</p>
<p>A modul a HMI-től kap bemenetet, mindenek előtt váltóállás, gáz- és fékpedálállás valamint kormányelfordulás. A váltó automata, ami azzal jár, hogy a HMI a négy állapot (P, R, N, D) egyikét közli.</p>
<ul>
<li><strong>P</strong>ark: Ez az egyik olyan állapot amiben a motor beindítható (a másik az N), ez a váltó alapállása, mechanikusan megszünteti az erőátvitelt. A valóságban nem helyettesíti kéziféket, de mivel azt nem kell implementálni a feladat során, lehet úgy tekinteni, hogy P-ben a kézifék is be van húzva. Az autó nem mozdul ebben az állásban.</li>
<li><strong>R</strong>everse: hátramenet</li>
<li><strong>N</strong>eutral: üres, ebben az állásban sem jut a motorerő tengelyekre, a motor nem gyorsíthatja az autót. Ha üresben gázt adunk, a motor felpörög, méghozzá jelentősen, mivel nincs ami ellene dolgozna. Ha az autónak volt lendülete, az még hajtja tovább.</li>
<li><strong>D</strong>rive: előremenet. A D-m belül definiálni kell 4-5 belső fokozatot (mint ahogy manuális váltónál is lenne), le kell programozni, hogy valamilyen fordulatszám értékeknél a váltó váltson. Ezen értékek meghatározásához lehet találni motorkarakterisztikákat (lehetőség szerint utcai autó kerüljön kiválasztásra, ne valami sportautó). A belső fokozatok a felhasználó interfész szempontjából transzparensek.</li>
</ul>
<p>A pedál állások [0-100] skálán érkeznek. 0: nincs lenyomva, 1: 1%-ig van lenyomva, 100: tövig (100%-ig) le van nyomva. Minél jobban le van nyomva a gázpedál, annál több teljesítményt kell a motornak kiadnia. A motor belső működését nem kell részletekbe menően implementálni, pláne nem egy belső égésű motorét, egy elektromos hajtáslánc egyszerűbb.
A szoftverben üzemanyag-fogyasztást (vagy akkumulátor töltöttséget) és hatótávokat nem kell kezelni.</p>
<p>A kormány jellemzően valamilyen áttétel segítségévél befolyásolja a kormányzott kerekek helyzetét. Ez ebben a szoftverben sokkal egyszerűbb is lehet. Ha 60°-ot tengelyelfordulást feltételezünk és a kormány „nulla” állásból +/- 60-at mozdulhat el, akkor lényegében 1:1-es „áttételünk” van.
Ha az input +/- 100-as skálán adja meg a kormányelfordulás mértékét, akkor azt kell a tengelyelfordulásra képzeni. A bemeneti skálával kapcsolatban a HMI csapattal kell egyeztetni.</p>
<p>A úgymond kimenete egy mozgásvektor, vagyis az, hogy a következő ciklusban az autó (referenciapontjának) X, Y koordinátáit mennyivel kell módosítani.
A pedálállás és a motor korábbi állapotának függvényében meghatározásra kerül a sebesség, a kormányállás valamint az egocar korábbi orientációjának függvényében meghatározásra kerül, hogy módosul-e az autó iránya, a kettő eredőjeként a teljes vektor.</p>
<p>A modullal kapcsolatban kihívás a hajtáslánc működésének és a mozgás és kanyarodás fizikájának megértése, implementálása. A fizika tekintetében sem kell elaprózni a dolgokat. Két erő elégséges: a motorerő mint gyorsítja a járművet (ez a gázpedállal szabályozható) és egy fékező erő, amelyet a fékpedállal lehet szabályozni, valamint ezen felül egy konstans fékező erőnek is lennie kell, tehát a fékező erő akkor sem nulla, ha a fékpedál állása nulla. Ez utóbbit mindegy minek nevezzük (légellenállás, csúszási-súrlódási erő, a kettő eredője, stb.), nem kell cicomázni, de legyen.</p>
<p>Külön feladat észben tartatni és célszerűen előre felkészülni arra, hogy a 3. sprintes vezetéstámogató modulok (LKA, AAC, AEB, PP) közvetlenül az egocar hajtásláncára és a kormányra hatnak. Fel kell készíteni a modult ilyen, „nem a HMI-ről” érkező inputok kezelésére is, amelyek ráadásul magasabb prioritásúak. Pl. ha a vészfékező rendszer „lenyomja” a fékpedált, akkor magasabb prioritással kell kezelni mint a HMI-ről érkező pedálállást.</p>
<h3 id="definition-of-done-8"><a class="header" href="#definition-of-done-8">Definition of Done</a></h3>
<ul>
<li>Az autó gázpedál állásától függően gyorsul</li>
<li>A gyorsulás a „belső fokozatok” szerint kerül meghatározásra</li>
<li>Az autó a gázpedál felengedésével fokozatosan lassul, majd megáll</li>
<li>Az autó R válóállásban tolat</li>
<li>Felkészíteni a modult, hogy a vészfékező, az adaptív tempomat vagy a parkoló asszisztens is küldhet inputot, melyek magasabb prioritásúak
<ul>
<li>vészfékező értelemszerűen fékezés inputot</li>
<li>az adaptív tempomat és a parkoló asszisztens gáz és fék inputot is</li>
</ul>
</li>
<li>Buszról érkező kormányállás felhasználása</li>
<li>Autó kanyarodásának biztosítása valóságos fordulókör szerint
<ul>
<li>ehhez szükséges extra tulajdonságot meghatározása</li>
</ul>
</li>
<li>Tényleges mozgásvektor meghatározása a motor csapat gyorsulás, lassulás értékének felhasználásával</li>
<li>A meghatározott mozgásvektor alapján az autó pozíciójának frissítése
<ul>
<li>az AutomatedCar osztály x,y koordinátáinak frissítése</li>
</ul>
</li>
<li>Tolatás során is valósághű kanyarodás történik</li>
<li>Felkészíteni a modult, hogy a sávtartó automatika vagy a parkoló asszisztens is küldhet kormányzás inputot</li>
</ul>
<h2 id="vizualizáció"><a class="header" href="#vizualizáció">Vizualizáció</a></h2>
<p>A <em>vizualizációs</em> modul felelőssége a játék virtuális terének, pontosabban a képernyőn megjeleníthető részének kirajzolása miután a világ lényegesen nagyobb mint ami a programablakba egyszerre belefér. A modul csak megjelenít, a modellt a világmodellért felelős csapat állítja össze. Ebbe nem csak a pálya statikus elemei tartoznak, hanem értelemszerűen a dinamikus objektumok is. A megjelenítés középpontja az mindenkor vezérelt autó (egocar).</p>
<p>Továbbá, a modul felelőssége a debuggoláshoz és teszteléshez használandó segédobjektumok opcionálisan bekapcsolható megjelenítése. Ide tartozik a szenzorok látómezeje, a világobjektumok „poligon váza”, valamint utóbbiak eseményre történő kiemelésének lehetősége. Ez utóbbi akkor történik, amikor majd a 2. sprintben létrehozandó szenzor látómezejébe kerül pl. egy fa, akkor a szenzor a fa kiemelés tulajdonságát bebillenti és ekkor a megjelenítésnek valami más színt kell tudnia használni (a poligon kirajzolására, esetleg kitöltésére).</p>
<p>A programablaknak az alábbi módon nézni majd ki. Két jól el különülő részre oszlik, a nagyobb baloldali a <em>viewport</em>, amelyen keresztül a világ éppen megjelenített része látható. A jobb oldali a műszerfal, amely <em>nem</em> tartozik e modul felelősségi körébe.</p>
<p><img src="sprints_old/images/gui_plan_course_display.png" alt="gui_plan" /></p>
<p>A modullal kapcsolatos kihívása a rajzoláshoz használt keretrendszer megismerése, az objektumtranszformációk megfelelő végrehajtása és az objektummodellért felelős csapattal egyeztetés az objektumok elérését illetően.
Bár a modul függ a világmodelltől, a munka értelemszerűen nem akkor kezdődik mikor az a modul elkészült. A világobjektumok képfájljai és a világot leíró állomány kezdettől fogva rendelkezésre áll, nem kell megvárni a teljes modell elkészültét.</p>
<h3 id="definition-of-done-9"><a class="header" href="#definition-of-done-9">Definition of Done</a></h3>
<ul>
<li>a megjelenés villódzásmentes és folyamatos legyen</li>
<li>A kirajzolt világ egy része látható csak állandóan a programablakban, a „kamera” a vezérelt autót (egocar) követi
<ul>
<li>világ széleinek kezelése</li>
</ul>
</li>
<li>statikus objektumok pozícióhelyes kirajzolása és résmentes illesztése a rendelkezésre álló építőelemekből</li>
<li>mozgó objektumok helyes kirajzolása</li>
<li>debug célból meg kell tudni jeleníteni az egyes objektumokhoz definiált poligonokat</li>
<li>interfészt kell biztosítani, hogy egy megcímzett objektum poligonja eltérő színnel jelenhessen meg (ha kijelölésre kerül)</li>
<li>interfészt kell biztosítani a szenzorok látóterét jelképező háromszögek opcionális megjelenítésére
<ul>
<li>típusonként (radar, kamera, ultrahang) külön-külön kapcsolhatónak kell lennie és más-más színnel kell megjelennie (piros, kék, zöld)</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2-sprint-1"><a class="header" href="#2-sprint-1">2. Sprint</a></h1>
<!-- toc -->
<h2 id="ultrahang-szenzor-implementálása"><a class="header" href="#ultrahang-szenzor-implementálása">Ultrahang szenzor implementálása</a></h2>
<p>Az <em>ultrasonic sensor</em> modul felelőssége a parkoló automata alapjául szolgáló ultrahang szenzorcsomag szimulációjának implementálása. Mint minden szenzor, az ultrahang is érzékeli a világ egy szeletét és eléri a látóterében található objektumokat.</p>
<p>A valóságos és szimulált szenzorok működését részletesebben a <a href="sprints_old/sensors.html"><em>Szenzorok</em></a> fejezet mutatja be.</p>
<p>A modul bemenete tehát a világmodell, kimenete olyan ütközhető világ objektumok gyűjteménye képezi, amelyek beleesnek a szenzor látóterébe. A világ objektumainak lekérdezésére már léteznie kell egy publikus metódusnak, mely 3 pontot vár bemenetként és visszaadja a bele eső objektumokat. Ezekből kell még leválogatni a relevánsakat.
A szenzor látóterét 3 ponttal kel definiálni.</p>
<p>A kamera és a radar szenzorhoz képest a legfőbb különbség, hogy ultrahang szenzorból 8 példány kerül az autóra.
Minden példány látómezejének 3 pontját folyamatosan frissíteni kell az autó pozíciójának függvényében. Vagyis az autó egyébként folyamatosan frissülő referenciapontjához képest kell definiálni.
A megjelenítés is felhasználja ezeket a pontokat a háromszög kirajzolására a debuggoláshoz.</p>
<p><img src="sprints_old/images/ultrasonic.png" alt="Ultrahang szenzorok elhelyezése" /></p>
<h3 id="definition-of-done-10"><a class="header" href="#definition-of-done-10">Definition of Done</a></h3>
<ul>
<li>8 db ultrahang szenzor, egyenként 3 méter látótávolsággal, 100° látószöggel</li>
<li>A 8 darab háromszög koordinátái az autó helyzetétől függően folyamatosan frissülnek</li>
<li>A látószög és távolság által meghatározott területen kérjék el a <strong>releváns</strong> objektumokat</li>
<li>Határozzák meg a legközelebbi (ütközés szempontjából) objektum pozícióját, kiterjedését, távolságát
<ul>
<li>külön-külön minden egyes szenzor, majd a rá épülő funkcionalitás fog ezekkel tovább dolgozni, tehát célszerű biztosítani a példányonként legközelebbi objektum továbbadását</li>
</ul>
</li>
<li>A legközelebbi objektum legyen vizuálisan kiemelve
<ul>
<li>a kiemelés megjelenítését a vizualizáció intézi az objektum tulajdonsága (kijelöltség) alapján, de azt, hogy éppen ki van-e jelölve a szenzornak kell az objektumon beállítani</li>
</ul>
</li>
</ul>
<!-- - debug célra bekapcsolható módon ezek a háromszögek legyen kirajzolhatóak **zöld** színnel -->
<h2 id="kamera-szenzor-implementálása-Ütközés-detekció-és-mozgásállapot-változás-szimuláció"><a class="header" href="#kamera-szenzor-implementálása-Ütközés-detekció-és-mozgásállapot-változás-szimuláció">Kamera szenzor implementálása, Ütközés detekció (és mozgásállapot-változás szimuláció)</a></h2>
<p>A kamera modul felelőssége a sávtartó automatika és táblafelismerő alapjául szolgáló kamera szenzor implementációja. Mint minden szenzor, a kamera is érzékeli a világ egy szeletét és eléri a látóterében található objektumokat.</p>
<p>A valóságos és szimulált szenzorok működését részletesebben a <a href="sprints_old/sensors.html"><em>Szenzorok</em></a> fejezet mutatja be.</p>
<p>A táblafelismerőnek csak továbbítani kell minden látott táblát, az majd eldönti, hogy melyik miképp releváns a vezérelt autóra nézve.</p>
<p>A sávtartó automatika az összetettebb feladat, ugyanis meg kell tudni határozni a sávot (ebben segítenek az útelemek részét képező sávokat reprezentáló geometria objektumok). Tehát a világmodell már jól definiált módon rendelkezésre bocsátja a sávinformációkat, de ezeket olyan adatstruktúrába kell rendezni, amely megkönnyíti a sávtartó automata implementálását: a sávtartó automatikának arra lesz majd szüksége, hogy az autó közelít-e a sávját meghatározó felfestésekhez, a sáv határait.</p>
<p>A modul bemenete tehát a világmodell, kimenetét olyan világ objektumok gyűjteménye képezi, amelyek beleesnek a szenzor látóterébe. A világ objektumainak lekérdezésére már léteznie kell egy publikus metódusnak, mely 3 pontot vár bemenetként és visszaadja a bele eső objektumokat. Ezekből kell még leválogatni a relevánsakat.
A szenzor látóterét 3 ponttal kel definiálni. Miután a szenzor kimenetét két különböző típusú világobjektumokat igénylő funkció használja, a kimenete legyen ennek megfelelően szétválasztva. Így a kimenet valójában két gyűjtemény, az egyik csupán táblákat, a másik útelemeket tartalmaz.</p>
<p>A szenzor látómezejének 3 pontját folyamatosan frissíteni kell az autó pozíciójának függvényében. Vagyis az autó egyébként folyamatosan frissülő referenciapontjához képest kell definiálni.
A megjelenítés is felhasználja ezeket a pontokat a háromszög kirajzolására a debuggoláshoz.</p>
<p><img src="sprints_old/images/camera.png" alt="" /></p>
<h3 id="definition-of-done-11"><a class="header" href="#definition-of-done-11">Definition of Done</a></h3>
<ul>
<li>1 db, a szélvédő mögé elhelyezett kamera implementálása</li>
<li>A látószög és távolság által meghatározott területen kérje el a <strong>releváns</strong> objektumokat
<ul>
<li>külön, a táblafelismerő szempontjából releváns objektumok, a táblák</li>
<li>külön, a sávtartó szempontjából releváns objektumok, az utak</li>
</ul>
</li>
<li>A háromszög koordinátái az autó helyzetétől függően folyamatosan frissülnek</li>
<li><input disabled="" type="checkbox"/>
a legközelebbi objektum legyen kiemelve</li>
</ul>
<!-- - A szenzorok által relevánsnak tartott objektumok vizuálisan kiemelhetők egy debug kapcsolóval (billentyű vagy debug módba váltás) -->
<!-- - A kamera szenzor a látható sávok összes adatát visszaadja(hány sáv, melyikben vagyunk, azon belül milyen távolságra a szélektől)
- A kamera szenzor a látott táblák közül a legközelebbi összes adatát visszaadja (milyen tábla, milyen messzire van) -->
<h3 id="Ütközés-detektálás-1"><a class="header" href="#Ütközés-detektálás-1">Ütközés-detektálás</a></h3>
<p>Folyamatosan vizsgálni kell, hogy a vezérelt autó nekiütközött-e egy ütközhető objektumnak. Ennek vizsgálatához használható a világobjektumok poligon váza. Később majd az automatikus vészfékező modul feladat lesz, hogy ez ne következhessen be.</p>
<ul>
<li>A vezérelt autó - tereptárgy ütközésének detektálása és esemény kiváltása</li>
<li>A vezérelt autó - NPC-vel való ütközésének detektálása és esemény kiváltása</li>
<li>Két objektum akkor ütközött amikor a poligon reprezentációjuk összeért, nem amikor a képfájlok fedik egymást
<ul>
<li>pl. autó a fa lombkoronája alatt, de még nem érte el a törzset</li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
Legyen valami visszajelzés felhasználói felületen arról, hogy ütközés történt (pl. alert dialog)</li>
</ul>
<h3 id="mozgásállapot-változás-szimuláció"><a class="header" href="#mozgásállapot-változás-szimuláció">Mozgásállapot-változás szimuláció</a></h3>
<p><strong>2021 tavasz: nem feladat</strong></p>
<p>A modul felelőssége, hogy az ütközésben részt vevő objektumok mozgásállapota az ütközés ereje függvényében megváltozzon. Ehhez egyrészt szükséges az objektumok sebessége, irányvektora és tömege is. Tömeg értékekkel a modell még nem rendelkezik ezek hozzáadása szintén a feladat része. Az autó, gyalogos, biciklis objektumokhoz keresni kell egy átlagos értéket. A statikus objektumok esetében azt is figyelembe kell venni vagy a tömeg értéken keresztül vagy ennél realisztikusabban, hogy rögzítettek. Pl. egy épület tömegét meg lehet választani kvázi végtelen nagyra így az nem tud elmozdulni az ütközés hatására. Egy ha esetében is hasonlóan lehet eljárni, egy táblát viszont könnyen elsodorhat egy autó.</p>
<ul>
<li>Az objektumok mozgásállapota az energiamegmaradás törvényeinek megfelelően változik (gyorsul, lassul, irányt vált, megáll)
<ul>
<li>Ha a vezérelt autó nekimegy egy NPC autónak akkor ez legyen rá hatással (lassuljon le)</li>
<li>Ha a vezérelt autó nagyobb sebességgel nekimegy egy „stabil” tereptárgynak (pl. fa), akkor álljon meg, érjen véget a játék, tekintsük úgy, hogy totálkáros.
<ul>
<li>egy táblán azonban át tud menni (el tudja sodorni), csak lassuljon le és sérüljön egy kicsit</li>
</ul>
</li>
</ul>
</li>
<li>Az objektumok sérülnek, akár megsemmisülnek amennyiben túl nagy energiával ütköznek</li>
<li>Ha a vezérelt autó elüt egy gyalogost, akkor érjen véget a játék</li>
<li>A játék véget ér, ha a játékos ütközés(ek) következtében mozgásképtelenné válik (megsemmisül)</li>
<li>Az NPC - NPC ütközés nem releváns
<ul>
<li>tehát ha NPC autó üti el a gyalogost, akkor nem kell, hogy véget érjen a játék</li>
</ul>
</li>
<li>Kisebb sérüléseknél a játékot ne kelljen újraindítani, valami inputra lehessen resetelni akár
<ul>
<li>sérülés visszaállítása nullára, vagy autó pozíciójának módosítása, hogy az ütközés már ne álljon fönt</li>
</ul>
</li>
</ul>
<h2 id="világ-populálása-mozgó-npc-objektumokkal"><a class="header" href="#világ-populálása-mozgó-npc-objektumokkal">Világ populálása mozgó NPC objektumokkal</a></h2>
<p>A modul felelőssége, hogy az előző sprintben felépített világot, amelyben már megjelennek a statikus objektumok és van egy működő, vezethető autó, további dinamikus objektumokkal kell kiegészíteni. Ezek a nem játszható karakterek (NPC, <em>non player character</em>), amelyekre azért van szükség, hogy a 3. sprintes modulok tesztelhetők legyenek. Például a vészfékező rendszer nem üti el a gyalogost, vagy az adaptív tempomat igazítja az autó sebességét az előtte haladó autóéhoz.</p>
<p>A modul bemenete a világmodell, amely egyrészt elősegíti az implementálást azáltal, hogy a előre definiált helyett az osztályhierarchiában az NPC objektumok számára, másrészt a statikus objektumok, egészen pontosan az út elemek definiálják a pályát amelyen az NPC autónak haladnia kell a KRESZ szabályai szerint: nem tér át az út másik oldalára, nem hajt gyorsan.</p>
<!-- Alapvetően két megközelítés lehetséges az útvonalak definiálásához. Az egyik, hogy a pályaelemeket (amelyek nem a világban elfoglalt helyzetük alapján sorba rendezve kerülnek eltárolásra) sorba rendezzük, kijelölünk egy  -->
<p>A legkézenfekvőbb megoldás, hogy a világban, a világ koordinátáira építve felveszünk vezérpontokat, amelyek kijelölnek egy utat. Ezeket célszerű nem a kódban, hanem valamilyen fájlban tárolni. Az NPC objektum pedig ezt az utat követni. Például a parkoló mellől indul az úton megy fölfele (csökken az y koordinátája) a kanyar előtt (x,y) világkoordinátákat elérve lelassul, (x,y)' koordináták elérése esetén elkezd kanyarodni, a sávból nem tér ki, majd (x,y)" koordinátáig halad a fönti egyenesen. És így tovább.</p>
<p><img src="sprints_old/images/npc_route.png" alt="" /></p>
<p><img src="sprints_old/images/npc_route_pedestrian.png" alt="" /></p>
<p>A mozgáshoz sebességet is kell társítani. Két vezérlőpont közötti egyenesen adott idő alatt kell az NPC-nek végighaladnia. Továbbá az egyes vezérlőpontokhoz forgatási műveletet is társítani kell. Ehhez egy mozgás leíró struktúra lesz szükséges, pl. az alábbi elnagyolt példa <a href="https://toml.io/en/">TOML</a> nyelven, de bármilyen megoldás választható (JSON, XML, YAML vagy teljesen egyedi formátum):</p>
<pre><code class="language-toml">[points]

[points.1]
x = 100
y = 200
rotation = 0
speed = 50 # px/s

[points.2]
x = 100
y = 100
rotation = 15
speed = 30 # px/s
</code></pre>
<p>A feladatban az igazi kihívás, hogy az NPC objektumok adaptálódjanak pályához. Az adaptálódást úgy lehet megkerülni, hogy mindkét pályához készül egy-egy útvonal.</p>
<p>Az NPC autónak nincs hajtáslánc modulja, nem szükséges olyan részletes mozgatás sem mint az vezérelt autónál, de azért a kanyarpontoknál legyen több lépésben megoldva, hogy fokozatosan legyen az autó elforgatva a kanyarodás valósághű leképezése céljából.</p>
<h3 id="definition-of-done-12"><a class="header" href="#definition-of-done-12">Definition of Done:</a></h3>
<ul>
<li>Objektumok előre definiált, értelmes helyen jelennek meg (autók úton, gyalogosok út mellett, a járda környékén)</li>
<li>Objektumok előre szkriptelt útvonalat követnek</li>
<li>Gyalogosok az út mentén haladnak, zebrán áthaladnak, megfordulnak majd újra átkelnek az úton</li>
<li>Autók az utat - sávot - pontosan követik</li>
<li>NPC objektumok egymás mozgásállapotát nem változtatják meg
<ul>
<li>Egy NPC autó gyalogoson akár átmehet, nem kell ütközésnek minősíteni</li>
</ul>
</li>
<li>Legalább egy autó végigmegy a pályán</li>
<li>Legalább egy gyalogos mozog és átkel egy zebrán</li>
<li>Új (a másik) pálya esetén az NPC objektumok adaptálódnak az új környezethez</li>
</ul>
<h2 id="radar-szenzor"><a class="header" href="#radar-szenzor">Radar szenzor</a></h2>
<p>A <em>radar sensor</em> modul felelőssége az adaptív tempomat és az automata vészfékező alapjául szolgáló radar szenzor szimulációjának implementálása. Mint minden szenzor, az radar is érzékeli a világ egy szeletét és eléri a látóterében található objektumokat.</p>
<p>A valóságos és szimulált szenzorok működését részletesebben a <a href="sprints_old/sensors.html"><em>Szenzorok</em></a> fejezet mutatja be.</p>
<p>A modul bemenete tehát a világmodell, kimenetét olyan ütközhető világ objektumok gyűjteménye képezi, amelyek beleesnek a szenzor látóterébe. A világ objektumainak lekérdezésére már léteznie kell egy publikus metódusnak, mely 3 pontot vár bemenetként és visszaadja a bele eső objektumokat. Ezekből kell még leválogatni a relevánsakat.
A szenzor látóterét 3 ponttal kel definiálni.</p>
<p>A szenzor látómezejének 3 pontját folyamatosan frissíteni kell az autó pozíciójának függvényében. Vagyis az autó egyébként folyamatosan frissülő referenciapontjához képest kell definiálni.
A megjelenítés is felhasználja ezeket a pontokat a háromszög kirajzolására a debuggoláshoz.</p>
<p><img src="sprints_old/images/radar.png" alt="Radar szenzor elhelyezése" /></p>
<p>A kihívás a komponenssel kapcsolatban, hogy nem elég egyszerűen csak visszaadni a látótérben található releváns objektumokat, hanem el kell tudni dönteni, hogy a jelenlegi haladási irányunkat tartva veszélyesek-e. Pl. pontosan előttünk halad (a sávban), vagy oldalról érkezik és keresztezi az utunkat. A legközelebbi releváns objektum az alábbi ábrán az 1-es, a 2-es nem.</p>
<p><img src="sprints_old/images/radar_lanes_simple.png" alt="Azonos sávban haladó jármű" /></p>
<p>Itt arról van szó, hogy a a szenzor egy iterációjában megkapjuk a látótérbe került ütközhető objektumokat. Egy fa pl. jellegénél fogva statikus, tehát túlzottan sok figyelmet nem igényel, de ugyanúgy továbbítani kell mint egy autót. Az NPC autó esetében az adott iterációban ismert az autó helyzete, majd ezt össze kell vetni az előző iterációban ismert helyzetével. A kettőből meghatározható egy irányvektor és el lehet dönteni, hogy merre halad (ha halad egyáltalán), előttünk halad, vagy mellettünk (pl. másik sávban), stb. Az ACC az azonos sávban előttünk haladó autó sebességét veszi fel, ezért az autó haladási iránya fontos szempont.</p>
<!-- nyomon kell követni őket és azonosítani az útvonalukat, ebből pedig meghatározni azt, hogy keresztezik-e a vezérelt autóét. -->
<!-- A vészfékezőnek reagálnia kell majd az akadályra, ha akkor is útban lesz-e még mire az autó odaér, ehhez szükséges az útban levő objektum távolsága és pozíciója (relatívan az autóhoz) -->
<!-- , ez minden ciklusban lefutva előállítja az objektum pl. gyalogos mozgásvektorát.
Nem a radar, hanem majd a ráépülő funkció fogja ezekből meghatázorni, hogy pl. oldalról a vezérelt autó útjába tart-e egy objektum és ez veszélyt jelent-e rá. -->
<!-- ![Oldalirányból érkező jármű](images/radar_aeb_sideward.png) -->
<p>Mindez értelemszerűen egy statikus objektum pl. fa esetében is működik, csak az nem mozog (mert nem Középföldén vagyunk).</p>
<!-- Az ACC-hez a radarnak el kell tudni dönteni, hogy pl. egy autó a vezérelt autó előtt halad-e. -->
<h3 id="definition-of-done-13"><a class="header" href="#definition-of-done-13">Definition of Done</a></h3>
<ul>
<li>Elkészült 1 db, az autó első lökhárítója mögött elhelyezett radar szenzor</li>
<li>A látószög (60°) és távolság (200m) által meghatározott területen kérjék el a <strong>releváns</strong> objektumokat</li>
<li>A háromszög koordinátái az autó helyzetétől függően folyamatosan frissülnek</li>
<li>Határozzák meg a legközelebbi, sávon belüli (lateral offset alapján) objektum helyzetét</li>
<li>Az automata vészfékező számára releváns objektumok (az autó középvonala felé halad, látjuk) kiválogatása és visszaadása</li>
<li>A legközelebbi objektum legyen vizuálisan kiemelve
<ul>
<li>a kiemelést a megjelenítés intézi az objektum tulajdonsága (kijelöltség) alapján, de azt, hogy éppen ki van-e jelölve a szenzornak kell az objektumon beállítani</li>
</ul>
</li>
</ul>
<!-- - debug célra bekapcsolható módon a háromszög legyen kirajzolhatóak **piros** színnel -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="3-sprint"><a class="header" href="#3-sprint">3. Sprint</a></h1>
<!-- toc -->
<h2 id="parkoló-automatika"><a class="header" href="#parkoló-automatika">Parkoló automatika</a></h2>
<p>A modul felelőssége az ultrahang szenzorokra épülő <a href="sprints_old/functions.html#parkol%C3%B3-asszisztens-parking-pilot---pp"><em>Parking Pilot</em></a> vezetéstámogató funkció elkészítése.
Ennek feladata, hogy a megtalálja a parkolóban a megfelelő nagyságú szabad helyet, majd oda -- vezetői beavatkozás nélkül -- beparkolja az autót.</p>
<p>A parkolóig még a sofőr vezet, megáll az autósor mellett aktiváltja a parkolóhely keresést (bekapcsolja a PP-ot és kiteszi az irányjelzőt abba az irányba ahol a parkolót keresni kell), majd továbbra is "emberi" irányítással el kell haladni a parkolóhelyek mellett. Eközben a funkció kiszámolja a szabad hely méretét. Amikor megvan az alkalmas hely, akkor visszajelzést kell adni a sofőrnek és a hely dimenzióját és az autóhoz viszonyított helyzetét le kell tudni írni (és átadni a buszon, ha a manőver végrehajtását végző komponens el van választva a kereső komponenstől).</p>
<p><img src="sprints_old/images/find_parking_place_horizontal.png" alt="" /></p>
<p>A parkolóhely a vezérelt autó (ennek ismert a szélessége és a hosszúsága) referenciapontjához viszonyítva legyen leírva. A parkolóhely hossza nem a felfestett parkolóhely hosszát jelenti. Egyrészt nem garantált, hogy mindenki szabályosan parkol, másrészt azt nem is lehet az ultrahang szenzorral lemérni. Ehelyett két parkoló autó által szabadon hagyott helyet (amely akár két felfestésnyi is lehet) kell detektálni.</p>
<p>A szabad hely szélessége ha egyéb akadályt -- pózna (<code>bollard.png</code>) vagy fa -- nem tesztek külön emiatt, támpontként a pályára, akkor a szenzor látótávolsága, azaz 3 méter. A szabad helyhez egy referenciapontot kell (érdemes) társítani, pl. a helyet leíró téglalap bal felső pontja (ábrán így van) és az autó középpontjával és ezzel a ponttal (ebből számolható a távolság) valamint a hely dimenzióival kielégítően jellemezhető a parkoló hely.</p>
<p><img src="sprints_old/images/parking_place_found_horizontal.png" alt="" /></p>
<p>Miután a hely keresése során még a sofőr vezet, a „van szabad parkoló” jelzésre vélhetően nem egy előre definiált pozícióban állítja meg az autót. Ezért fontos, hogy a szabad hely mindig a vezérel autó pozíciójához képest legyen definiálva, mert a parkolási manőver kezdetéig esetleg valamennyit hátra kell majd tolatni.</p>
<p>Ezután, (ha más nem próbálgatásos módszerrel) ki kell tapasztalni, hogy a szükséges "párhuzamos parkolás" manőver hogyan vihető végbe a vezérelt autó irányítószerveivel, majd ezt le kell automatizálni: pl. le kell írni, kormány jobbra teker 100-ra, gáz 25% 1,5s-ig, majd kormány balra 75, gáz 20% 1.25s-ig. Ez hasonló az NPC objektumok szkripteléséhez.</p>
<p>A programozott vezérlést a buszon keresztül kapott szabad helyet leíró adatok függvényében kell elindítani (amelyhez szükséges lehet tehát egy előzetes tolatás is.</p>
<p><img src="sprints_old/images/parking_horizontal.png" alt="" /></p>
<h3 id="definition-of-done-14"><a class="header" href="#definition-of-done-14">Definition of Done</a></h3>
<ul>
<li>Indexkapcsoló állása alapján parkolóhely keresés jobbra vagy balra</li>
<li>Autó méretének megfelelő hely beazonosítása</li>
<li>Megtalált parkoló jelzése, a hely információinak buszra írása (packet-tel)</li>
<li>A parkolóhely megtalálásához szükséges NPC-k példányosítása</li>
<li>A parkolás megkezdése külön inputhoz kötött (van erre vonatkozó gomb a műszerfalon, inputtól meg billentyűesemény)</li>
<li>A kormány és gáz/fék vezérlésével beparkolás a talált helyre</li>
<li>Párhuzamos parkolás sikeres (ütközés nélkül megtörténik)</li>
<li>Sofőr beavatkozására (fék, gáz, kormány) kikapcsolás (megszűnik az automata vezérlés)</li>
</ul>
<h2 id="sávtartó-automatika-és-táblafelismerés"><a class="header" href="#sávtartó-automatika-és-táblafelismerés">Sávtartó automatika és táblafelismerés</a></h2>
<p>A sávtartó automatika modul felelőssége a kamera szenzorra épülő <a href="sprints_old/functions.html#s%C3%A1vtart%C3%B3-automatika-lane-keeping-assistant---lka"><em>Lane Keeping Assistant</em></a> funkció megvalósítása.</p>
<p>Ezt két alapvetően kétféleképpen lehet megoldani. Az egyik a sáv széleihez viszonyítva korrigál: ha az autó elérné a sáv szélét, akkor ellenkormányoz. A másik megoldás kiszámolja a sáv közepét és azon tartja az autót.</p>
<h3 id="1-sáv-széleinek-használata-1"><a class="header" href="#1-sáv-széleinek-használata-1">1. Sáv széleinek használata</a></h3>
<p>Itt azt lehet vizsgálni, hogy a vezérelt autó jövőbeli helyzetében metszi-e a sávot.</p>
<p><img src="sprints_old/images/lka_a.png" alt="" /></p>
<h3 id="2-sávközép-használata-1"><a class="header" href="#2-sávközép-használata-1">2. Sávközép használata</a></h3>
<p>Itt a vezérelt autó középpontját lehet a sávközéphez igazítani.</p>
<p><img src="sprints_old/images/lka_b.png" alt="" /></p>
<p>Csak a 45 foknál enyhébb kanyarodású úton kell működnie, ilyenkor a kocsi a sáv szemmel látható közepét követi. Az LKA működése egy enyhe sávon belüli cikázást eredményez.</p>
<p><img src="sprints_old/images/lka_wave.png" alt="" /></p>
<p>Az automatika számára kezelhetetlen forgalmi szituációkban (pl. éles kanyar, kereszteződés) el kell engednie a vezérlést és ezt a vezető tudtára kell hoznia. Legyen hozzá vizuális figyelmeztetés a műszerfalon (pl. LKA visszajelző sárga). Ha újra olyan útszakasz következik, ahol a funkció használható, akkor arról szintén legyen tájékoztatás.
Ezen kívül természetesen a funkció ki- és bekapcsolható.</p>
<p>A <strong>Táblafelismerő</strong> modul felelőssége a kamera szenzor látómezejébe kerülő közlekedési táblák közül kiválogatja a relevánsakat (csak az adott irányra/sávra vonatkozó) és a műszerfalnak átadja megjelenítésre az utolsó látott releváns táblát, továbbá beállítja a buszon az aktuális sebességkorlátozást, amelyet az adaptív tempómat modul használ majd. Ez debug információként jelenjen is meg a műszerfalon (szövegesen mint az X,Y koordináták).</p>
<p><img src="sprints_old/images/tsr.png" alt="" /></p>
<h3 id="definition-of-done-15"><a class="header" href="#definition-of-done-15">Definition of Done</a></h3>
<ul>
<li>A sávtartó automatika ki- és bekapcsolható
<ul>
<li>emberi beavatkozásra kikapcsol</li>
</ul>
</li>
<li>45 foknál enyhébb kanyarodású úton a kocsi a sáv szemmel láthatóan a sáv közepén marad</li>
<li>Ha el kell engednie a kontrollt (az automatika számára kezelhetetlen forgalmi szituáció következik, pl. éles kanyar, kereszteződés), vizuális figyelmeztetést ad</li>
<li>Ha újra elérhető a funkció (pl. elhagytuk a kanyart) vizuális indikáció (a műszerfalon)</li>
</ul>
<p>Táblafelismerő:</p>
<ul>
<li>az utolsó látott, releváns tábla megjelenik a műszerfalon</li>
<li>az utolsó sebességkorlátozás kiírásra kerül a buszra
<ul>
<li>és megjelenik debug információként a műszerfalon</li>
</ul>
</li>
</ul>
<h2 id="adaptív-tempomat-1"><a class="header" href="#adaptív-tempomat-1">Adaptív tempomat</a></h2>
<p>A modul felelőssége a radar szenzorra épülő <a href="sprints_old/functions.html#adapt%C3%ADv-tempomat-adaptive-cruise-control---acc"><em>adaptív tempomat</em></a> vezetéstámogató funkció elkészítése. Ennek a funkciónak három felhasználói esetet kell lefednie.</p>
<ol>
<li>Felhasználó által beállított sebesség tartása</li>
<li>A táblafelismerő által közölt sebességkorlátozás betartása</li>
<li>Az előttünk haladó (NPC) autó sebességének felvétele és egy (időben definiált) beállított követési távolság tartása
<ul>
<li>Valójában ettől lesz adaptív</li>
</ul>
</li>
</ol>
<p>Az egyes ponthoz szükséges kezelőszervek már elkészültek az első sprintben és a funkcióhoz szükséges bemeneti értékek már a buszon keresztül elérhetőek. A modulnak szabályoznia kell a hajtásláncot, hogy ne léphesse túl a beállított sebességet. Ehhez olyan inputot kel biztosítania mintha az a billentyűzetről érkezne, de a tényleges vezetői input felülírja őket.</p>
<p>A kettes pont egy harmadik sprintes (tehát aktuálisan készülő funkciótól függ), azonban könnyen visszavezethető az első pontra. A közúti szabályozást magasabb prioritásúnak kell minősíteni. Tehát a felhasználó pl. beállít egy 70 km/h-ás célsebességet, majd érkezik egy kérés a táblafelismerőtől, hogy 50km/h a megengedett, akkor azt kell figyelembe venni.</p>
<p>A hármas pont egy második sprintes modultól, az NPC autók meglététől függ. Az előttünk haladó sebességéhez való igazodás a legmagasabb prioritású, hiszen hiába szeretne a vezető 70-el haladni, mikor a tábla szerint 50-nel lehet, de ha az előttünk haladó mindössze 40-el halad, akkor ahhoz kell igazodni, különben nekiütközünk.
Oda kell figyelni, hogy csak a sávban előttünk haladó autót vegye figyelembe, a szembejövőt ne.</p>
<p>A követési <em>távolság</em> időben történő megadása azt jelenti, hogy a beállított (pl.) 1 másodperces követés esetén akkora távolságot kell hagyni, hogy <strong>az aktuális sebességgel</strong> haladva 1 másodperc alatt megtett út legyen a távolság: 10 m/s (36 km/h) esetében 10 méter. Ezen érték beállítására már az első sprintben készült vezérlő.</p>
<p><img src="sprints_old/images/acc.png" alt="" /></p>
<h3 id="definition-of-done-16"><a class="header" href="#definition-of-done-16">Definition of Done</a></h3>
<ul>
<li>Ki- és bekapcsolható</li>
<li>Bekapcsoláskor a célsebessége az aktuális sebesség, de a minimum célsebesség 30 km/h</li>
<li>Ha nincs saját sávban előttünk autó, akkor a vezérelt autó tartja a kiválasztott célsebességet</li>
<li>Ha a saját sávban található autó:
<ul>
<li>Ha az előttünk levő autó lassabb, akkor fel kell venni a sebességét</li>
<li>Ha gyorsabb, akkor tartja a kiválasztott sebességet</li>
</ul>
</li>
<li>Fékezésre kikapcsol</li>
<li>AEB beavatkozásra kikapcsol</li>
<li>Ha sebesség korlétozást talál a buszon, azt alkalmazza új célsebességként, amíg a sofőr felül nem írja</li>
</ul>
<h2 id="vészfékező-1"><a class="header" href="#vészfékező-1">Vészfékező</a></h2>
<p>A modul felelőssége a radar szenzorra épülő <a href="sprints_old/functions.html#auton%C3%B3m-v%C3%A9szf%C3%A9kez%C5%91-rendszer-automatic-emergency-brake---aeb">automata vészfékező rendszer</a> megvalósítása. A vészfékező kritikus biztonsági funkció, így nem kapcsolható ki manuálisan, de maximum 70 km/h sebességig működik. A működése két esetre bontható: ütközés statikus vagy dinamikus objektummal.</p>
<p>Az előbbi az egyszerűbb eset, mivel a veszélyt jelentő objektum pozíciója változatlan.</p>
<p><img src="sprints_old/images/aeb_radar_static.png" alt="" /></p>
<p>El kell dönteni, hogy az autó az aktuális irányvektort figyelembe véve ütközni fog-e az objektummal. Ha igen, az autó ismert sebességét figyelembe véve kiszámolható, hogy ehhez mennyi időre van szükség és, hogy mekkora mértékű lassulás kell ehhez.</p>
<p>A radar visszaadja az autó előtt levő legközelebbi releváns objektum adatait (táv, sebesség), ezekkel lehet számolni. A távolságból és az autó sebességéből meghatározható, hogy milyen lassulást kell adni az autónak, hogy még megálljon, de ne lépje túl a \( 9 m/s^2 \)-et.</p>
<p>Ha az ütközés elkerülhető, vizuális figyelmeztetést kell elhelyezni a vezetőnek, hogy fékezzen. Ha nem reagál, azaz továbbra is ütközési pályán vagyunk és már csak vészfékezéssel kerülhető el az ütközés, akkor a hajtásláncnak vészfékezési inputot kell adni. Ez a maximálisan megengedett, \( 9 m/s^2 \)-es lassulást (ennél nagyobb lassulás veszélyes az utasokra), akkor</p>
<p>Ha más nem próbálgatással meg kell határozni, hogy adott sebességről egy maximális fékezési input (100% pedál állás) mennyi idő alatt fékezi állóra az autót.
A modul olyan triggerekkel vezérli az autót mint amilyenek a billentyűlenyomás kezelőtől jönnek (fékpedál állás).</p>
<p>Dinamikus objektumok esetében a vészfékezés elve azonos, de az ütközési pálya meghatározása összetettebb.</p>
<p><img src="sprints_old/images/aeb_radar_pedestrian.png" alt="" /></p>
<p>Másik sávban szembe jövő autóra nem kell vészfékezni, tehát el kell tudni dönteni, hogy abban az esetben nincs ütközési pálya.</p>
<p><img src="sprints_old/images/radar_lanes_simple.png" alt="" /></p>
<h3 id="definition-of-done-17"><a class="header" href="#definition-of-done-17">Definition of Done</a></h3>
<ul>
<li>Elkerülhető ütközés esetén vizuális figyelmeztetés a sofőrnek</li>
<li>Ha a sofőr nem avatkozik közbe, automatikus fékezés (az utolsó pillanatban, ahol az ütközés még elkerülhető)</li>
<li>Az automatikus fékezés mértéke a sebességgel arányos, de nem lehet \( 9 m/s^2 \)-nél nagyobb</li>
<li>70 km/h felett figyelmeztetés, hogy az AEB nem tud minden helyzetet kezelni</li>
<li>A vezérelt autó nem üt el gyalogost, nem megy neki fának</li>
<li>Nem releváns objektumok esetében (fals pozitív) mint a szembejövő autó nem történik vészfékezés</li>
</ul>
<h2 id="tolatóradar--tolatókamera"><a class="header" href="#tolatóradar--tolatókamera">Tolatóradar / Tolatókamera</a></h2>
<p>A modul felelőssége a hátsó két ultrahang szenzorra épülő tolatóradar (és kamera) implementálása, amely visszajelzést ad a vezetőnek, arról, hogy tolatás közben veszélyesen közelre került-e valamilyen objektumhoz.
A távolság számoláshoz itt is lehet használni az objektum referenciákat, az objektum koordinátái közvetlenül elérhetőek, de ne az objektum közepéhez, hanem értelem szerűen annak széléhez képest legyen kiszámolva a távolság.</p>
<p><img src="sprints_old/images/reverse_radar_system_horizontal.png" alt="" /></p>
<p>Hozzá tartozó GUI, Valami ehhez hasonlóként lehet elképzelni: <a href="https://www.youtube.com/watch?v=qZkCoDChS4A">YouTube videó</a>. A bal- és jobboldali szenzor legközelebbi objektumának értéke külön-külön kerüljön megjelenítésre.</p>
<p><img src="sprints_old/images/gui_plan_dashboard_with_rr.png" alt="" /></p>
<p>A tolató radar mellé legyen a tolatókamerák távolságkijelzése is megvalósítva a pályamegjelenítőjén, három lépcsőben 0.5m piros, utána 1m sárga majd az autó hosszáig zöld. Ez hátramenetben kerüljön megjelenítésre, nem debug-funkcióként.</p>
<p><img src="sprints_old/images/reversing_camera.png" alt="" /></p>
<h3 id="definition-of-done-18"><a class="header" href="#definition-of-done-18">Definition of Done</a></h3>
<ul>
<li>a tolatóradar csak hátramenetben aktív</li>
<li>figyelmeztetés megjelenítése a műszerfalon 3 fokozatban
<ul>
<li>nincs akadály (zöld)</li>
<li>közel van akadály: 0.8m-en belül (sárga)</li>
<li>nagyon közel van akadály 0.4m-en belül (piros)</li>
</ul>
</li>
<li>távolság megjelenítése a műszerfalon</li>
<li>távolságok kirajzolása a képernyőre
<ul>
<li>az autó pozíciójához képest folyamatosan frissül</li>
<li>hátramenetben mindig látszik (nem debug funkció)</li>
</ul>
</li>
</ul>
<p>Korábbi implementáció (ekkor csak a műszerfalas visszajelzés volt feladat):</p>
<p><img src="sprints_old/images/reverse_radar_2020spring.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="demók-1"><a class="header" href="#demók-1">Demók</a></h1>
<p>A félév során a csapatok három alkalommal prezentálják az elvégzett munkát. A „demók” az <em>elkészült</em> szoftver megrendelőnek való bemutatását szimulálják. Nem a kódra vagyunk kíváncsiak, hanem működés közben szeretnénk látni, hogy a szoftver teljesíti feladatban foglalt követelményeket.
A bemutatás során, a <code>master</code> branchre befogadott kódot vesszük figyelembe, minden egyéb <em>„nem készült el határidőre”</em>, azaz értékelhetetlen.</p>
<h2 id="ideális-eset-az-első-sprint-után"><a class="header" href="#ideális-eset-az-első-sprint-után">Ideális eset az első sprint után</a></h2>
<p>A „megrendelő” az aktuális master branchről elindítja a szoftvert, az ablak bal oldalán ott van az autó (középen), az út fölé helyezve, jobb oldalon a műszerfal mutatja az állapotát. Sebességbe teszi az autót, majd gázt ad, elindul, kicsit mászkál a világban, teszteli a gyorsulás, lassulás és kanyarodás „érzetét”, közben megfigyeli a pálya illesztéseit és a „grafika folytonosságát”.
Még kipróbálja a debug funkciókat és egyéb kapcsolót a rend kedvéért.</p>
<p><strong>konklúzió</strong>: a pálya hibátlanul kirajzolásra került, emögött <em>vélhetően</em> van egy modell világ, hiszen a poligonok is rendben a helyükön vannak, az autó mozgása „rendben van”, nem volt cél egy profi autószimulátor szintű fizika, ha a sebesség-változások és a fordulás nem mutat kiugró rendellenességet, az autó pontosan vezethető (érts, végre tudok hajtani pl. egy párhuzamos parkolást), és a műszerfal közvetíti azt amit látunk, akkor mind a 4 csapat kifogástalan munkát végzett, mindenki teljesítménye 5-ös, lehet foglalkozni érdekesebb témákkal.</p>
<h2 id="realisztikus-demó-sok-félév-tapasztalata-alapján"><a class="header" href="#realisztikus-demó-sok-félév-tapasztalata-alapján">Realisztikus demó, sok félév tapasztalata alapján</a></h2>
<p>Eleve még reggel 3/4 8-kor fogadom el az utolsó PR-eket (amik esetenként éjfél után készültek el), tulajdonképp érdemi review nélkül, mert nem akarom, hogy ezen múljon a demó sikeressége, ha fordul, nincs ütközés és az automatizált ellenőrzések sem mutatnak hibát akkor beengedem a masterbe.</p>
<p>A szoftver máskor nem is indul, mert valaki a <code>C:\Users\XYZ\ÓE\AutomatedCar\Assets</code> mappát beégette a kódba. Ezt ott élesben kijavítjuk, végre nem száll el kivétellel. A műszerfal vezérlőinek egy része ott van, de nincs bekötve, nem az autó állapotát, hanem konstans dummy értékeket mutat, rosszabb esetben azért, mert skeleton dummy mozgatása aktív még mindig, jobb esetben azért mert a hajtáslánc ugyan mozgatja az autót, de nem propagálja az állapotát a műszerfal felé.
Néha az történik, hogy a hajtáslánc propagálja ezeket, de X csomagban, míg a hajtáslánc Y csomagot vár.</p>
<p>A fordulókör kicsit irreális, de azért kanyarodni lehet, nincs nagy vész, akár 1 óra alatt fixálható; az autó gyorsul, de irreálisan gyorsan vagy lassan. Teljesen egyértelmű, hogy a kollégák alapos munkát végeztek a mozgatás fizikai részének implementálásában, utánaolvastak meg minden, de sosem próbálták ki, hogy milyen érzés vezetni az autót, mert akkor rájöttek volna, hogy pár konstanst finomhangolni kell. Ebben minden bizonnyal az is közrejátszhatott, hogy a kód eleve exception-el elszállt és a hiba nem az ő térfelükön volt, a felelős csapatnak meg, a demó előtti szerda este 8-kor jelentett bugot meg már nem tudta időben javítani.</p>
<p>A képfájlok gyakran nem illeszkednek, némelyik elem nem úgy van elforgatva, ahogy kellene. Ugyanaz a helyzet mint fentebb, valami nem úgy volt kommunikálva, valaki úgy gondolta, hogy fokban van a szög, más meg úgy, hogy radiánban. Látszik, hogy a munka nagyja kész, de a pályára nem lehet azt mondani, hogy ki van rajzolva, mert tulajdonképpen csak összevissza kirakott útdarabokat látni.
Mivel már a képek sem kerültek ki hibátlanul, így a poligonokhoz hozzá sem nyúltak, mondván ha a képek jók, akkor a poligonok kirakása gyerekjáték (valóban), de arra nem jutott idő.</p>
<p>Ezek után és közben egy-egy kolléga hevesen elkezdi mutogatni a kódot, hogy de hát itt van az elforgatás implementálva, mindenki lássa bele azt amit ő lát, hogy ez a metódus, amihez még unit tesztet is írt, tényleg hibátlanul el tud forgatni egy útelemet.</p>
<p>Aztán gyakori jelenség még, hogy a csapat jelzi, hogy sajnos odáig nem jutottak el, hogy a masterbe kerüljön a kód, de ők szeretnének saját branch-ről/gépről prezentálni. Ilyenkor rábólintunk, hátha látunk valami lenyűgözőt. A kolléga néha ekkor indítja az IDE-t, de se baj, után a még átváltja a branch-et, elindítja de nem az történik amit várt, majd a csapattársa jelzi, hogy már ne a team3_perfect_steering branchet nézze, hanem a team3_perfect_steering2-t, mert ő fél 2-kor még abban fixálta a hátramenetben történő kanyarodást, de valójában azt nem tudja megmondani, hogy a műszerfalra az fordulatszám miért nem kerül ki. Ugyanis azt a részt XYZ kolléga csinálta, aki most nincs itt, mert dolgozik, de skype-on azt írta, hogy kész van vele, nála működik.</p>
<p>Természetesen, ebben összevontam azokat a hibákat és jelenségeket, amelyeket előfordulnak, nem egy konkrét forgatókönyv volt, hanem állatorvosi ló gyanánt összemosott, ilyen értelemben fiktív történet, de külön-külön minden eleme valóságos, megtörtént eset.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="acceptance-test-convoy"><a class="header" href="#acceptance-test-convoy">Acceptance test: 'convoy'</a></h1>
<p><a href="https://www.youtube.com/watch?v=Xbjdmw8D9-Y"><img src="https://img.youtube.com/vi/Xbjdmw8D9-Y/0.jpg" alt="Konvoj" /></a></p>
<p>A fenti videó a Hyundai promóciós videója az olyan vezetéstámogató rendszereiről, mint az adaptív sebességtartó automatika, az automata vészfékező vagy a sávtartó automatika. A cél a fenti videón bemutatott tesztet teljesítő funkciók implementálása egy leegyszerűsített, szimulált környezetben.</p>
<p><img src="sprints/../images/oval.png" alt="" /></p>
<ul>
<li>A pálya szélessége ~500m, magassága ~300m, a kanyarok 6 fokos elemekből állnak, hogy a sávtartó automatika le tudja kezelni.</li>
<li>Az NPC modul (sprint 1 / team 3) implementálja a fekete furgon mozgását, amely a parkoló mellől indul, állandó 50km/h-s sebességgel körbemegy a pályán.</li>
<li>A teszt során, a vevő vezeti a fehér (vezérelt) autót, ami egy AutomatedCar példány, besorol a fekete NPC mögé, aktiválja az LKA-t és az ACC-t.</li>
<li>Majd átvált a másik AutomatedCar példányra, a pirosra, amikor odaér a konvoj, besorol a fehér AutomatedCar mögé, aktiválja az LKA-t és az ACC-t.</li>
<li>Az NPC útvonala szerint mikor megtett egy kört, akkor a stop táblánál nyom egy satuféket (a tábla csak vizuális visszajelzésként céllal van kint a pályán).</li>
<li>A satufék nem azt jelenti, hogy 0 másodperc alatt lassul 0-ra a sebessége, hanem egy erőteljes fékezés kerül megvalósításra az NPC szkript segítségével.</li>
<li>Az NPC ütközhető objektum, az ACC és a AEB szépen elkerüli az ütközést, mindkét példánynál.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="munkakörnyezet"><a class="header" href="#munkakörnyezet">Munkakörnyezet</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="git"><a class="header" href="#git">Git</a></h1>
<!-- toc -->
<h2 id="interaktív-online-oktató-anyagok"><a class="header" href="#interaktív-online-oktató-anyagok">Interaktív online oktató anyagok</a></h2>
<ol>
<li><a href="https://www.katacoda.com/courses/git">Webes interaktív oktatóanyag</a>
<ul>
<li>GitHub fiókkal -többek közt- a git kurzus ingyenesen végigvihető</li>
<li>az első 6 modul mindenképpen ajánlott</li>
</ul>
</li>
<li><a href="http://learngitbranching.js.org/">Learn Git Branching</a>
<ul>
<li>ez kifejezetten a branchelésre megy rá, szóval nem véletlenül a második!</li>
</ul>
</li>
</ol>
<h2 id="online-anyagok"><a class="header" href="#online-anyagok">Online anyagok</a></h2>
<ul>
<li><a href="http://smutch.github.io/VersionControlTutorial/">Version Control Tutorial</a>
<ul>
<li>kezdőknek, az alapoktól</li>
</ul>
</li>
<li><a href="http://rogerdudler.github.io/git-guide/">git - the simple guide</a>
<ul>
<li>inkább újrakezdőknek, ismétlés szintű</li>
</ul>
</li>
<li><a href="https://www.atlassian.com/git/tutorials">Altassian Git tutoriálja</a></li>
<li><a href="http://goalkicker.com/GitBook/">Git Notes for Professionals book</a>
<ul>
<li>haladókank, nem tanítja a git használatát, de <em>probléma: megoldás</em> alapon összefoglalja a használatának majd minden aspektusát (a Stackoverflow válaszok alapján)</li>
</ul>
</li>
<li><a href="https://git-scm.com/book/en/v2/">Git könyv</a>
<ul>
<li>mindent tartalmaz a gitről, gyakorlatilag a fejlesztők által írt dokumentáció</li>
<li><a href="https://git-scm.com/book/en/v2/Git-Branching-Branches-in-a-Nutshell">"git branching in a nutshell"</a> fejezete viszont minimum ajánlott</li>
</ul>
</li>
<li><a href="https://help.github.com/articles/syncing-a-fork/">Fork szinkronizálása</a></li>
</ul>
<h3 id="puskák-pdf-formátumban"><a class="header" href="#puskák-pdf-formátumban">Puskák PDF formátumban</a></h3>
<ul>
<li><a href="https://education.github.com/git-cheat-sheet-education.pdf">GitHubtól</a></li>
<li><a href="https://about.gitlab.com/images/press/git-cheat-sheet.pdf">GitLabtól</a></li>
<li><a href="https://www.atlassian.com/dms/wac/images/landing/git/atlassian_git_cheatsheet.pdf">Altassiantól (BitBucket)</a></li>
</ul>
<h2 id="kliensek"><a class="header" href="#kliensek">Kliensek</a></h2>
<p>A fejlesztői környezetek rendelkeznek Git integrációval, de a parancssoron kívül grafikus kliensek is <a href="https://git-scm.com/downloads/guis">léteznek</a>, többek között a <a href="https://desktop.github.com/">GitHub saját asztali kliense</a>.</p>
<ul>
<li><a href="https://gitforwindows.org/">Git for Windows</a></li>
</ul>
<h2 id="egyéb"><a class="header" href="#egyéb">Egyéb</a></h2>
<ul>
<li>Egy commit üzenet utólagos megváltoztatása <a href="https://help.github.com/articles/changing-a-commit-message/">nem egyszerű</a> (különösen ha pusholva lett, lokálisan még nem is olyan vészes), így eleve írjuk meg korrekten.</li>
<li>Ha többen dolgoztok egy módosításon akkor a commit üzenet láblécében tüntessétek föl a <a href="https://help.github.com/articles/creating-a-commit-with-multiple-authors/">társszerzőket is</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="github"><a class="header" href="#github">GitHub</a></h1>
<p>A félév során a GitHubot használjuk a kód tárolására, a feladatok menedzselésére is és kommunikációra is.</p>
<h2 id="oktatóanyagok"><a class="header" href="#oktatóanyagok">Oktatóanyagok</a></h2>
<ul>
<li><a href="https://lab.github.com/"><strong>interaktív oktatófelület</strong></a></li>
<li><a href="https://guides.github.com/">GitHub Guides</a></li>
</ul>
<h2 id="Áttekintés"><a class="header" href="#Áttekintés">Áttekintés</a></h2>
<p>Minden hallgató tagja lesz egy GitHub szervezetnek (<code>Organization</code>), és egy-egy csapatnak (Team A[1-4], Team B[1-4]). Minden csapat külön issue board-dal rendelkezik (<code>Projects</code>), ezen kell vezetni a feladatok (<code>issue</code>) megoldását (részletében lásd <a href="workflow.html">Munkafolyamat</a>).</p>
<p>Issue-t nem csak feladatra lehet felvenni, akár kérdésre is (felénk vagy más csapatok felé is), probléma megvitatására is. Ez esetben célszerű megjelölni a <code>type: question</code> címkével. 2017 őszétől csapat (<code>team</code>) szintű fórummal (<code>Discussions</code>) is rendelkezik a GitHub. A szervezeten belül a csapatok hierarchikus struktúrában vannak. A gyökér az <em>Everyone</em>, az összes többi csapat ennek tagja (Group A, Group B csapatokon keresztül). Az Everyone falára írt üzeneteket mindenki megkapja. Ezen keresztül fogunk a félév során kurzus szintű közleményeket kiadni, de bárki használhatja kommunikációra. Ugyanilyen üzenőfallal rendelkezik az összes többi csapat is, amelyre szintén bárki írhat. Ha például a Team2-ből szeretné elérni valaki a Team3-at, akkor mindösszesen annyi a dolga, hogy ír a Team3 üzenőfalára. Az <em>Instructors</em> nevű team-en keresztül az oktatókat lehet elérni ugyanilyen módon.</p>
<p>A comment szekciókban is élnek az @ jeles említések, ez a mi esetünkben <code>@ravaszla</code> és <code>@pintergreg</code>, ugyanígy működik csapatra is pl. <code>@szfmv2020-osz/team-a1</code>, illetve <code>@szfmv2020-osz/instructors </code> a mi esetünkben. Csapat esetében a csapat valamennyi tagja kap értesítést az hivatkozásról.</p>
<p>A GitHub valamennyi elemén használhatóak formázási lehetőségek <a href="https://guides.github.com/features/mastering-markdown/">Markdown stílusban</a>, kód kiemelésre is lehetőség van, amelyet több mint célszerű használni. Ehhez csak a nyelv nevét kell csak a nyitó ``` jelek után írni:</p>
<pre>
```python
def get_random_number():
    return 4;  # chosen by fair dice roll. guaranteed to be random.
```
</pre>
<p>Eredmény:</p>
<pre><code class="language-python">def get_random_number():
    return 4;  # chosen by fair dice roll. guaranteed to be random.
</code></pre>
<h2 id="címkék"><a class="header" href="#címkék">Címkék</a></h2>
<p>Létrehozásra kerültek címkék (<code>Labels</code>) négy „dimenzióban” (vagy kategóriában), amelyek használata elvárás a létrehozott issue-khoz a munka áttekinthetőségének javítása miatt. Kell, hogy legyen az issue-nak típusa, állapota, prioritása és legyen megjelölve a feladat nehézsége is.</p>
<p><img src="images/labels.png" alt="" /></p>
<h3 id="típus-type"><a class="header" href="#típus-type">Típus (type)</a></h3>
<ul>
<li>bug</li>
<li>design</li>
<li>documentation</li>
<li>enhancement</li>
<li>integration</li>
<li>question</li>
<li>user story</li>
</ul>
<h3 id="Állapot-status"><a class="header" href="#Állapot-status">Állapot (status)</a></h3>
<ul>
<li>completed</li>
<li>duplicate</li>
<li>help wanted</li>
<li>invalid</li>
<li>pending</li>
<li>review needed</li>
</ul>
<h3 id="prioritás-priority"><a class="header" href="#prioritás-priority">Prioritás (priority)</a></h3>
<ul>
<li>critical</li>
<li>high</li>
<li>moderate</li>
<li>low</li>
</ul>
<h3 id="nehézség-effort"><a class="header" href="#nehézség-effort">Nehézség (effort)</a></h3>
<ul>
<li>high</li>
<li>moderate</li>
<li>low</li>
</ul>
<!--
## Pull requestek kezelése:  review és ütközésfeloldás

Előfordulhat, hogy a git nem tudja feloldani a változtatásokat és emberi beavatkozást igényel a merge-elés. Például létrehoztad a feature branchet a csapat branch adott állapotáról, ám az időközben módosult és a módosítás ugyanazon fájl ugyanazon részét érintette. A GitHubon ez az alábbihoz hasonlóan néz ki:

![PR conflict](images/conflict.png)

Ezen belül is egyszerűbb esetekben a GH felajánlja a webes szerkesztőjét, de összetettebb esetekben ki kell checkolni az adott ágat és „kézzel” (editorral) feloldani helyzetet.

**Fontos!** A masterbe nem fogadunk el olyan PR-et, amelyben ütközés van, mivel jellemzően nem tudjuk eldönteni, hogy melyik változat fele meg „az utoljára megbeszélteknek”.

### Webes szerkesztő

A képen az  látható, hogy Hegedűs kolléga a `master` azon állapotában írta be a nevét, amikor a 64. sor volt az utolsó. Időközben egyéb PR-eket is elfogadtam így a git nem tudja, hogy a 68-73. sorokat kell megtartani vagy a 66.-at (ennek szintaktikáját látni a „kacsacsőrökkel”).

![GH web editor](images/conflict_web_editor.png)

 Jelen esetben persze mindkettő kell, így kézzel átrendezem, majd ezt megjelölöm feloldottnak:

![GH web editor](images/conflict_web_editor2.png)
![conflict resolved](images/conflict_mark_resolved.png)

**További tippek a témában**: https://stackoverflow.com/questions/161813/how-to-resolve-merge-conflicts-in-git

Ekkor a GH azt mutatja, hogy nincs ütközés, de review szükséges (ha nem is volt ütközés, akkor innen indul a történet).

### Lokális szerkesztő

Ha a GH webes felületén nem engedi az ütközés feloldását, akkor lokálisan kell. Az IDEA pl. az alábbi három paneles megoldást kínálja. Csak rá kell kattintgatni arra, amelyiket meg akarjuk tartani (vagy kézzel összemásolni mint a fönti példa esetében).

Ha valaki parancssorból intézi, akkor a beállított editorral nyitja meg (vi, nano, stb.) és szintaktikailag ugyanazt a megoldást kapja mint a webes editor esetében.

![](http://www.tilcode.com/wp-content/uploads/2015/09/intellij_merge_conflict_tool.png)
-->
<h2 id="branching-modell"><a class="header" href="#branching-modell">Branching modell</a></h2>
<p>Csoportos munka során fontos tisztázandó kérdés, hogy milyen stratégiával kezeljük a branch-eket. Az egyik legismertebb talán a GitFlow (<a href="http://nvie.com/posts/a-successful-git-branching-model/">A successful Git branching model</a>), amelyet mára több kritika is ért.</p>
<p>A legelterjedtebbek tőbb tulajdonságait Scott Shipp <a href="https://dev.to/scottshipp/war-of-the-git-flows-3ec2">War of the Git Flows</a> című cikke nyomán a következő táblázatban foglaltam össze:</p>
<div class="table-wrapper"><table><thead><tr><th></th><th>GitFlow</th><th>GitHub Flow</th><th>OneFlow</th><th>GitLab Flow</th><th>Trunk-Based Development</th><th>Rebasing Flow</th></tr></thead><tbody>
<tr><td>Uses feature branches</td><td>yes</td><td>yes</td><td>yes</td><td>yes</td><td>optionally, if short lived</td><td>no</td></tr>
<tr><td>Uses release branches</td><td>yes</td><td>no</td><td>yes</td><td>yes</td><td>yes</td><td>optional</td></tr>
<tr><td>Uses rebasing</td><td>no</td><td>no</td><td>optional</td><td>optional</td><td>optional</td><td>yes</td></tr>
<tr><td>Merges</td><td>no fast forward merges</td><td>unclear</td><td>up to you</td><td>up to you</td><td>optional</td><td>no</td></tr>
</tbody></table>
</div>
<ul>
<li><a href="http://nvie.com/posts/a-successful-git-branching-model/">A successful Git branching model</a></li>
<li><a href="https://barro.github.io/2016/02/a-succesful-git-branching-model-considered-harmful/">A succesful Git branching model considered harmful</a></li>
<li><a href="https://trunkbaseddevelopment.com/">Trunk-Based Development</a></li>
<li><a href="https://guides.github.com/introduction/flow/">GitHubFlow</a></li>
<li><a href="https://docs.gitlab.com/ee/topics/gitlab_flow.html">GitLabFlow</a></li>
<li><a href="https://www.endoflineblog.com/oneflow-a-git-branching-model-and-workflow#oneflow-advantages">OneFlow</a></li>
<li><a href="https://gist.github.com/jbenet/ee6c9ac48068889b0912">a simple git branching model</a></li>
<li><a href="https://www.atlassian.com/git/tutorials/comparing-workflows">Comparing Workflows</a></li>
</ul>
<p>A korábbi félévekben a GitFlow szerű megoldást használtuk megbonyolítva azzal, hogy minden csapatnak saját fejlesztői branche-e volt. Ezt jelentősen leegyszerűsítendő a <a href="https://guides.github.com/introduction/flow/">GitHubFlow</a>-ra váltunk.</p>
<p>A <code>master</code> branch <a href="https://docs.github.com/en/github/administering-a-repository/about-protected-branches">védett</a>, nem lehet bele commitolni. Minden feladatohoz tartoznia kell egy issue-nak, és a megoldásához létre kell hozni egy (feature) branchet az aktuális masterről. A feladatot azon kell megoldani, majd PR-et nyitni a masterbe.</p>
<p>Ahhoz, hogy a masterbe kerülhessen a módosítás több követelménynek is teljesülnie kell:</p>
<ul>
<li>a kód fordul</li>
<li>az összes teszt sikeres</li>
<li>két csapattárs és egy oktató jóvá hagyta (review)</li>
<li>nincs ütközés (conflict)</li>
</ul>
<!-- ![](images/branching.png) -->
<!-- A `master` branch védett, nem lehet bele commitolni. Nem egy, hanem több (4) fejlesztői branch-ünk van (`team1`, ..., `team4`), ezek szintén védettek. Minden feladathoz létre kell hozni egy *feature branch-et*, azon lehet dolgozni. Ha a feladat elkészült, akkor a csapat branchbe lehet *merge-eni*. Ami mivel védett [*pull request-et*](https://help.github.com/articles/about-pull-requests/) (továbbiakban PR) küldeni. A PR lehetőséget biztosít ellenőrzésekre és [review-zásra](https://help.github.com/articles/about-pull-request-reviews/). Csak a lefordítható, teszteknek megfelelő, ütközés (conflict) mentes PR kerülhet elfogadásra! -->
<p><strong>Fontos</strong>: Ha egy Pull Request <em>nem</em> fogadható el, akkor sem kell a PR-t lezárni, lehet tovább dolgozni a forrás branchen, az új commit-okkal automatikusan frissül a PR is addig míg a teszteknek meg nem felel és elfogadásra nem került. Sőt, kifejezetten lehet <a href="https://github.blog/2019-02-14-introducing-draft-pull-requests/"><strong>Draft* Pull Request</strong></a> is létrehozni, jelezve, hogy a munka már tartalmaz véleményezhető elemeket, de még nincs kész.</p>
<p>Ha a PR el lett fogadva<!--, a feature branch-re nincs már tovább szükség. Le lehet törölni és--> be kell zárni azt az <em>issue-t</em> is, amihez a branch kapcsolódott. Tehát ideálisan minden (nem user-story és kérdés) issue-hoz készül(t) egy branch.</p>
<h3 id="forking"><a class="header" href="#forking">Forking</a></h3>
<p>A tárgyhoz nem lesz szükség forkok használatára, de a GitHub workflow szerves részét képezi (különösen nyílt forrású projekteknél) így érdemes lehet ismerni.</p>
<ul>
<li><a href="https://www.pluralsight.com/blog/software-development/the-definitive-guide-to-forks-and-branches-in-git">The Definitive Guide to Forks and Branches in Git</a></li>
<li><a href="https://www.atlassian.com/blog/git/git-branching-and-forking-in-the-enterprise-why-fork">Git branching and forking in the enterprise: why fork?</a></li>
<li><a href="https://blog.scottlowe.org/2015/01/27/using-fork-branch-git-workflow/">Using the Fork-and-Branch Git Workflow</a></li>
<li><a href="https://stackoverflow.com/a/34343080/4737417">Stackoverflow / Forking vs. Branching in GitHub</a></li>
</ul>
<h2 id="review-2"><a class="header" href="#review-2">Review</a></h2>
<p><img src="images/review_required.png" alt="review required" /></p>
<p>Erre az „add your review” szolgál. Fájlonként át lehet nézni minden módosítást, soronként kommentelni, illetve egy globális véleményt írni a PR-ről (+1, -1, -2). A comment opció semleges, nem elfogadás, de nem is elutasítás. A másik két opció elég egyértelmű. Ha változtatást kérsz, akkor addig amíg a PR forrásbranche nem módosul nem lehet újra próbálkozni a PR elfogadásával.</p>
<p><img src="images/review_approved.png" alt="review" /></p>
<p>Ha minden rendben, akkor el lehet fogadni a PR-et:</p>
<p><img src="images/mergable.png" alt="" /></p>
<p>Elfogadás után így néz ki:</p>
<p><img src="images/merged.png" alt="" /></p>
<!--
Ezen a ponton a feature branch nem szükséges továbbá, törölhető. Persze egy ideig még visszaállítható:

![](images/restore_branch.png)
-->
<h2 id="társszerzők"><a class="header" href="#társszerzők">Társszerzők</a></h2>
<p>A munkafolyamat alapvetően egyéni munkára van kitalálva, de legkevésbé sem tilos a <a href="https://en.wikipedia.org/wiki/Pair_programming">pair programming</a> sem. Volt, hogy Skype-os képernyő-megosztásos módszerrel dolgoztak <em>távolról</em> párban... Ilyenkor mindig felvetődik a kérdés, hogy csak az egyik kolléga nevében történhet a commit de mi van a másikkal... A GitHub-nak <a href="https://github.com/blog/2496-commit-together-with-co-authors">van egy funkciója</a> ennek orvoslására. Részletek <a href="https://help.github.com/articles/creating-a-commit-with-multiple-authors/">elérhetőek itt</a>.</p>
<p>Ebben az esetben a commit üzenet törzse után 2 üres sorral elválasztva kell a társszerzőket feltüntetni. Pl.:</p>
<pre><code>Commit message header

Commit message body preceded by an empty line and followed by
two empty lines and the trailer.


Co-authored-by: name &lt;name@example.com&gt;
Co-authored-by: another-name &lt;another-name@example.com&gt;"
</code></pre>
<p>Ahhoz, hogy a GitHub a társszerzőt össze is tudja rendelni a felhasználói fiókjával fontos, hogy az a <code>name</code> és különösen az az <code>e-mail</code> szerepeljen, amelyet egyébként git beállításként használ!</p>
<h3 id="e-mail-cím-védelme"><a class="header" href="#e-mail-cím-védelme">E-mail cím védelme</a></h3>
<p>A GH minden felhasználónak biztosít egy "proxy ímélcímet", hogy titokban tarthassa a címét, ez xxxxxxx+username@users.noreply.github.com szerkezetű, ahogy xxxxxxx egy hétjegyű felhasználói azonosító. Bővebben <a href="https://docs.github.com/en/github/setting-up-and-managing-your-github-user-account/setting-your-commit-email-address#about-commit-email-addresses">itt</a>. Ezt is lehet használni, nem csak társszerzőhöz hanem saját címnek is, csak legyen konzisztens!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fejlesztői-eszközök"><a class="header" href="#fejlesztői-eszközök">Fejlesztői eszközök</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="visual-studio-code"><a class="header" href="#visual-studio-code">Visual Studio Code</a></h1>
<p>Csak a hivatalos Microsoft féle build hajlandó együttműködni a .NET debuggerrel!</p>
<h2 id="editorconfig-for-vs-code"><a class="header" href="#editorconfig-for-vs-code">EditorConfig for VS Code</a></h2>
<blockquote>
<p>This plugin attempts to override user/workspace settings with settings found in .editorconfig files.</p>
</blockquote>
<p>A formázási beállításokhoz a <a href="https://docs.microsoft.com/en-us/visualstudio/ide/editorconfig-code-style-settings-reference?view=vs-2019">MS ajánlása szerinti</a> .editorconfig fájl hozzáadásra került a projekthez.</p>
<h2 id="c"><a class="header" href="#c">C#</a></h2>
<blockquote>
<ul>
<li>Lightweight development tools for .NET Core.</li>
<li>Great C# editing support, including Syntax Highlighting, IntelliSense,Go to Definition, Find All References, etc.</li>
<li>Debugging support for .NET Core (CoreCLR).
<ul>
<li>NOTE: Mono debugging is not supported. Desktop CLR debugging has limited support.</li>
</ul>
</li>
<li>Support for project.json and csproj projects on Windows, macOS and Linux.</li>
</ul>
</blockquote>
<h2 id="auto-using-for-c"><a class="header" href="#auto-using-for-c">Auto-Using for C#</a></h2>
<blockquote>
<p>Auto-imports and provides intellisense for references that were not yet imported in a C# file.</p>
</blockquote>
<h2 id="automatikus-kódformázás"><a class="header" href="#automatikus-kódformázás">Automatikus kódformázás</a></h2>
<p><a href="https://stackoverflow.com/questions/49500433/auto-format-c-sharp-code-in-visual-studio-code">StackOverflow://Auto format C# code In Visual Studio Code</a></p>
<h2 id="net-core-test"><a class="header" href="#net-core-test">.NET Core Test</a></h2>
<p>Unit test támogatás <em>MSTest</em>, <em>xUnit</em> és <em>NUnit</em> keretrendszerekhez.</p>
<p>Ajánlott beállítások, amiket a <code>.vscode/settings.json</code> fájlban kell elhelyezni:</p>
<pre><code class="language-json">{
    "dotnet-test-explorer.testProjectPath": "**/*Tests.csproj",
    "dotnet-test-explorer.autoWatch": true
}
</code></pre>
<!-- C# FixFormat -->
<h2 id="code-coverage"><a class="header" href="#code-coverage">Code Coverage</a></h2>
<p>A tesztlefedettség számítását a <a href="https://www.nuget.org/packages/coverlet.collector/">Coverlet</a> végzi, amit a teszt projekthez adtam hozzá. Ennek riportját használja a Codecov is.
A riportot cobertura, lcov fomátumban is legeneráltatom, előbbi a Codcov-nak, utóbbi a <a href="https://marketplace.visualstudio.com/items?itemName=ryanluker.vscode-coverage-gutters">Coverage Gutters</a>-nak kell, amely a VS Code-on belül ad visszajelzéseket. Utóbbi beállításaiban meg kell adni, hogy a report <code>coverage.info</code> néven áll elő, ezt keresse. Illetve be kell kapcsolni a <em>statusbar</em> „Watch” gombjábal.</p>
<p>Formátumbeállítás <code>runsettings.xml</code> állományon keresztül [<a href="https://github.com/coverlet-coverage/coverlet/blob/master/Documentation/VSTestIntegration.md">forrás</a>]:</p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;RunSettings&gt;
  &lt;DataCollectionRunSettings&gt;
    &lt;DataCollectors&gt;
      &lt;DataCollector friendlyName="XPlat code coverage"&gt;
        &lt;Configuration&gt;
          &lt;Format&gt;lcov,cobertura&lt;/Format&gt;
        &lt;/Configuration&gt;
      &lt;/DataCollector&gt;
    &lt;/DataCollectors&gt;
  &lt;/DataCollectionRunSettings&gt;
&lt;/RunSettings&gt;
</code></pre>
<p><img src="images/coverage_gutters.png" alt="" /></p>
<!-- ## Code Style -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="intellij-rider---c"><a class="header" href="#intellij-rider---c">IntelliJ Rider - C#</a></h1>
<p>Egyetemi e-mail címmel (<code>stud.uni-obuda.hu</code>) igényelhető egy éves hallgatói licenc az IntelliJ termékekhez, így használható a C# fejlesztéshez szánt <a href="https://www.jetbrains.com/rider/">Rider</a> is.</p>
<h2 id="code-style"><a class="header" href="#code-style">Code Style</a></h2>
<p>https://www.nuget.org/packages/StyleCop.Analyzers/</p>
<h2 id="save-actions-reborn"><a class="header" href="#save-actions-reborn">Save Actions Reborn</a></h2>
<p>Ezzel automatizálni lehet a Reformat Code meghívásást.</p>
<h2 id="code-coverage-1"><a class="header" href="#code-coverage-1">Code Coverage</a></h2>
<ul>
<li><a href="https://www.jetbrains.com/dotcover/">dotCover</a></li>
<li>része a Ridernek</li>
<li>aktiválás: Unit Tests fül, Run (zöld háromszög) rejtett menü / Cover Selected Unit Tests</li>
</ul>
<p><img src="images/dotcover.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="intellij-idea---java"><a class="header" href="#intellij-idea---java">IntelliJ IDEA - Java</a></h1>
<!-- toc -->
<p>A feladat Java nyelvű megoldásához ajánlott és támogatott fejlesztői környezet az <a href="https://www.jetbrains.com/idea/#chooseYourEdition">IntelliJ IDEA</a>. A Community Edition ingyenes, ez tartalmaz mindent amire szükség lehet a félév során.Egyetemi e-mail címmel elvileg ingyen igényelhető Pro verzió.</p>
<h2 id="kódformázás"><a class="header" href="#kódformázás">Kódformázás</a></h2>
<p>IDEA beállításai alapértelmezetten elvileg megfelelnek az elvárásoknak, így egy fájl befejezése után (de értelem szerűen commit előtt) célszerű egy formázást megejteni: Code &gt; Reformat Code (CTRL+ALT+L)</p>
<ul>
<li>A behúzás beállítása: File &gt; Settings &gt; Editor &gt; Code Style &gt; Java &gt; Tabs and Indents: nem tab, de 4 karakternyi</li>
<li>A sorhossz beállítása: File &gt; Settings &gt; Editor &gt; Code Style &gt; Default Options &gt; Right magin (columns) 120 kell, hogy legyen eredetileg</li>
<li>Emellett default beállításokban a vessző és kettőspont utáni szóközök, illetve az operátorokat körbevevő szóközök is szerepelnek. Továbbá a kapcsos zárójelek használata is az elvártnak megfelelően van beállítva.</li>
</ul>
<p><a href="java_style_guide.html">Java kódformázási előírások</a></p>
<h2 id="save-actions"><a class="header" href="#save-actions">Save actions</a></h2>
<p>Mivel a <em>Reformat Code</em> nyomogatását az ember hajlamos elfelejteni, létezik egy IDEA bővítmény a probléma automatizálására. Ez nem más mint a <a href="https://plugins.jetbrains.com/plugin/7642-save-actions">Save Actions plugin</a>, mely lehetővé teszi, hogy az amúgy is használt <strong>mentés</strong> (CTRL+S) parancshoz lehessen kötni a kódformázási műveletet.
A <em>Save Actions</em> plugin konfigurálását az alábbiak szerint kell megejteni.
<img src="https://user-images.githubusercontent.com/3854784/37599751-c35c06c6-2b85-11e8-8018-a8a07c1c1aa7.png" alt="idea_save_action" /></p>
<p>Zárójeles megjegyzés, hogy ez akkor fog tisztességesen működni, ha az IDEA kódformázási előírásai megfelelően vannak beállítva, vagy legrosszabb esetben default-on lett hagyva minden (már akkor is képes megszüntetni a Checkstyle-ben rögzített problémák jelentős részét).</p>
<p><a href="https://stackoverflow.com/a/28748557/4737417"><em>forrás</em></a></p>
<h2 id="checkstyle-plugin"><a class="header" href="#checkstyle-plugin">Checkstyle plugin</a></h2>
<p>A Checkstyle egy statikus kódelemző szoftver Java nyelvhez, amely egyrészt a kódformázási előírások betartását, másrészt egyéb programozástechnikai előírások betartását is ellenőrzi.</p>
<p><a href="https://plugins.jetbrains.com/plugin/1065-checkstyle-idea">Checkstyle plugin</a> beállítása IntelliJ IDEA környezetbe. A plugin telepíthető a plugin managerből majd a következő beállításokra van szükség:</p>
<p>File &gt; Settings &gt; Other Settings &gt; Checkstyle &gt; Configuration File panelen <em>Add</em> és a projekt gyökérben megtalálható <code>checkstyle.xml</code> fájlt kell neki megadni (és elnevezni valamiként, az alábbi képen <code>szfmv</code>). Innentől a fejlesztői környezeten belül elérhető a kódminőség-ellenőrzés <em>valós időben</em>, warning-okkal jelzi a találatokat.</p>
<p><img src="images/idea_checkstyle_plugin_settings.png" alt="" />
<img src="images/idea_checkstyle_findings.png" alt="" /></p>
<h2 id="tesztlefedettség-1"><a class="header" href="#tesztlefedettség-1">Tesztlefedettség</a></h2>
<p>A kód „minőség” egy mérőszáma lehet, hogy mekkora része van (unit)tesztekkel lefedve. Ezt a projekt README-ben a <a href="https://coveralls.io/github/SzFMV2017-Tavasz/AutomatedCar?branch=master">Coveralls.io</a> szolgáltatás folyamatosan meg is jeleníti.</p>
<p>Ehhez a <a href="http://www.eclemma.org/jacoco/">JaCoCo</a>-t használjuk, ami Maven-en keresztül (a <code>pom.xml</code>-ben) lett beállítva. A kód tesztekkel történő lefedettségének megjelenítéséhez a fejlesztői környezetek mindenféle okos eszközöket is rendelkezésre bocsátanak.</p>
<p>Az IntelliJ IDEA-ban beépített megoldás is van, illetve olyan külső eszközöket is képes használni mint a JaCoCo. Képes arra, hogy színkódokkal megfesse az egyes metódusokat annak megfelelően, hogy van-e hozzá teszt.</p>
<p>A <a href="https://www.jetbrains.com/help/idea/2016.3/code-coverage.html">beállításához</a> meg kell nyitni a <a href="https://www.jetbrains.com/help/idea/2016.3/creating-and-editing-run-debug-configurations.html">Run/debug configuration</a> ablakot, majd a <em>Code Coverage</em> fülön kiválasztani az IntelliJ IDEA-t vagy a JaCoCo-t, előbbi Tracing típusú vizsgálatot is tud (ami jelenleg mindegy). Ezután a <em>Run</em> menü <em>Run 'Main' with Coverage</em> menüpontjával a kódot úgy futtatja, hogy a számításokat el is végzi és megjeleníti az összesítő panelt.</p>
<p>Az IDEA-n kívül más IDE-khez is megtalálhatóak hasonló funkciók: <a href="http://wiki.netbeans.org/MavenCodeCoverage">NetBeans</a>, <a href="http://www.eclemma.org/jacoco/">Eclipse</a></p>
<h3 id="képernyőképek"><a class="header" href="#képernyőképek">Képernyőképek</a></h3>
<p><img src="images/idea_run_debug_config_menu.png" alt="" />
<img src="images/idea_run_debug_config_window.png" alt="" />
<img src="images/idea_coverage_window.png" alt="" /></p>
<h2 id="logolás---log4j"><a class="header" href="#logolás---log4j">Logolás - Log4J</a></h2>
<p>Módfelett udvariatlan, káros és így kerülendő hibakeresési céllal a standard kimenetre (<code>System.out.println</code>) írni. Ettől még sokan megteszik mondván addig nincs baj, míg nem kerül pusholásra a közös repóba. Csakhogy a kódolás hevében könnyen ott felejthet az ember egy-két ilyet, így célszerű eleve bele sem tenni!</p>
<p>Szerencsére több logger is létezik, amik nem csak a <code>System.out.println</code> nem rendeltetés szerű használatát tudják megakadályozni, de bónuszként még egy halom hasznos és kényelmes funkcióval is rendelkeznek. A projektben az <a href="https://logging.apache.org/log4j/2.x/">Apache log4j 2.8</a>-as verziója került bevezetésre.</p>
<h2 id="konfigurálás"><a class="header" href="#konfigurálás">Konfigurálás</a></h2>
<p>A logolási beállítások egyrészt helyzetfüggőek, másrészt a fejlesztő magánügyét képezik, így nem kényszerítjük rá a másikra a kedvenc beállításainkat. Ebből következik, hogy a <code>log4j2.xml</code> konfigurációs állomány nincs a <em>git</em> verziókezelő felügyelete alatt. Példa a tartalmára [<a href="http://stackoverflow.com/a/21206994/4737417">forrás</a>]:</p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;Configuration status="INFO"&gt;
    &lt;Appenders&gt;
        &lt;Console name="Console" target="SYSTEM_OUT"&gt;
            &lt;PatternLayout pattern="%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n" /&gt;
        &lt;/Console&gt;
        &lt;!--&lt;File name="MyFile" fileName="all.log" immediateFlush="true" append="false"&gt;--&gt;
            &lt;!--&lt;PatternLayout pattern="%d{yyy-MM-dd HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n"/&gt;--&gt;
        &lt;!--&lt;/File&gt;--&gt;
    &lt;/Appenders&gt;
    &lt;Loggers&gt;
        &lt;Root level="debug"&gt;
            &lt;AppenderRef ref="Console" /&gt;
            &lt;!--&lt;AppenderRef ref="MyFile"/&gt;--&gt;
        &lt;/Root&gt;
    &lt;/Loggers&gt;
&lt;/Configuration&gt;
</code></pre>
<p>A fenti fájlt a projektmappába pl. a <code>src/main/resources/</code>-be kell elhelyezni. Jelenlegi beállításokkal <strong>DEBUG</strong> szintű, fájlba nem ment, csupán a fejlesztői környezet konzoljára ír. A fenti fájl hiányában <strong>ERROR</strong> beállításokkal fog működni.</p>
<h3 id="szintek"><a class="header" href="#szintek">Szintek</a></h3>
<p>A logolásnak több szintje van attól függően, hogy milyen finomságú részletekre vagyunk kíváncsiak. Ezek a szintek sorban (a legbővebbtől a legszűkebbig): ALL, TRACE, DEBUG, INFO, WARN, ERROR, FATAL, OFF. Ebből következik, hogy egy <em>INFO</em> szintű log üzenet meg fog jelenni <em>DEBUG</em> beállítások mellett, de nem fog megjelenni <em>ERROR</em> beállításokkal.</p>
<h3 id="példa-a-használatára"><a class="header" href="#példa-a-használatára">Példa a használatára</a></h3>
<pre><code class="language-java">package hu.oe.nik.automatedcar.demo;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

public class Demo {
  private static final Logger LOGGER = LogManager.getLogger();

  public void demo(){
    LOGGER.debug("Ez egy debug szintű üzenet");
    LOGGER.error("Ez egy error szintű üzenet");
  }
}
</code></pre>
<h3 id="további-leírás"><a class="header" href="#további-leírás">További leírás</a></h3>
<ul>
<li><a href="http://howtodoinjava.com/log4j2/log4j-2-xml-configuration-example/">Log4j2 xml configuration example</a></li>
</ul>
<h2 id="maven-és-a-proxy"><a class="header" href="#maven-és-a-proxy">Maven és a proxy</a></h2>
<p>Ha valaki céges gépen dolgozik előírt proxy mellett, érdemes figyelni arra, hogy <a href="https://maven.apache.org/guides/mini/guide-proxies.html">a maven-nek külön kell konfigurálni a proxy-t</a>.</p>
<h2 id="függőségeket-tartalmazó-futtatható-jar-állomány-létrehozása"><a class="header" href="#függőségeket-tartalmazó-futtatható-jar-állomány-létrehozása">Függőségeket tartalmazó futtatható <code>.jar</code> állomány létrehozása</a></h2>
<pre><code>mvn clean compile assembly:single
</code></pre>
<p>Az eredmény a <code>target/AutomatedCar-jar-with-dependencies.jar</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kódformázás-1"><a class="header" href="#kódformázás-1">Kódformázás</a></h1>
<p><img src="https://www.explainxkcd.com/wiki/images/c/c6/code_quality.png" alt="Code quality" /></p>
<p>A kód tisztasága, olvashatósága nem csak szemantikai, de szintaktikai értelemben is fontos. Minden nyelvnek megvannak a maga „nyelvtani”, szintaktikai előírásai, amit a fordító be is tartat. Azonban ezen túl megvannak azok az (íratlan) szabályai is, amiket már nem a fordító feladata betartatni. (A Go fordítónál ez kezd egybemosódni, pl. nem fordul a kód ha van deklarált, de fel nem használt változód, a <a href="https://golang.org/cmd/gofmt/">gofmt, Go format</a> pedig kikényszeríti a kódformázási szabályokat.)</p>
<p>Ezek olyan kódformázási szabályok, amelyek több szinten lehetnek definiálva. Egyrészt (többé-kevésbé) egyezményesen egy-egy nyelv szintjén (pl. <a href="https://www.python.org/dev/peps/pep-0008/">PEP8</a> Python esetében, gofmt), aztán lehetnek vállalati esetleg osztály és projekt szinten is.
Például a <a href="https://01.org/linuxgraphics/gfx-docs/drm/process/coding-style.html">Linux kernelkez tartozó előírások</a> - többek között - 8 szóköznyi behúzást írnak elő és maximum 80 karakter széles sorokat. A gondolat emögött, hogy maximum három blokk mélységű szerkezet fogadható el, amikor is már a sor 30%-át teszi ki a behúzás. Ennél több behúzás esetén már nem sok hely marad a kódnak.</p>
<p>A Java nyelvhez is van(nak) kódformázási előírás(ok), amelyek egy része teljesen általános. Pl. a csomagnevek kisbetűsek, az osztály nevek mindig nagybetűvel kezdődnek (a fejlesztői környezetek ezt például általánosan számon kérik), a metódusnevek pedig kis betűvel kezdődnek továbbá a szóösszetételeknél nagybetűket használunk pl. <code>metódusNév</code>.</p>
<p>Átfogó ajánlást készített még 2000 környékén a Sun, ám ez mára meglehetősen túlhaladott, vagy ilyen a Google által összeállított <a href="https://google.github.io/styleguide/javaguide.html">Google Java Style Guide</a>.
Ez viszont helyenként túl specifikus (nagyvállalati környezetre optimalizált) a tárgy kereteihez, így nem egy az egyben ezt használjuk. A <a href="http://checkstyle.sourceforge.net/">Checkstyle</a> statikus kódanalizátor default értékei vagy a Jetbrains által az IntelliJ IDEA-ba beállított default szabályok is felfoghatók egy ilyen ajánlásnak.</p>
<p>A C#-hoz a Microsoft definiálta a <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/inside-a-program/coding-conventions">kódformázási szabályokat</a>, ezeket kell követni a tárgy során is.</p>
<h1 id="statikus-program-analízis"><a class="header" href="#statikus-program-analízis">Statikus program analízis</a></h1>
<p>A statikus analízis során a programkód végrehajtása nélkül, többnyire a forráskód elemzésével - automatizáltan - történik kód hibáinak feltárása.[<a href="https://en.wikipedia.org/wiki/Static_program_analysis">Wikipédia</a>]
Ilyen eszköz Java nyelvhez például a nyílt forrású <a href="https://pmd.github.io/">PMD</a>, vagy a <a href="http://checkstyle.sourceforge.net/">Checkstyle</a>.</p>
<p>A kurzus során az utóbbit használjuk, amely figyeli a fentebb leírt formázási ajánlásokat (<a href="http://checkstyle.sourceforge.net/checks.html">teljes használható szabálylista</a>). Ezen túlmenőleg egyéb hibafaktorokat is figyel: magic number-ek alkalmazása, string literál többszöri előfordulása, <a href="https://en.wikipedia.org/wiki/Cyclomatic_complexity">Ciklomatikus komplexitás</a>, túl sok paraméter a metódusban (5), túl hosszú metódus (20 utasítás), túl hosszú sor (120 karakter) valamint a kódban felejtett <code>TODO</code> és <code>FIXME</code> kommentekre is érzékeny.</p>
<p>A master repók (<a href="https://github.com/SzFMV2018-Osz/AutomatedCar-A">A</a> és <a href="https://github.com/SzFMV2018-Osz/AutomatedCar-B">B</a>) össze lett drótozva a <a href="https://www.codefactor.io">CodaFactorral</a> és folyamatosan méri a kód minőségét, valamint egy A-tól F-ig tartó skálán <a href="https://support.codefactor.io/i14-glossary">osztályozza</a> is (ahol az A a legjobb).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kódformázási-előírások-c-nyelvhez"><a class="header" href="#kódformázási-előírások-c-nyelvhez">Kódformázási előírások C# nyelvhez</a></h1>
<p>Work in progress...</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kódformázási-előírások-java-nyelvhez"><a class="header" href="#kódformázási-előírások-java-nyelvhez">Kódformázási előírások Java nyelvhez</a></h1>
<p>„Örök kérdés”, hogy szóközök vagy tabok jelöljék-e a behúzást. Ma már minden normális editor beállítható úgyis, hogy a tab billentyű szóközöket szúrjon be, amelyik erre (sem) képest azt meg nem használjuk. A kérdés, legalábbis ezen tárgy keretein belül azzal zárult, hogy <em>mindenki</em> szóközöket használ, tabok nem lehetnek a fájlban. Pont.
Egy rövid (nem túl komoly) videó a témában: <a href="https://youtu.be/SsoOG6ZeyUI">Silicon Valley - S03E06</a></p>
<ul>
<li>a behúzást 4 szóköz jelöli (nincs tab a fájlban)</li>
<li>nem lehetnek üres blokkok</li>
<li>a nyitó kapcsos zárójel a sor végén található</li>
</ul>
<pre><code class="language-java">if (condition) {
    ...
}
</code></pre>
<ul>
<li>a záró kapcsos zárójel kulcsszavakkal azonos sorba helyezendő</li>
</ul>
<pre><code class="language-java">try {
    ...
} catch (Exception ex) {
    ...
} finally {
    ...
}
</code></pre>
<ul>
<li>minden esetben ki kell tenni a blokkjelölő kapcsos zárójeleket</li>
<li>osztályon belül meghatározott sorrendben szerepelnek az elemek
<ol>
<li>Class (static) variables. First the public class variables, then protected, then package level (no access modifier), and then private.</li>
<li>Instance variables. First the public class variables, then protected, then package level (no access modifier), and then private.</li>
<li>Constructors</li>
<li>Methods</li>
</ol>
</li>
<li>kerülendő az üres utasítás (<code>;</code>)</li>
<li>mindig szükséges default ág a swith-case szerkezetben</li>
<li>soronként egy utasítás szerepel</li>
<li>kerülendő a <code>return</code> kulcsszavak halmozása egy metóduson belül</li>
<li>kerülendőek a *-os importálások</li>
<li>kerülendő a nem használt importálás</li>
<li>az osztály neve megegyezik a fájl nevével</li>
<li>az operátorok körül, valamint a vessző és kettőspont után szóköz kerül</li>
</ul>
<h2 id="kulcsszó-sorrend"><a class="header" href="#kulcsszó-sorrend">Kulcsszó sorrend</a></h2>
<p>A Javában a metódusok különböző módosítókkal láthatók el mint <code>static</code>, <code>public|private|protected</code>, <code>final</code> ám ezeknek előírt sorrendje is van. Nem a fordító írja elő sajnos, tehát lefordul, de konvenció, hogy ezeket milyen sorrendbe tesszük. Pl. a teljesség igénye nélkül  <code>public static</code> oké <code>static public</code> nem.
Sajnos a <em>Reformat Code</em> ezt nem rázza gatyába, így az automatizált megoldás sem fogja, de ettől még stílus hiba.</p>
<p>Javítani lehet a helyzeten a File | Settings | Editor | Inspections | Java | Code style issues | Missorted modifiers inspection bepipálásával <strong>ÉS</strong> az Analyze | Code Cleanup <em>commit előtti</em> alkalmazásával. Sajnálatos módon a Save Actions ezt nem tudja. :sob:</p>
<p><a href="https://stackoverflow.com/a/31203757/4737417"><em>forrás</em></a></p>
<h2 id="javadoc"><a class="header" href="#javadoc">Javadoc</a></h2>
<blockquote>
<p>Javadoc is a tool which comes with JDK and it is used for generating Java code documentation in HTML format from Java source code, which requires documentation in a predefined format.</p>
<p><a href="https://www.tutorialspoint.com/java/java_documentation.htm">tutorialspoint / Java - Documentation Comments</a></p>
</blockquote>
<p>Tutorials:</p>
<ul>
<li><a href="https://www.tutorialspoint.com/java/java_documentation.htm">tutorialspoint</a></li>
<li><a href="https://www.baeldung.com/javadoc">baeldung.com/javadoc</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="munkafolyamat"><a class="header" href="#munkafolyamat">Munkafolyamat</a></h1>
<p>Definiáltunk egy munkafolyamatot, amely követése elvárás a félév során.
A munkafolyamat alapvetően feltételezi, hogy egy adott kódrészletet egy kolléga ír, de legkevésbé sem tilos a <a href="https://en.wikipedia.org/wiki/Pair_programming">pair programming</a> sem. Ahhoz, hogy a GitHub rögzítse a mindkét kollégát, a társszerzőt meg kell jelölni. Erről <a href="git.html#t%C3%A1rsszerz%C5%91k">itt lehet olvasni</a>.</p>
<p>A konkrét feladatmegoldáshoz az alábbi folyamat az elvárt:</p>
<p><img src="images/proc1.png" alt="" /></p>
<ul>
<li>User Story:
<ul>
<li>high level description of sprint goal by customer not complete! Never detailed enough!</li>
</ul>
</li>
<li>Component Design:
<ul>
<li>what will realize the functions in the user story You have to recognize the (hidden?) functionality!</li>
</ul>
</li>
<li>Requirement Specification:
<ul>
<li>what makes the component work as expected basically the Definition of Done for the component</li>
</ul>
</li>
<li>Task Definition:
<ul>
<li>add milestone (there is one for every sprint) to issue</li>
<li>add assignee to issue</li>
<li>add Definition of Done list to issue</li>
<li>add project (there is one for every team) to issue</li>
<li><a href="https://www.humanizingwork.com/the-humanizing-work-guide-to-splitting-user-stories/">Guide to Splitting User Stories</a></li>
</ul>
</li>
</ul>
<p><img src="images/proc2.png" alt="" /></p>
<ul>
<li>Dod: Definition of Done</li>
</ul>
<h2 id="code-review-in-details"><a class="header" href="#code-review-in-details">Code Review in details</a></h2>
<p><img src="images/proc3.png" alt="" /></p>
<ul>
<li>Clean Code:
<ul>
<li>no magic numbers</li>
<li>no abbreviations</li>
<li>no extreme unit lengths</li>
<li>talkative names</li>
<li>unambiguous code</li>
</ul>
</li>
<li>in short:
<ul>
<li>Easy to understand and maintain</li>
<li>Reads like well written prose</li>
</ul>
</li>
</ul>
<h2 id="commit-üzenetek-1"><a class="header" href="#commit-üzenetek-1">Commit üzenetek</a></h2>
<p>A <a href="https://chris.beams.io/posts/git-commit/">How to Write a Git Commit Message</a> egy hosszabb, példákkal illusztrált írás a jó commit üzenetekről, amely <a href="https://chris.beams.io/posts/git-commit/#seven-rules">hét szabályban</a> foglalja össze, hogy mire kell figyelni. Ezt egészíteném ki egy nyolcadikkal.</p>
<ol>
<li><a href="https://chris.beams.io/posts/git-commit/#separate">Separate subject from body with a blank line</a></li>
<li><a href="https://chris.beams.io/posts/git-commit/#limit-50">Limit the subject line to 50 characters</a></li>
<li><a href="https://chris.beams.io/posts/git-commit/#capitalize">Capitalize the subject line</a></li>
<li><a href="https://chris.beams.io/posts/git-commit/#end">Do not end the subject line with a period</a></li>
<li><a href="https://chris.beams.io/posts/git-commit/#imperative">Use the imperative mood in the subject line</a></li>
<li><a href="https://chris.beams.io/posts/git-commit/#wrap-72">Wrap the body at 72 characters</a>
<ul>
<li>ez a legkevésbé fontos</li>
</ul>
</li>
<li><a href="https://chris.beams.io/posts/git-commit/#why-not-how">Use the body to explain what and why vs. how</a></li>
<li><strong>Reference the issue!</strong></li>
</ol>
<h3 id="miért-fontos-a-8-pont-1"><a class="header" href="#miért-fontos-a-8-pont-1">Miért fontos a 8. pont?</a></h3>
<p>Valójában (bizonyos szempontból) az issue behivatkozása a legfontosabb, méghozzá a <strong>visszakövethetőség</strong> (traceability) miatt.</p>
<p><img src="../images/traceability_via_commit.png" alt="" /></p>
<p>Minden módosítás (a verziókövető rendszerben) rendelkezik egy azonosítóval, amelyhez társul, hogy ki és mikor végezte el a módosítást. Valamit egy üzenet, amely -- jó esetben -- leírja, hogy mi volt ez a módosítás. A visszakövethetőség egy adott szintig tehát szerves része a verziókövető rendszereknek.</p>
<p>A módosítások azonban nem csak úgy ötletszerűen történnek, hanem valamilyen feladat által meghatározott célból. Pl. jelenítsd meg a műszerfalon az autó pillanatnyi sebességét (feature), vagy javítsd ki pixel/s -&gt; km/h átváltást, mert kerekítési hiba miatt értelmetlen érték jelenik meg (bugfix).</p>
<p>Ugyanakkor a feladatok (task) sem csak úgy lógnak a levegőben, jellemzően kapcsolódnak egy user story-hoz (különösen a feature-ök), de biztosan kapcsolódnak egy sprinthez (hiszen beütemezték a megoldását valamikorra), van felelősük, határidejük, stb. Úgy általában van véve egy kontextusuk. Az issue (más néven task) tartalmazza az adott feladat pontos részleteit, az issue/task trackerben akár a megoldás teljes vitafolyamata megtalálható. Pl. ki hogyan akarta implementálni, milyen érvek és ellenérvek merültek fel az egyes implementációs lehetőségek mellett/ellen, hogyan jutott a fejlesztőcsapat konszenzusra, vagy ki hagyta jóvá az adott módosítást, ki döntött arról, hogy melyik sprintbe kerüljön be, stb.</p>
<p>A visszakövethetőség nem csak addig a pontig érdekes és fontos, hogy ki írta át a változó típusát (pl.), hanem a teljes tervezési/döntés folyamatig visszamenőleg.</p>
<p>Mi van akkor ha a döntés egy face-to-face meetingen (pl. standup), skype konferenciahíváson vagy egyéb nem írásos formában történt?
(A szó elszáll, írás megmarad...)</p>
<p>Ebben az esetben, az issue kiváló hely arra, hogy írásban is rögzítve legyenek az elhangzottak. Pl. YYYY-MM-DD-ei megbeszélés alapján az XY library segítségével fogom implementálni az analóg fordulatszámkijelzőt. Akár explicit írásos jóváhagyást is lehet kérni...</p>
<h1 id="vállalati-példa"><a class="header" href="#vállalati-példa">Vállalati példa</a></h1>
<p>A munkakultúráról egy remek videót tett közzé a Spotify, <a href="https://labs.spotify.com/2014/03/27/spotify-engineering-culture-part-1/">megtekinthető itt</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="implementáció"><a class="header" href="#implementáció">Implementáció</a></h1>
<!-- toc -->
<h2 id="c-1"><a class="header" href="#c-1">C#</a></h2>
<p>A korábbi félévek visszajelzései visszatérő eleme volt, hogy C#-ban is meg lehessen oldani a feladatot. A cross-plastform fejlesztés ugyanúgy feltétel, így „csak” a <a href="https://dotnet.microsoft.com/download/dotnet-core">.NET Core</a> jöhet szóba, ennek is a 3.1-es verziója (LTS).</p>
<p>A .NET 5 egyesíti majd a .NET Framework-öt és a .NET Core-t, majd a .NET 6 be fogja vezetni a MAUI-t mint multiplatform keretrendszert grafikus felületek készítéséhez, ez azonban ma még <a href="https://devblogs.microsoft.com/dotnet/introducing-net-multi-platform-app-ui/">nem elérhető</a>.</p>
<p>Mivel a CI környezet Linux alapon futott, szükség volt egy áthidaló megoldásra miután a WPF nem használható Windows-on kívül, erre a <em>3rd party</em> <a href="http://avaloniaui.net/">Avalonia</a> keretrendszert használtuk. Az Avalonia a WPF-hez hasonlóan egy XAML alapú Model-View-ViewModel (MVVM) rendszer.
Viszont miután már a GitHub Actions ingyenes opció mellett is lehetővé teszi a Windows alapú CI környezetek használatát, a WPF is használható lett.</p>
<p><img src="images/dotnet_stack.png" alt=".NET stack" /></p>
<p>Használható fejlesztői környezetek: Visual Studio, VS Code (kizárólag a hivatalos, MS változattal működik együtt a .NET debugger), IntelliJ Rider, stb.</p>
<p>Hasznos írások az implementációhoz:</p>
<ul>
<li>Útvonalkövetés: <a href="https://en.wikipedia.org/wiki/A*_search_algorithm">A* algoritmus</a>
<ul>
<li>implementáció: LINQ to A* <a href="https://github.com/rvhuang/linq-to-astar">GitHub</a>, <a href="https://www.nuget.org/packages/linq-to-astar/">NuGet</a></li>
</ul>
</li>
</ul>
<h2 id="java"><a class="header" href="#java">Java</a></h2>
<p>A feladat megoldásához Java nyelvet, annak is a 11-es verzióját kell használni (LTS), <a href="https://maven.apache.org/guides/getting-started/index.html">Maven</a> projekt menedzsment eszközzel. (A kiinduló projekt ezeket már teljesíti). Egyaránt használható az <a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk11-downloads-5066655.html">Oracle JDK 11</a> vagy az <a href="http://openjdk.java.net/projects/jdk/11/">OpenJDK 11</a> is, operációs rendszer sincs megszabva.
Az automatizált CI eszközök jogi okokból az OpenJDK-t használják, linuxon. Szóval már csak emiatt is „érdemes” platformfüggetlen kódot írni!</p>
<p>A kiadott kód csak példa egy alap GUI készítésére Swing-el, ez akár teljesen átírható, más GUI könyvtárak (pl. JavaFx) is használható.
Viszont az IntelliJ IDEA GUI Designer-e <em>nem</em> használható, esetleges kompatiblitási okoból.</p>
<p>Hasznos írások az implementációhoz:</p>
<ul>
<li><a href="https://gamedev.stackexchange.com/questions/56017/java-best-implementation-keylistener-for-games">Billentyű/input kezelés</a></li>
<li><a href="https://web.archive.org/web/20190403012130/https://gafferongames.com/post/fix_your_timestep/">Időzítés</a></li>
<li><a href="https://docs.oracle.com/javase/tutorial/extra/fullscreen/doublebuf.html">Villódzásmentes rajzolás</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="virtuális-világ"><a class="header" href="#virtuális-világ">Virtuális világ</a></h1>
<p>Az autónak egy virtuális tesztpályán kell végigmennie, amelyhez modellezni a világot. Két teszt pályát biztosítunk, egy egyszerűbbet és egy nagyobbat, bonyolultabbat. Alább látható az egyszerűbb.</p>
<p><img src="images/test_world.png" alt="" /></p>
<p>A fenti világ elemekből épül föl, amelyek között vannak egyenes útszakaszok, kanyarok (pl. 45° és 90°), T elágazás, gyalogos átkelő, közúti táblák, parkolók és fák. Mindezt <a href="resources/test_world.xml">egy XML</a>, vagy <a href="resources/test_world.json">egy JSON</a> írja le. A feladat megoldásához bármelyik formátum használható.</p>
<p>A számítógépes grafikában megszokott módon, a bal felső sarok jelenti az origót (0,0) koordinátát. Az x tengely tehát jobbra haladva, az y tengely lefelé haladva növekszik. Így kell értelmezni az XML-t és ekképpen működik a megjelenítés is, hiszen a form bal felső sarkánál van a (0, 0) pont. Az alábbi kép <a href="http://www.e-cartouche.ch/content_reg/cartouche/graphics/en/html/Screen_learningObject3.html">forrása</a>.</p>
<p><img src="http://www.e-cartouche.ch/content_reg/cartouche/graphics/en/image/coordinates.jpg" alt="" /></p>
<h2 id="objektumok-leírása"><a class="header" href="#objektumok-leírása">Objektumok leírása</a></h2>
<p>Egy-egy objektum leírása a következőképpen néz ki (XML-ben):</p>
<pre><code class="language-xml">&lt;Object type="road_2lane_straight"&gt;
      &lt;Position x="1700" y="144"/&gt;
      &lt;Transform m11="0" m12="1" m21="-1" m22="0"/&gt;
      &lt;Parameter name="roadpainting_1" value="1"/&gt;
      &lt;Parameter name="roadpainting_2" value="1"/&gt;
      &lt;Parameter name="roadpainting_3" value="1"/&gt;
&lt;/Object&gt;
</code></pre>
<ul>
<li>A <code>type</code> attribútum írja le, hogy milyen objektumról van szó. A példában egy 2 sávos egyenes útszakaszról.</li>
<li>A <code>Position</code> elem megadja az elem viszonyítási pontjának koordinátáját.</li>
<li>A <code>Transform</code> elem egy 2×2-es transzformációs mátrix, amely forgatást ír le.</li>
<li>A <code>roadpainting</code> megadná, hogy milyen felfestések vannak vannak az úton, de ez nem releváns</li>
<li>Egy ilyen egyenes útelem 350×350px, ekkora a kép is és ennek kell lennie az XML-ben is.</li>
</ul>
<h2 id="az-út-elemek-viszonyítási-pontjai"><a class="header" href="#az-út-elemek-viszonyítási-pontjai">Az út elemek viszonyítási pontjai</a></h2>
<p>A képfájlok amikkel a rajzoló csapat dolgozik elég sajátosan működnek. A transzformációs mátrixban leírt elforgatás pl. nem a bal felső sarokkal van értelmezve, hanem elemenként más és más ponttal. Ezek rögzítése szükséges lehet a modellben, a rajzoló csapat munkáját megkönnyítendő. Egyébként korábbi félévekben ezt már összeszedték <a href="resources/reference_points.xml">egzakt módon is</a>.</p>
<p><img src="images/90right.png" alt="" /> <img src="images/90left.png" alt="" /></p>
<p><img src="images/45right.png" alt="" /> <img src="images/45left.png" alt="" /></p>
<p><img src="images/6right.png" alt="" /> <img src="images/6left.png" alt="" /></p>
<p><img src="images/tjunctionright.png" alt="" />
<img src="images/tjunctionleft.png" alt="" /></p>
<p><img src="images/straight.png" alt="" />
<img src="images/rotary.png" alt="" /></p>
<p><img src="images/2_crossroad_1.png" alt="2_crossroad_1" />
<img src="images/2_crossroad_2.png" alt="2_crossroad_2" /></p>
<p>Minden itt fel nem sorolt esetben feltételezhető, hogy a bal felső sarok a viszonyítási pont.</p>
<p>Egy korábbi félév során a referenciapontokat (részben) már összegyűjtötték (@csabalint, @SiposGergo, @markkurucz), ez elérhető <a href="resources/reference_points.xml">XML</a> vagy <a href="resources/reference_points.json">JSON</a> formátumban.</p>
<p>A mozgatásra szoruló elemek (vezérelt autó és NPC autók) nem képezik részét a világ leírásának, viszonyítási pontjuk nem definiált. A rendelkezésre bocsátott autó képek méretarányosak az összes többi objektummal.</p>
<p>A világhoz szükséges elemek megtalálhatóak a kiinduló project <code>src/main/resources</code> (Java) vagy <code>src/AutomatedCat/Assets</code> (C#) mappájában.</p>
<h2 id="objektum-poligonok"><a class="header" href="#objektum-poligonok">Objektum poligonok</a></h2>
<p>Minden objektumnak kell, hogy legyen egy poligon váza, amely többek között az ütközéshez vagy a kijelüléshez is használható. Különböző objektumoknak azonban kicsit mást jelent ez a poligon „váz”.</p>
<p>Az autó esetében (pl.) a legfontosabb felhasználása az, hogy nekiment-e valaminek, tehát az autó körvonalát kell megjelölni. Ez leegyszerűsíthető, nem kell a grafikai elemet teljes mértékben követni.</p>
<p><img src="images/car_simplified_polygon_model.png" alt="" /></p>
<p>Egyes elemek (fa, tábla) a felülnézet miatt nem azt mutatják, ami az ütközéshez szükséges. Értelem szerűen nem a lombkoronának, hanem a törzsnek lehet nekiütközni. Tehát egy törzset kell ábrázolni a poligonnal.</p>
<p><img src="images/tree_polygon.png" alt="" /></p>
<p>Az útelemek esetében nem az ütközés a probléma, hanem a sávokat kell kijelölni, amit a a sávtartó automatika fog felhasználni. Ezeket is lehet egyszerűsíteni.</p>
<p><img src="images/90left_polygon.png" alt="" /></p>
<p>A poligonok megrajzolásához használható a <a href="https://www.robots.ox.ac.uk/~vgg/software/via/">VGG Image Annotator</a>, amely <a href="https://www.robots.ox.ac.uk/~vgg/software/via/via.html">böngészőből is működik</a> és a megrajzolt polygont JSON-ben le lehet menteni.</p>
<p>Korábbi félév során @ArchiCat és @konyarilaszlo ezt már megtette, elérhető a <a href="resources/worldobject_polygons.json">worldobject_polygons.json</a> állományban.</p>
<p>Ennek struktúrája:</p>
<pre><code class="language-json">{
    "objects": [
        {
            "typename": "car_1_white",
            "polys": [
            {
                "type": "standalone",
                "points": [
                [51, 239],
                [40, 238],
                [26, 236],
                ...
                [51, 239]
                ]
            }
            ]
        },
        ...
    ]
}
</code></pre>
<p>Van benne egy objects tömb, minden objektum esetében a <code>typename</code> a képfájl neve (kiterjesztés nélkül), majd egy polygon tömb (mivel a <a href="https://www.robots.ox.ac.uk/~vgg/software/via/">VGG Image Annotator</a> multipoligonokat is elő tud állítani). Azon belül egy <code>points</code> tömb ahol a koordináták a képfájlon koordinátarendszerében értendők.</p>
<p><img src="images/polygon_relative_coordinates.png" alt="" /></p>
<p>A fenti példa esetében a képfájl (50, 20) koordinátára van rajzolva, a hatszög benne a képen belüli relatív koordinátákkal van megadva.</p>
<pre><code class="language-json">"points": [
    [10, 10],
    [15, 8],
    [20, 10],
    [20, 20],
    [15, 22],
    [10, 20],
    [10, 10]
]
</code></pre>
<h2 id="méretarány"><a class="header" href="#méretarány">Méretarány</a></h2>
<p>Az XML-ben leírt objektumok koordináta-rendszere nem feltétlenül egyezik meg a megjelenítő koordináta-rendszerével, ezt figyelembe véve skálázás, vagy viewport kezelés válhat szükségessé.</p>
<p>A feladat megoldás során jellemzően valóságos mértékegységekben specifikáljuk a feladatot (pl. méter, km/h, m/s^2, stb.) míg az XML és a grafikai elemek értelem szerűen pixellel dolgoznak. Ennek feloldására, illetve az átváltásra az <strong>1m=50px</strong> szabályt célszerű használni. Ez egy hozzávetőlegesen arányos érték, amellyel számolni is könnyű.</p>
<!--## Sávtartó automatika tesztelése

A sávtartó automatika nem tesztelhető kanyarokban, ehhez ezért egy alább látható kinézetű pályaszakasz készült. Csak 6°-os és egyenes útszakaszból áll. [Az XML elérhető itt](resources/lane_keeping_test_world.xml).

![](images/lka_track.png)
--><div style="break-before: page; page-break-before: always;"></div><h1 id="az-autó-fizikája"><a class="header" href="#az-autó-fizikája">Az autó fizikája</a></h1>
<p>Az autónak egy leegyszerűsített modellen keresztül ugyan, de mégis valóságosan kell viselkednie, ehhez pedig megfelelő fizikát kell leprogramozni. Az haladásához nyilván <em>sebességre</em> lesz szükség, amit a <em>motorerő</em> gyorsító ereje segítségével kaphatunk, és ami a gázpedál(t helyettesítő billentyű) elengedésével <em>nem szűnik meg azonnal</em>, tehát ha úgy tetszik lendületben marad, viszont a környezet (légellenállás, súrlódás) fokozatosan <em>fékezi</em> (akár egyetlen lassító erő is elegendő). Nem kell az egész univerzumot szimulálni, de legalább egy gyorsító és egy fékező erő például biztosan szükséges lesz.</p>
<p>Ezen jelenségeket (és még sok minden mást) egy autós játék fizikájáról Marco Monster szépen összefoglalta <a href="http://www.asawicki.info/Mirror/Car%20Physics%20for%20Games/Car%20Physics%20for%20Games.html">Car Physics for Games</a> című írásában (angol nyelven).</p>
<p>Az autóhoz <a href="https://auto.howstuffworks.com/automatic-transmission.htm">automata váltót</a> kell megvalósítani, de az automata vátóban is vannak „belső” fokozatok (1, 2, 3, 4 stb. előremenetben), tehát meg kell különböztetni a „külső” fokozatokat (P, R, N, D) és D állapotban a belsőket.</p>
<p>Szintén hasznosak lehetnek még az alábbi írások, természetesen továbbra is angol nyelven, vagy tetszőleges egyéb irodalom (hint: Google, Stackoverflow, Wikipedia).</p>
<ul>
<li><a href="http://www.iforce2d.net/b2dtut/top-down-car">Box2D C++ tutorials - Top-down car physics</a></li>
<li><a href="https://www.gamedev.net/forums/topic/470497-2d-car-physics-tutorial/">2D Car Physics Tutorial </a></li>
<li><a href="https://engineeringdotnet.blogspot.com/2010/04/simple-2d-car-physics-in-games.html">Simple 2D car steering physics in games</a></li>
</ul>
<h2 id="fordulókör-kiszámítása"><a class="header" href="#fordulókör-kiszámítása">Fordulókör kiszámítása</a></h2>
<p><a href="http://gamedev.stackexchange.com/questions/50022/typical-maximum-steering-angle-of-a-real-car">Typical Maximum steering angle of a real car</a></p>
<p><img src="https://i.stack.imgur.com/DQsP9.png" alt="" /></p>
<p>A fordulókör sugarának kiszámításához a fönti linkből származó képlet használható:</p>
<blockquote>
<p>atan(wheelbase / (turning circle - car width)) = angle</p>
</blockquote>
<p>A <a href="resources/car_2_white.png"><code>car_2_white.png</code></a> esetében a szélesség kb. 90px, a tengelytáv kb. 130px-nek tekinthető. Tegyük fel, hogy maximum 60°-ban kormányozható, ekkor a fordulókör sugara:</p>
<blockquote>
<ul>
<li>
<p>atan(130px / (r - 90px)) = 60°</p>
</li>
<li>
<p>tan(60) = 130/(r-90)</p>
</li>
<li>
<p>r = 130/tan(60) + 90</p>
</li>
<li>
<p>r = ~165px</p>
</li>
</ul>
</blockquote>
<p><strong>Figyelem, ezek lényegesen valósághűbb autó szimulálását tűzték ki célul mint ami itt minimálisan elvárt!</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="szenzorok"><a class="header" href="#szenzorok">Szenzorok</a></h1>
<!-- toc -->
<p>A vezetéstámogató rendszerek 3 fő szenzorra épülnek: kamera, radar és ultrahang. A valóságban adott esetben a vezetéstámogató rendszerek több szenzor együttes használatával működnek (a szoftverben ilyet nem kell megvalósítani).</p>
<p>A jegyzetben szereplő ábrák a szenzorok látóterét nem méretarányosan mutatják mivel a radar és a kamera látótere túl nagy, így az igazán lényeges részletek elvesznének.</p>
<p>További olvasmány:</p>
<ul>
<li><a href="http://www.eetimes.com/document.asp?doc_id=1272754">Driver Assistance Systems, an introduction to Adaptive Cruise Control</a></li>
<li><a href="https://autonomous-driving.org/2019/01/25/positioning-sensors-for-autonomous-vehicles/">Sensor Set Design Patterns for Autonomous Vehicles</a></li>
</ul>
<h2 id="kamera"><a class="header" href="#kamera">Kamera</a></h2>
<p>A kamera a szélvédő mögött található, 60°-os látószöggel 80 méterre lát el. A <a href="functions.html#t%C3%A1blafelismer%C5%91-traffic-sign-recognition---tsr">táblafelismerő rendszer</a> és a <a href="functions.html#s%C3%A1vtart%C3%B3-automatika-lane-keeping-assistant---lka">sávtartó automatika</a> használja.</p>
<p><img src="images/camera.png" alt="Kamera szenzor látótere, nem méretarányos" title="Kamera szenzor látótere, nem méretarányos" /></p>
<h2 id="radar"><a class="header" href="#radar">Radar</a></h2>
<p>A radar az autó lökhárítóján helyezkedik el, 60°-os látószöggel 200 méterre lát el. Az <a href="functions.html#adapt%C3%ADv-tempomat-adaptive-cruise-control---acc">adaptív tempomat</a> és az <a href="functions.html#auton%C3%B3m-v%C3%A9szf%C3%A9kez%C5%91-rendszer-automatic-emergency-brake---aeb">autonóm vészfékező rendszer</a> épül rá.</p>
<p><img src="images/radar.png" alt="Radai szenzor látótere, nem méretarányos" title="Radai szenzor látótere, nem méretarányos" /></p>
<p>A valóságban a radar több járművet is azonosít. A azonos sávban közvetlenül előtte haladót, a szomszédos sávokban haladó autókat és a képes az azonos sávban haladó előttit is azonosítani (az autó alatt átverődő jelekkel). Ennek köszönhetően az olyan potenciálisan veszélyes manőverek mint a szomszéd sávból elénk bevágó autó is felismerhető mivel folyamatosan figyeli ezek helyzetét.</p>
<p><img src="images/radar_lanes.png" alt="" /></p>
<h2 id="ultrahang"><a class="header" href="#ultrahang">Ultrahang</a></h2>
<p>Az ultrahang szenzorból 8 darab van az autón, látótávolsága 3 méter, látószöge 100°, a <a href="functions.html#parkol%C3%B3-asszisztens-parking-pilot---pp">parkoló asszisztens</a> és a <a href="functions.html#tolat%C3%B3radar">tolatóradar</a> épül rá.</p>
<p><img src="images/ultrasonic.png" alt="Ultrahang szenzorok látóterei" title="Ultrahang szenzorok látóterei" /></p>
<h1 id="szenzorimplementáció-működése"><a class="header" href="#szenzorimplementáció-működése">Szenzorimplementáció működése</a></h1>
<p>A valóságos szenzorokhoz képest az implemtálandó szenzorok jelentősen egyszerűbbek. Értelem szerűen nem kell sem radar, sem ultrahang jeleket szimulálni és a szenzorok látóterét is jelentősen egyszerűsítve reprezentáljuk: egy háromszöggel.</p>
<p><img src="images/sensor_dataflow.png" alt="" /></p>
<p>A szenzor látóterét jelképező háromszög a vezérelt autóhoz van rögzítve, vele együtt mozog. Ez az a háromszög amely kijelöli a világ egy szeletét és elérhetővé teszi a szenzornak feldolgozásra. Maga a világ (World osztály) singleton, pontosan egy létezik belőle amelyhez bármely szenzor közvetlenül hozzáfér.</p>
<p>A világ tartalmaz egy WorldObject objektumokból álló gyűjteményt, amelyben minden statikus és dinamikus objektum megtalálható, beleértve a vezérelt autót is.</p>
<p>Az első sprint során a modellező csapat implementál egy lekérdező metódust, amely egy háromszöget (vagy 3 pontot) vár bemenetként és visszadja azon világ objektumok listáját, amelyek beleesnek ebbe a háromszögbe.</p>
<p>Ha a szenzor háromszög ugyanolyan poligonnal van megvalósítva mint a világobjektumok poligonjai, akkor az <code>intersects</code> metódussal könynen eldöntehető, hogy a szenzor látóterének háromszövgébe tartozik-e egy-egy világ objektum.</p>
<p><img src="images/sensor_dataflow_2.png" alt="" /></p>
<p>A szenzorok ez a listát tovább szűrik az alapján, hogy mire érzékenyek. A kamerára a sávtartóautomatika (LKA) és a táblafelismerő (TSR) épül, így annak a szenzornak az útelemek és a táblák relevánsak.</p>
<p>A radar és az ultrahang olyan objektumokra érzékeny, amelynek neki lehet menni, amivel az egocar ütközhet. Ezen kívül a radarra épülő ACC a vezérelt autó előtt (sávon belül) haladó autóra fókuszál, a vészfékező (AEB) bármire ami az egocar útjába esik. Az ultrahang szenzor szintén, csupán az rövidebb távon és a Parking Pilot használja.</p>
<p>Miután a szenzorokhoz konkrét objektum referenciák kerülnek, a szenzor hozzáfér az objektum minden tulajdonságához. Így akár könnyedén lehet számítani távolságot két objektum között (a referenciapontok segítségével).</p>
<p><img src="images/sensor_dataflow_3.png" alt="" /></p>
<p>A szenzorok a feldolgozásuk eredményét a <em>Virtual Function Bus</em>-ra írják <em>packet</em> objektumok segítségével. Aztán ezeket a megfelelő modulok kiolvassák és hasznosítják. Pl. a műszerfalon megjelenik a táblafelismerő által detektált tábla, vagy az AEB által generált vezérlésre a hajtáslánc modul fékezéssel reagál.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vezetéstámogató-funkciók"><a class="header" href="#vezetéstámogató-funkciók">Vezetéstámogató funkciók</a></h1>
<h2 id="adaptív-tempomat-adaptive-cruise-control---acc"><a class="header" href="#adaptív-tempomat-adaptive-cruise-control---acc">Adaptív tempomat (Adaptive Cruise Control - ACC)</a></h2>
<blockquote>
<p>Az adaptív sebességtartó automatika a hagyományos tempomat továbbfejlesztett változata. Az ACC egy rendkívül precíz radarral, valamint a gázadás és a fékezés elektronikus vezérlésével tartja az előre beállított követési távolságot. Ha a két jármű között csökken a távolság, az ACC mérsékli a sebességet, sőt szükség esetén fékez is, közben pedig aktiválja a féklámpákat. Ha az elöl haladó jármű gyorsít, vagy átsorol a másik sávba, az Ön autója is fokozatosan felgyorsít, amíg el nem éri az előre beállított sebességet. Az adaptív sebességtartó automatikával a kívánt követési távolságot is beállíthatja (hosszú, közepes vagy rövid).</p>
<p>forrás: <a href="https://www.toyota.hu/world-of-toyota/safety/adaptive-cruise-control-how-it-works.json">toyota.hu / Adaptív sebességtartó automatika</a></p>
</blockquote>
<h3 id="bemutatóvideó-youtube"><a class="header" href="#bemutatóvideó-youtube">Bemutatóvideó (YouTube)</a></h3>
<p><a href="https://www.youtube.com/watch?v=own_VaRZ9M8"><img src="https://img.youtube.com/vi/own_VaRZ9M8/0.jpg" alt="Bemutatóvideó" /></a></p>
<h3 id="implementálás"><a class="header" href="#implementálás">Implementálás</a></h3>
<p>A kiválasztott célobjektum (autó előtt haladó NPC) sebességéhez igazítja a saját sebességet, vagy tartja a sofőr által kiválasztott sebességhatárt, ha nincs előtte célobjektum.</p>
<ul>
<li>ki- és bekapcsolható, reagál az állapotváltás, alapértelmezetten az aktuális sebesség, de min célsebesség 30 km/h</li>
<li>ha nincs saját sávban autó, a játékos autó tartja a kiválasztott célsebességet</li>
<li>ha saját sávban található autó:
<ul>
<li>felveszi a sebességét, ha lassabb</li>
<li>tartja a kiválasztott sebességet, ha gyorsabb</li>
</ul>
</li>
<li>fékezésre kikapcsol</li>
<li>AEB beavatkozásra kikapcsol</li>
<li>ha speed limitet talál a buszon (táblafelismerő), azt alkalmazza új célsebességként, amíg a sofőr felül nem írja</li>
</ul>
<p><img src="images/acc.png" alt="" /></p>
<h3 id="kezelőszervek"><a class="header" href="#kezelőszervek">Kezelőszervek</a></h3>
<ul>
<li>bekapcsoló gomb</li>
<li>célsebesség kijelölése
<ul>
<li>léptetés 10 km/h-val</li>
<li>30 és 160 km/h között</li>
</ul>
</li>
<li>követési távolság definiálása másodpercben: 0.8, 1.0, 1.2, 1.4
<ul>
<li>sebességfüggő</li>
<li>a léptetés körbe jár, tehát 1.4 után 0.8 következik és a 0.8 után az 1.4</li>
</ul>
</li>
</ul>
<h2 id="autonóm-vészfékező-rendszer-automatic-emergency-brake---aeb"><a class="header" href="#autonóm-vészfékező-rendszer-automatic-emergency-brake---aeb">Autonóm vészfékező rendszer (Automatic Emergency Brake - AEB)</a></h2>
<blockquote>
<p>Az Autonóm Vészfékező Rendszer (AEB) lényege, hogy egy beépített technológia alkalmazásával (általában radar, kamera, vagy lézer segítségével) folyamatosan méri az elöl haladó jármű mögötti távolságot. Ha a rendszer úgy érzi, hogy a gépkocsik közötti távolság veszélyesen csökken, akkor jelzést ad a járművezetőnek, lehetőséget adva a beavatkozásra (pl. fékezésre). Amennyiben a járművezető reakciója elmarad, vagy annak mértékét a rendszer nem tartja elégségesnek, abban az esetben az AEB beavatkozik, s akár vészfékezés alkalmazásával igyekszik a balesetet elkerülni.</p>
<p>forrás: <a href="http://www.baleset-megelozes.eu/cikk.php?id=1032">baleset-megelozes.eu / Autonóm Vészfékező Rendszer (AEB)</a></p>
</blockquote>
<h3 id="bemutatóvideó-youtube-1"><a class="header" href="#bemutatóvideó-youtube-1">Bemutatóvideó (YouTube)</a></h3>
<p><a href="https://www.youtube.com/watch?v=VHR8AeZrlVc"><img src="https://img.youtube.com/vi/VHR8AeZrlVc/0.jpg" alt="Bemutatóvideó" /></a></p>
<h3 id="implementálás-1"><a class="header" href="#implementálás-1">Implementálás</a></h3>
<p>Nyilvánvalóan nem azt kell vizsgálni, hogy az autó ütközik-e az előtte levő objektummal hanem, hogy <em>ütközni fog-e vele</em>. A vészfékezés maximális lassulása 9 m/s^2 lehet. Ha az autó 36 m/s sebességgel halad akkor 4 másodperc kell a nullára fékezéshez (ha 50 km/h sebességgel halad, akkor 20). Az aktuális sebességből meghatározható, hogy mekkora a fékút, a maximális megengedett lassulás mellett. Az is kiszámolható, hogy ez mennyi időt vesz igénybe, így az is, hogy mikor kell elkezdeni a vészfékezést, hogy a gyalogost ne üssük el.</p>
<p>A radar szenzor elég messzire ellát, egy nem mozgó objektum (pl. fa) esetében egyszerű meghatározni, hogy lesz-e ütközés és el kell-e kezdeni vészfékezni. Mozgó objektum (gyalogos) esetében azt is figyelembe kell venni, hogy mire odaérünk még az úton lesz-e.</p>
<ul>
<li>elkerülhető ütközés esetén vizuális figyelmeztetés a sofőrnek</li>
<li>70 km/h felett figyelmeztetés, hogy az AEB nem tud minden helyzetet kezelni</li>
<li>ha a sofőr nem avatkozik közbe, automatikus fékezés (az utolsó pillanatban, ahol az ütközés még elkerülhető)</li>
<li>az automatikus fékezés mértéke a sebességgel arányos, de nem lehet 9 m/s^2-nél nagyobb</li>
<li>gyalogos, fa esetén megáll az autó</li>
<li>nincs nem releváns objektumokra való fékezés (fals pozitív) - pl. szembejövő autó</li>
</ul>
<p><img src="images/radar_aeb.png" alt="" /></p>
<h2 id="parkoló-asszisztens-parking-pilot---pp"><a class="header" href="#parkoló-asszisztens-parking-pilot---pp">Parkoló asszisztens (Parking Pilot - PP)</a></h2>
<p>A rendszert az erre szolgáló vezérlővel aktiválni kell, majd az irányjelzővel kijelölni, hogy jobbra, vagy balra keressük a parkolóhelyet. Ezután ahogy az autó <em>vezetői irányítás mellett</em> végiggurul a parkoló mellett, a rendszer detektálja az üres parkolóhelyet. Ekkor hátramenetbe kapcsolva az PP vezetői beavatkozás nélkül beáll a szabad pozícióba.</p>
<h3 id="bemutatóvideók-youtube"><a class="header" href="#bemutatóvideók-youtube">Bemutatóvideók (YouTube)</a></h3>
<ul>
<li><a href="https://www.youtube.com/watch?v=HWMzP9HYNCQ"><img src="https://img.youtube.com/vi/HWMzP9HYNCQ/0.jpg" alt="Bemutatóvideó" /></a></li>
<li><a href="https://www.youtube.com/watch?v=rYPby2ALLnE"><img src="https://img.youtube.com/vi/rYPby2ALLnE/0.jpg" alt="Bemutatóvideó" /></a></li>
</ul>
<h3 id="implementálás-2"><a class="header" href="#implementálás-2">Implementálás</a></h3>
<ul>
<li>a parkolás megkezdése külön inputhoz kötött</li>
<li>a kormány és gáz/fék vezérlésével beparkolás a talált helyre
<ul>
<li>a tolatási manőver lehet egy előre definiált szekvencia, amelyet a parkolóhely (abszolút) pozíciójával lehet paraméterezni</li>
</ul>
</li>
<li>ha a PP aktív és a váltó hátramenetben van (és van detektált parkolóhely), akkor parkolási szekvencia végrehajtása</li>
<li>a párhuzamos parkolás akkor sikeres, ha ütközés nélkül megtörténik</li>
<li>a sofőr beavatkozására (fék, gáz, kormány) kikapcsolás (megszűnik az automata vezérlés)</li>
</ul>
<ol>
<li>parkolóhely keresése
<ul>
<li><img src="images/find_parking_place_horizontal.png" alt="" /></li>
<li>Az üres hely detektálása lényegébe egy állapotátmenet az első és a hátsó ultrahang szenzor „van-e akadály” visszajelzésében. Amíg egy kocsisor mellett halad az autó mindkét szenzor „van akadály” jelzéssel tér vissza (ez valójában nem <code>boolean</code> állapot, egy objektum listát ad vissza), az üres hely kezdetén a az első „nincs akadály” állapotba megy át (a lista üres), majd ahogy az autó halad tovább a hátsó szenzor is „nincs akadály” állapotba kerül.</li>
<li>A szabad terület végén ugyanez fordítva játszódik le.</li>
<li>Azonban a parkoló autó objektumot adja vissza a szenzor,a melynek ismert a kiterjedése és a referencia pontja, így a játékszoftverben pontosan „látszik” a foglalt terület. Ahogy az egocar elhalad a parkoló autók mellett mindkét autó által lefoglalt terület pontosan ismert így kiszámítható a közöttük meglevő szabad terület.</li>
</ul>
</li>
<li>Parkolóhely azonosítva
<ul>
<li><img src="images/parking_place_found_horizontal.png" alt="" /></li>
<li>Miután sikerült meghatározni a szabad parkolóhely méretét, ezt valamiylen formában le kell írni. Célszerűen az egocar referenciapontjáthoz viszonyítva, hogy milyen távol vagyunk tőle, valamint a méretét/hosszát. Lehet egy téglalappal is reprezentálni ahogy az ábrán is látszik.</li>
</ul>
</li>
<li>Automatikus parkolás
<ul>
<li><img src="images/parking_horizontal.png" alt="" /></li>
<li>A parkolási manőver tökéletes megoldása, hogy a <em>Parking Pilot</em> az autó kezelőszerveire hat. Eltekeri a kormányt, gázt ad, fékez, nem csak úgy módosítgatja az autó koordinátáit és elforgatását. (Mindez precízen szabályozható hajtáslánc és kormánymechanika implementációt igényel.)</li>
</ul>
</li>
</ol>
<hr />
<p>Parkolás manőver leírása nagy vonalakban <a href="https://www.dmv.ca.gov/portal/dmv/detail/pubs/hdbk/parking">forrás</a>:</p>
<ol>
<li>Bring your car to a stop alongside the car at the front of the space.
<ul>
<li><img src="https://www.dmv.ca.gov/imageserver/dmv/images/dlhdbk/perfect1.jpg" alt="" /></li>
</ul>
</li>
<li>Reverse into the space with an S motion.
<ul>
<li><img src="https://www.dmv.ca.gov/imageserver/dmv/images/dlhdbk/perfect2.jpg" alt="" /></li>
</ul>
</li>
<li>Once the car is parallel with the curb, pull forward to center your car within the space.
<ul>
<li><img src="https://www.dmv.ca.gov/imageserver/dmv/images/dlhdbk/perfect3.jpg" alt="" /></li>
</ul>
</li>
</ol>
<h3 id="kezelőszervek-1"><a class="header" href="#kezelőszervek-1">Kezelőszervek</a></h3>
<ul>
<li>aktiválás billentyűzettel</li>
<li>az irányjelzővel jelölhető ki keresési oldal</li>
</ul>
<h2 id="sávtartó-automatika-lane-keeping-assistant---lka"><a class="header" href="#sávtartó-automatika-lane-keeping-assistant---lka">Sávtartó automatika (Lane Keeping Assistant - LKA)</a></h2>
<h3 id="bemutatóvideó-youtube-2"><a class="header" href="#bemutatóvideó-youtube-2">Bemutatóvideó (YouTube)</a></h3>
<p><a href="https://www.youtube.com/watch?v=GdtVe1Pnayg"><img src="https://img.youtube.com/vi/GdtVe1Pnayg/0.jpg" alt="Bemutatóvideó" /></a></p>
<h3 id="implementálás-3"><a class="header" href="#implementálás-3">Implementálás</a></h3>
<p>Két jellemző megvalósítása van. Az egyik a sáv széleihez viszonyítva korrigál: ha az autó elérné a sáv szélét, akkor ellenkormányoz. A másik megoldás kiszámolja a sáv közepét és azon tartja az autót.</p>
<ul>
<li>45 foknál enyhébb kanyarodású úton a kocsi a sáv szemmel látható közepén marad</li>
<li>ha el kell engednie a kontrollt (az automatika számára kezelhetetlen forgalmi szituáció következik, pl. éles kanyar, kereszteződés), vizuális figyelmeztetést ad
Ha újra elérhető a funkció (pl. elhagytuk a kanyart) vizuális indikáció (a műszerfalon)
Be- és kikapcsolható</li>
</ul>
<h4 id="1-sáv-széleinek-használata-2"><a class="header" href="#1-sáv-széleinek-használata-2">1. Sáv széleinek használata</a></h4>
<p><img src="images/lka_a.png" alt="" /></p>
<h4 id="2-sávközép-használata-2"><a class="header" href="#2-sávközép-használata-2">2. Sávközép használata</a></h4>
<p><img src="images/lka_b.png" alt="" /></p>
<p>Sávon belüli mozgás: a LKA működése egy enyhe sávon belüli cikázást eredményez.</p>
<p><img src="images/lka_wave.png" alt="" /></p>
<h3 id="kezelőszervek-2"><a class="header" href="#kezelőszervek-2">Kezelőszervek</a></h3>
<ul>
<li>aktiválás a műszerfalról (vagy billentyűzettel)</li>
</ul>
<h2 id="táblafelismerő-traffic-sign-recognition---tsr"><a class="header" href="#táblafelismerő-traffic-sign-recognition---tsr">Táblafelismerő (Traffic Sign Recognition - TSR)</a></h2>
<p>A kamera látóterébe eső és az autó számára releváns (ellentétes irányba közlekedők számára szólóakat nem) közlekedési táblákat fel kell ismerni és a legutolsó relevánsat megjeleníteni a műszerfalon. Ha ez sebességkorlátozás, akkor azt a buszra kiírni (az ACC használja).</p>
<h3 id="bemutatóvideó-youtube-3"><a class="header" href="#bemutatóvideó-youtube-3">Bemutatóvideó (YouTube)</a></h3>
<p><a href="https://www.youtube.com/watch?v=RFuUvqxbuSc"><img src="https://img.youtube.com/vi/RFuUvqxbuSc/0.jpg" alt="Bemutatóvideó" /></a></p>
<h3 id="implementálás-4"><a class="header" href="#implementálás-4">Implementálás</a></h3>
<ul>
<li>a táblát addig kell megjeleníteni, amíg újabb nem talál a rendszer</li>
<li>a sebesség limit mindaddig érvényes, míg feloldásra vagy felülbírálásra nem kerül</li>
<li>nem releváns táblák nem kerülhetnek azonosításra
<ul>
<li>mindenek előtt az út bal oldalán levők</li>
</ul>
</li>
<li>a kamera látótere elég nagy, a kanyaroknál kialakuló helyzetet is kezelni kell</li>
</ul>
<p><img src="images/tsr.png" alt="" /></p>
<h2 id="tolatóradar"><a class="header" href="#tolatóradar">Tolatóradar</a></h2>
<p>A hátsó ultrahang szenzorokat használja akadály detektálásra. Kiszámolja az akadály távolságát és annak megfelelően figyelmeztető jelzést ad a vezetőnek, megkönnyítve a manuális parkolást, tolatást.</p>
<h3 id="bemutatóvideó-youtube-4"><a class="header" href="#bemutatóvideó-youtube-4">Bemutatóvideó (YouTube)</a></h3>
<p><a href="https://www.youtube.com/watch?v=qZkCoDChS4A"><img src="https://img.youtube.com/vi/qZkCoDChS4A/0.jpg" alt="Bemutatóvideó" /></a></p>
<h3 id="implementálás-5"><a class="header" href="#implementálás-5">Implementálás</a></h3>
<ul>
<li>csak hátramenetben aktív</li>
<li>figyelmeztetés megjelenítése a műszerfalon</li>
<li>távolság megjelenítése a műszerfalon</li>
<li>a buszon keresztül történik a modulok (tolatóradar és műszerfal) kommunikáció</li>
<li>a kijelzés 3 fokozatban történik
<ul>
<li>nincs akadály</li>
<li>közel van akadály (0.8m-en belül)</li>
<li>nagyon közel van akadály (0.4m-en belül)</li>
</ul>
</li>
</ul>
<p><img src="images/reverse_radar_system_horizontal.png" alt="" /></p>
<!--
# „Fun” kategória

* [Hyundai - The Empty Car Convoy](https://www.youtube.com/watch?v=Xbjdmw8D9-Y)
    - LKA, ACC and AEB marketing
* [Nissan Parking Pilot inspirálta helyére ”parkoló” papucsa](https://youtu.be/tazFfEP_NcY) -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="referencia-architektúra"><a class="header" href="#referencia-architektúra">Referencia architektúra</a></h1>
<p>A repó található kezdeti kódot (skeleton) egységes alapot képez a félév során megvalósítandó szoftver számára, azonban nem kíván tökéletes és teljes megoldást biztosítani a feladat egyetlen elemére sem, mindösszesen példaként szolgál a következőkre:</p>
<ul>
<li>projekt struktúra</li>
<li>grafikus felület létrehozása
<ul>
<li>WPF keretrendszerrel</li>
<li>Avalonia keretrendszerrel</li>
</ul>
</li>
<li>világmodell benépesítése</li>
<li>vezérelt autó példányosítása és kiválasztása</li>
<li>képfájl betöltése projektkönyvtárból</li>
<li>világobjektumok rajzolása MVVM rendszerben</li>
<li>vezérelt autó állapotának megjelenítése a műszerfalon</li>
<li>ütemező használata</li>
<li>billentyű lenyomás és felengedés esemény kezelése</li>
<li>szenzor objektum létrehozása</li>
<li>adatcsomag küldése és fogadása a <em>Virtual Function Bus</em>-on keresztül</li>
</ul>
<!-- A fejezet további felépítse: -->
<!-- toc -->
<h2 id="Átfogó-kép"><a class="header" href="#Átfogó-kép">Átfogó kép</a></h2>
<p>A teljes szoftver moduljai <a href="sprints.html">12 user story</a>-ra vannak bontva. Az egyes modulok a teljes szoftver egy-egy komponensét valósítják meg. A legtöbb ilyen komponens a vezérelt autón belül kap majd helyet. Azonban vannak olyan komponensek (irányítás és megjelenítés), amelyek  nem csak az autón belül, de azon kívül, a keretszoftverben működnek.</p>
<p><img src="images/full_software.png" alt="" /></p>
<p>A billentyűzet események kezelése értelemszerűen a szoftverban történik, amelyet aztán a szimulált autó kezelőszerveire (gáz- és fékpedál, kormány) kell leképezni.
A megjelenítésnek pedig értelemszerűen a teljes világot, de legalábbis az autó egy környezetét kell, hogy kirajzolnia.</p>
<h2 id="virtual-function-bus"><a class="header" href="#virtual-function-bus">Virtual Function Bus</a></h2>
<p>A VirtualFunctionBus (VFB) egy kommunikációs megoldás az AutomatedCar komponensei (SystemComponent) számára. A komponensek feliratkoznak a buszra és <strong>a feliratkozás sorrendjében</strong> ciklikusan meghívásra kerül a <code>Process()</code> metódusok.</p>
<p>Ebből következik, hogy a feliratkozást az ábrán látható sorrendben kell megtenni, mivel az adatáramlásnak ilyen irányultsága van. Az ábra a kód kezdeti állapotát szemlélteti, a munka során további modulok (szenzorok, vezetés támogató rendszerek) is csatlakoznak majd. Valamint a hajtáslánc és a kormányzás modult nem kötelező ennyire élesen szétválasztani.</p>
<p><img src="plantuml/dummy_sensor_vfb.svg" alt="" /></p>
<p>Minden adatközlő modulnak létre kell hoznia egy-egy csomag (packet) típust (és vele párhuzamosan egy az olvasást biztosító interfészt), amely tartalmazza azokat az információkat amelyeket továbbítania kell. Például az input modul a pedál és kormány állásokat. A hajtáslánc a következő, kiolvassa a pedál és váltó állást, számol vele, majd visszaírja a <em>saját</em> csomagjába motor fordulatszámát és az autó sebességét, stb. Ezekre legközelebb a kormányzás modulnak lesz szüksége, az kiolvassa ugyanúgy mint az input modul kormányállás értékét, számol vele, majd visszaírja a autó adott iterációra vonatkozó elmozdulását.</p>
<h3 id="használata-általánosan"><a class="header" href="#használata-általánosan">Használata általánosan</a></h3>
<ol>
<li>Create a new package (e.g. SteeringAnglePacket)</li>
<li>Create a new interface for it (e.g. IReadonlySteeringAnglePacket)</li>
<li>Add reference to the owner component (e.g. SteeringSystem)</li>
<li>Add the interface reference to the VirtualFunctionBus</li>
<li>In the loop method of the writing componenet set the payload value of the packet</li>
<li>In the loop method of the reading compontent read the payload of the packet</li>
</ol>
<h3 id="konkrét-példán-keresztül-dummysensor"><a class="header" href="#konkrét-példán-keresztül-dummysensor">Konkrét példán keresztül: DummySensor</a></h3>
<p>A <em>DummySensor</em> egy rendkívül primitív „szenzor”: egyetlen feladata, hogy kiszámolja az egocar ás a <em>Circle</em> objektum közötti távolságot. Pontosabban az egocar és a kör referenciapont X, Y koordinátáinak különbségét. Azonban ez is teljes mértékben képes bemutatni a szenzorok működését és a buszon keresztüli adatcserét.</p>
<p>A példa szempontjából releváns komponensek viszonyát alábbi ábra szemlélteti.</p>
<p><img src="plantuml/dummy_sensor_component.svg" alt="" /></p>
<!--
```plantuml
@startuml
component [World] as world {

  component [AutomatedCar] as egocar {
    component [DummySensor] as ds
    component [VirtualFunctionBus] as vfb

    interface register as rc
  }

  component [Circle] {
  }
  
  ds -left-( rc
  vfb -right- rc
 
}

header
DummySensor component diagram
endheader

@enduml
```
-->
<p>A <em>World</em> singleton osztály tartalmaz minden <em>WorldObject</em>-et és tartalmaz referenciát a vezérelt autóra, amely közvetetten szintén <em>WorldObject</em>, csakúgy mint a <em>Circle</em>. Az <em>AutomatedCar</em> tartalmazza a <em>VirtualFunctionBus</em>-t, mivel ez az autó komponenseinek kommunikációs csatornáját valósítja meg. Szintén az <em>AutomatedCar</em> tartalmazza a szenzorokat, jelen esetben a <em>DummySensor</em>-t.</p>
<p>Ahhoz, hogy a szenzorok (vagy egyéb komponensek mint a hajtáslánc például) adatot cserélhessenek fel kell iratkozniuk a VFB-ra. Miután a feliratkozás megtörtént, a VFB minden ciklusában meghívja a <code>Porcess()</code> metódusát. A <em>DummySensor</em> esetében ez a metódus elkéri a világtól a <em>kör</em> objektumot, kiszámolja a vezérelt autó és a kör távolságát, majd ezt a távolságot eltárolja a <em>DummyPacket</em> objektumban (amely egy IReadOnlyDummyPacket típuson keresztül a VFB-ban van tárolva).</p>
<!-- A szenzor része az *AutomatedCar*-nak, közvetlenül hozzáférhet a világhoz (*World*) mivel az singleton. Lekéri a világobjektumok közül a kört (*Circle*), majd kiszámolja a koordináták különbségét a `process()` metódusban és az eredményt eltárolja az `dummyPacket` változóban. -->
<p>A <code>dummyPacket</code> referenciája eltárolásra került a <em>VirtualFunctionBus</em>ban, amely referenciáját a a szenzor konstruktorának biztosítani kell. Ehhez előzetesen létre kell hozni egy <code>IReadOnlyDummyPacket</code> típusú változót a VFB-ban.</p>
<p>Miután a <code>DummyPacket</code> megvalósítja az <code>IReadOnlyDummyPacket</code> interfészt, a VFB-ban az utóbbi típus tárolására szolgáló változó kerül deklarálásra. Ezzel biztosítható, hogy az adott értéket csak a csomag tulajdonosa (jelen esetben a <em>DummySensor</em>) tudja majd írni, de minden más komponens olvashatja a VFB-on keresztül.</p>
<!--
```plantuml
@startuml
DummySensor -> VirtualFunctionBus: registerComponent
loop
    VirtualFunctionBus -> DummySensor: Process
    activate DummySensor
    DummySensor -> World: Get Circle

    DummySensor -> DummySensor: Calculate distance from Circle
    DummySensor -> DummyPacket: Store distance
    deactivate DummySensor
end

header
DummySensor sequence diagram
endheader
@enduml
```
-->
<p><img src="plantuml/dummy_sensor_sequence.svg" alt="" /></p>
<p>Ez lejátszódik minden iterációban, így a kör és a vezérelt autó mindenkori helyzete szerinti távolságot fogja tartalmazni a <em>DummyPacket</em>.</p>
<!-- Az alábbi ábra a *DummySensor* szenpontjából fontos osztályok kapcsolatát mutatja. -->
<h3 id="osztálydiagramok"><a class="header" href="#osztálydiagramok">Osztálydiagramok</a></h3>
<!--
```plantuml
@startuml
abstract class GameBase {
    + int TicksPerSecond
    + long CurrentTick
    - DispatcherTimer _timer

    void DoTick()
    # {abstract} void Tick()
    + void Start()
    + void Stop()
}

class VirtualFunctionBus {
    - SystemComponent[] components
    - IReadOnlyDummyPacket DummyPacket
    + int getIReadOnlyDummyPacket()
    + void setIReadOnlyDummyPacket()
    + void registerComponent(SystemComponent component)
}

abstract class SystemComponent {
    # VirtualFunctionBus virtualFunctionBus
    # SystemComponent(VirtualFunctionBus virtualFunctionBus)
    + {abstract} void Process()
}

class DummySensor {
   - DummyPacket dummyPacket
}

class DummyPacket {
    - int distanceX
    - int distanceY
    + void setDistanceX()
    + int getDistanceX()
    + void setDistanceY()
    + int getDistanceY()
}

interface IReadOnlyDummyPacket {
    + int getDistanceX()
    + int getDistanceY()
}

DummySensor <|-- SystemComponent
DummySensor *-- DummyPacket
DummyPacket <-- IReadOnlyDummyPacket

VirtualFunctionBus <|-- GameBase
VirtualFunctionBus *-- "many" SystemComponent
VirtualFunctionBus *-- "1" IReadOnlyDummyPacket

header
DummySensor class diagram
endheader
@enduml
```
-->
<p><img src="plantuml/dummy_sensor_class.svg" alt="" /></p>
<!--
```plantuml
@startuml
    interface ReactiveObject {
    }
    note right: This is required to update the View in the MVVM model.\nRaiseAndSetIfChanged() method must be used in the setters.

    class World << (S, #FF7700) Singleton >> {
        - int width
        - int height
        - WorldObject[] worldObjects
        - AutomatedCar controlledCar
        + int getWidth()
        + void setWidth()
        + int getHeight()
        + void setHeight()
        + void addObject()
        + AutomatedCar getControlledCar()
        + void setControlledCar()
    }

    abstract class WorldObject {
        - int x
        - int y
        - int zIndex
        - string filename
        + int getX()
        + void setX()
        + int getY()
        + void setY()
        + string getFilename()
        + void setFilename()
    }

    class Car {
        - int speed
        + int getSpeed()
        + void setSpeed()
    }

    class AutomatedCar {
        - VirtualFunctionBus virtualFunctionBus
        - DummySensor dummySensor
        + VirtualFunctionBus getVirtualFunctionBus()
        + void Start()
        + void Stop()
    }

    AutomatedCar <|-- Car
    Car <|-- WorldObject
    WorldObject <|-- ReactiveObject
    World *-- "many" WorldObject

header
AutomatedCar class diagram
endheader
@enduml
```
-->
<p><img src="plantuml/automatedcar_class.svg" alt="" /></p>
<h2 id="megjelenítés"><a class="header" href="#megjelenítés">Megjelenítés</a></h2>
<p>Az elkészítendő szoftver felhasználói felületének az alábbi vázlat felépítését kell követnie.</p>
<p><img src="images/gui_plan.png" alt="gui plan" /></p>
<p>A programablak bal oldalán a virtuális világ egy szeletét látjuk ezért felel a vizualizációs modul. A megjelenítés középpontja az mindenkor vezérelt autó (egocar). A világ minden eleméhez tartozik egy képfájl, ezen elemek megfelelő transzformációk (forgatás, skálázás) végrehajtása után kirajzolásra kerülne a CourseDisplayre.</p>
<p>Továbbá erre a részre kerülnek kirajzolásra a debuggoláshoz és teszteléshez használandó segédobjektumok opcionálisan bekapcsolható megjelenítése. Ide tartozik a szenzorok látómezeje, a világobjektumok „poligon váza”, valamint utóbbiak eseményre történő kiemelésének lehetősége.</p>
<p>A jobb oldalon a műszerfal található. A műszerfalon nincsenek vezérlőelemek, csak megjelenítés. Az összes kapcsoló a billentyűzettel állítható, a grafikus elemeknek nem kell pl. egérrel kapcsolhatónak lenniük.</p>
<p>A fordulatszám és a sebesség legyen egy analóg órával reprezentálva; a kormány elforgatás, a gáz- és fékpedál állása progressbar-okkal szemléltethető. Az irányjelző visszajelzője és a vezetéstámogató funkciók visszajelzői lámpaszerűek, a sebességváltó állása, és a debug értékek pl. kocsi pozíciója (x, y koordináta) lehet szöveges.
A buszon közölt „utoljára látott tábla” képét ki kell tudni rajzolni (a képek rendelkezésre állnak). Legyen elkülönítve a nincs tábla eset is.</p>
<p>A megjelenítéshez tetszőleges grafikus keretrendszer választható, alább a skeleton két változatban kerül bemutatásra.</p>
<h2 id="wpf-alapú-megjelenítés"><a class="header" href="#wpf-alapú-megjelenítés">WPF alapú megjelenítés</a></h2>
<p>Az ismert WPF alapú implementáció, amely egyenértékű a később taglalt Avalonia alapú megoldással. Mindkettő XAML alapú, MVVM modellű keretrendszer, előbbi Windows-os, utóbbi platform független.</p>
<p>A főablak két UserControlt tartalmaz, az egyik a CourseDisplay, a másik a Dashboard, azért lettek szétválasztva, hogy a két komponensen dolgozó csapatoknak ne kelljen egymás munkájába nyúlkálniuk.</p>
<p>Például, alább látható a műszerfal, amely egy <em>AutomatedCar</em> objektum megjelenítését végzi. Egészen pontosan a <em>World</em>-ben tárolt <code>controlledCar</code> objektumét. A <code>ControlledCar</code> tulajdonság egy referencia az éppen vezérelt autóra (elvben lehetne a világban több <code>AutomatedCar</code> példány és ezek között váltogathatnánk is. Ilyen esetben a <code>ControlledCar</code> mindeg az aktuálisra mutat, amelyet meg akarunk jeleníteni). A <em>DashboardView</em> a <em>DashboardViewModel</em>-en keresztül a <code>controlledCar</code>-hoz van kötve.</p>
<pre><code class="language-xml">&lt;ContentControl Name="Dashboard" Content="{Binding World.ControlledCar, Mode=OneWay}" &gt;
    &lt;ContentControl.ContentTemplate&gt;
        &lt;DataTemplate DataType="{x:Type models:AutomatedCar}"&gt;
            &lt;StackPanel&gt;
                ...
            &lt;/StackPanel&gt;
        &lt;/DataTemplate&gt;
    &lt;/ContentControl.ContentTemplate&gt;
&lt;/ContentControl&gt;
</code></pre>
<p>A példakód ezt biztosítja, a feladat a konkrét visszajelzőkhöz megfelelő felületi elemek definiálása.</p>
<h3 id="coursedisplay"><a class="header" href="#coursedisplay">CourseDisplay</a></h3>
<p>A teljes CourseDisplay lényegében egy <em>ItemsControl</em>, amely a világ <code>WorldObjects</code> tulajdonságához van kötve. Ezen belül található egy <em>Canvas</em>, amire a rajzolás történik, valamint egy <em>DataTemplate</em>, amely azt írja le, hogy egy <em>WorldObject</em> típusú objektumok hogyan kell kezelni. A világelemhez tartozó képet kell kirajzolni, így tartalmaz egy <em>Image</em>-et, amelynek forrása a <em>WorldObject</em> <code>Filename</code> tulajdonsága. A <em>Converter</em> attribútumon keresztül meg lehet hívni egy függvényt, amellyel akár befolyásolni lehet a rajzolást (transzformálás).</p>
<p>A <em>WorldObject</em> -az alkalmazás szempontjából- a világ minden elemének őse, de ennél specializáltabban is lehet definiálni <em>template</em>-eket. Az alábbi kódrészlet szétbontja <em>Circle</em> és <em>AutomatedCar</em> típusokra, előbbihez nem is képet tölt be, hanem közvetlenül rajzol a <em>Canvas</em>-re. Az utóbbi esetben egyrészt a fentivel megegyező módon betölt egy képet, valamit arra kirajzol egy poligont (ez a debug funkcióknál kell majd).</p>
<pre><code class="language-xml">&lt;ItemsControl Name="CourseDisplay"
    ItemsSource="{Binding WorldObjects, Mode=OneWay}"
    Width="{Binding Width, Mode=OneWay}"
    Height="{Binding Height, Mode=OneWay}"
    HorizontalAlignment="Left" VerticalAlignment="Top"
    &gt;

     &lt;ItemsControl.ItemContainerStyle&gt;
        &lt;Style TargetType="ContentPresenter"&gt;
            &lt;Setter Property="Canvas.Left" Value="{Binding X}"/&gt;
            &lt;Setter Property="Canvas.Top" Value="{Binding Y}"/&gt;
            &lt;Setter Property="Canvas.ZIndex" Value="{Binding ZIndex}"/&gt;
        &lt;/Style&gt;
    &lt;/ItemsControl.ItemContainerStyle&gt;

    &lt;ItemsControl.ItemsPanel&gt;
        &lt;ItemsPanelTemplate&gt;
            &lt;Canvas /&gt;
        &lt;/ItemsPanelTemplate&gt;
    &lt;/ItemsControl.ItemsPanel&gt;

    &lt;ItemsControl.Resources&gt;
        &lt;DataTemplate DataType="{x:Type models:Circle}"&gt;
            &lt;Canvas&gt;
                &lt;Ellipse Fill="black" Width="{Binding Width}" Height="{Binding Height}" Panel.ZIndex="10"/&gt;
            &lt;/Canvas&gt;
        &lt;/DataTemplate&gt;
        &lt;DataTemplate DataType="{x:Type models:AutomatedCar}"&gt;
            &lt;Canvas&gt;
                &lt;Image Width="{Binding Width}" Height="{Binding Height}"
                    Source="{Binding Filename, Converter={x:Static visualization:WorldObjectTransformer.Instance}}"/&gt;
                &lt;Polyline Stroke="red" Points="{Binding Geometry.Points, Mode=OneWay}" /&gt;
            &lt;/Canvas&gt;
        &lt;/DataTemplate&gt;
    &lt;/ItemsControl.Resources&gt;
&lt;/ItemsControl&gt;
</code></pre>
<p>A skeletonban esetben az objektum nem a képet tárolja, hanem a képfájl nevét (<code>Filename</code>, ez van a Source-hoz kötve), a fájlnévből pedig egy konverter segítségével kap a megjelenítés képet.</p>
<p>Ráadásul nem is tölti be minden esetben a képfájlokat, hanem gyorsító-tárazza azokat fájlnév alapján egy <code>Dictionary</code> segítségével. A <code>WorldObjectTransformer</code> singleton, hogy ez a mechanizmus megfelelően működhessen.</p>
<pre><code class="language-csharp">public class WorldObjectTransformer : IValueConverter
{
    private static Dictionary&lt;string, BitmapImage&gt; cache = new Dictionary&lt;string, BitmapImage&gt;();

    public static WorldObjectTransformer Instance { get; } = new WorldObjectTransformer();

    static BitmapImage GetCachedImage(string filename)
    {
        if (!cache.ContainsKey(filename))
        {
            var image = new BitmapImage(new Uri($"src/AutomatedCar/Assets/WorldObjects/{filename}", UriKind.Relative));
            image.Freeze();
            cache.Add(filename, image);
        }
        return cache[filename];
    }

    public object Convert(object value, Type targetType, object parameter, CultureInfo culture) =&gt;
        GetCachedImage((string)value);
}
</code></pre>
<p>Megfigyelhető továbbá, hogy az AutomatedCar template esetében nem csak a kép van kirajzolva, hanem egy poligon ez, ez az objektum poligon váza, amelyet pl. ütközésekhez kell majd felhasználni. Előbb a kép, majd rá a polyline kerül kirajzolásra. Az ilyen poligonok megjelenítése debug funkciókét a megjelenítés feladata. A rajzolás pedig egy logikai értékhez kapcsolható...</p>
<h4 id="pozicionálás"><a class="header" href="#pozicionálás">Pozicionálás</a></h4>
<p>Megfigyelhető, hogy  a fenti példán, hogy a <code>ItemsControl.ItemContainerStyle</code> rendelkezik az objektumok pozíciójáról. Ezt CSS-szerűen működő stílusokkal lehet megadni. Az ItemsControl elemei (a WorldObject-ek) <em>X</em>, <em>Y</em> és <em>ZIndex</em> tulajdonságához van kötve a <code>ContentPresenter</code> <em>Canvas</em> <em>Left</em>, <em>Top</em> és <em>ZIndex</em> attribútuma.</p>
<p>Az alábbi ábrán látható a futó alkalmazás: bal oldalt a kezdetleges CourseDisplay, jobb oldalt a kezdetleges Dashboard. Az autó az <code>(50, 50)</code> pozícióba van kirajzolva, a kör a <code>(400, 200)</code> koordinátákra (bal felső sarokkal értendő) ezek különbségét pedig kiszámolta a <em>DummySensor</em> és leolvasható a műszerfalról.</p>
<p><img src="images/avalonia_skeleton.png" alt="" /></p>
<h2 id="avalonia-alapú-megjelenítés"><a class="header" href="#avalonia-alapú-megjelenítés">Avalonia alapú megjelenítés</a></h2>
<p>Az <a href="http://avaloniaui.net/"><em>Avalonia</em> keretrendszer</a> által is használt <a href="http://avaloniaui.net/docs/quickstart/mvvm">MVVM modell</a>ben az objektumokhoz tartozik egy definiált a megjelenítés.</p>
<p><img src="http://avaloniaui.net/docs/quickstart/images/mvvm.png" alt="" /></p>
<p>Jelen esetben például a műszerfal egy <em>AutomatedCar</em> objektum megjelenítése. Egészen pontosan a <em>World</em>-ben tárolt <code>controlledCar</code> objektumé. A <em>DashboardView</em> a <em>DashboardViewModel</em>-en keresztül a <code>controlledCar</code>-hoz van kötve.</p>
<pre><code class="language-xml">&lt;ContentControl Name="Dashboard" Content="{Binding World.ControlledCar, Mode=OneWay}" &gt;
    &lt;ContentControl.ContentTemplate&gt;
        &lt;DataTemplate DataType="{x:Type models:AutomatedCar}"&gt;
            &lt;StackPanel&gt;
                ...
            &lt;/StackPanel&gt;
        &lt;/DataTemplate&gt;
    &lt;/ContentControl.ContentTemplate&gt;
&lt;/ContentControl&gt;
</code></pre>
<p>A példakód ezt biztosítja, a feladat a konkrét visszajelzőkhöz megfelelő felületi elemek definiálása.</p>
<h3 id="coursedisplay-1"><a class="header" href="#coursedisplay-1">CourseDisplay</a></h3>
<p>A teljes CourseDisplay lényegében egy <em>ItemsControl</em>, amely a világ <code>WorldObjects</code> tulajdonságához van kötve. Ezen belül található egy <em>Canvas</em>, amire a rajzolás történik, valamint egy <em>DataTemplate</em>, amely azt írja le, hogy egy <em>WorldObject</em> típusú objektumok hogyan kell kezelni. A világelemhez tartozó képet kell kirajzolni, így tartalmaz egy <em>Image</em>-et, amelynek forrása a <em>WorldObject</em> <code>Filename</code> tulajdonsága. A <em>Converter</em> attribútumon keresztül meg lehet hívni egy függvényt, amellyel befolyásolni lehet a rajzolást (transzformálás).</p>
<pre><code class="language-xml">&lt;ItemsControl Name="CourseDisplay"
    DataContext="{Binding World, Mode=OneWay}"
    Items="{Binding WorldObjects, Mode=OneWay}"
    Width="{Binding Width, Mode=OneWay}"
    Height="{Binding Height, Mode=OneWay}"
    HorizontalAlignment="Left" VerticalAlignment="Top"
    &gt;

    &lt;ItemsControl.ItemsPanel&gt;
        &lt;ItemsPanelTemplate&gt;
            &lt;Canvas/&gt;
        &lt;/ItemsPanelTemplate&gt;
    &lt;/ItemsControl.ItemsPanel&gt;

    &lt;ItemsControl.DataTemplates&gt;
        &lt;DataTemplate DataType="{x:Type models:WorldObject}"&gt;
            &lt;Image Width="{Binding Width}" Height="{Binding Height}"
                Source="{Binding Filename, Converter={x:Static visualization:WorldObjectTransformer.Instance}}"/&gt;
        &lt;/DataTemplate&gt;
    &lt;/ItemsControl.DataTemplates&gt;
&lt;/ItemsControl&gt;
</code></pre>
<p>A <em>WorldObject</em> -az alkalmazás szempontjából- a világ minden elemének őse, de ennél specializáltabban is lehet definiálni <em>template</em>-eket. Az alábbi kódrészlet szétbontja <em>Circle</em> és <em>AutomatedCar</em> típusokra, előbbihez nem is képet tölt be, hanem közvetlenül rajzol a <em>Canvas</em>-re. Az utóbbi esetben egyrészt a fentivel megegyező módon betölt egy képet, valamit arra kirajzol egy poligont (ez a debug funkcióknál kell majd).</p>
<pre><code class="language-xml">&lt;ItemsControl.DataTemplates&gt;
    &lt;DataTemplate DataType="{x:Type models:Circle}"&gt;
        &lt;Canvas&gt;
            &lt;Ellipse Fill="black" Width="{Binding Width}" Height="{Binding Height}" ZIndex="10"/&gt;
        &lt;/Canvas&gt;
    &lt;/DataTemplate&gt;
    &lt;DataTemplate DataType="{x:Type models:AutomatedCar}"&gt;
        &lt;Canvas&gt;
            &lt;Image Width="{Binding Width}" Height="{Binding Height}"
                Source="{Binding Filename, Converter={x:Static visualization:WorldObjectTransformer.Instance}}"/&gt;
            &lt;Polyline Stroke="{Binding Brush, Mode=OneWay}" Points="{Binding Geometry.Points, Mode=OneWay}" /&gt;
        &lt;/Canvas&gt;
    &lt;/DataTemplate&gt;
&lt;/ItemsControl.DataTemplates&gt;
</code></pre>
<h4 id="pozicionálás-1"><a class="header" href="#pozicionálás-1">Pozicionálás</a></h4>
<p>Megfigyelhető, hogy  a fenti példák nem rendelkeznek az objektumok pozíciójáról. Ezt CSS-szerűen működő stílusokkal lehet megadni. Az alábbi példa beszínezi zöldre a <em>CourseDisplay</em>-t, valamint a <em>WorldObject</em>-ek <em>Left</em> és <em>Top</em> értékeit beállítja a <em>WorldObject</em> X és Y értének megfelelően.</p>
<pre><code class="language-xml">&lt;UserControl.Styles&gt;
    &lt;Style Selector="ItemsControl#CourseDisplay"&gt;
        &lt;Setter Property="Background" Value="#97D1A2"/&gt;
    &lt;/Style&gt;
    &lt;Style Selector="ItemsControl#CourseDisplay &gt; ContentPresenter"&gt;
        &lt;Setter Property="Canvas.Left" Value="{Binding X, Mode=OneWay}"/&gt;
        &lt;Setter Property="Canvas.Top" Value="{Binding Y, Mode=OneWay}"/&gt;
        &lt;Setter Property="ZIndex" Value="{Binding ZIndex, Mode=OneWay}"/&gt;
    &lt;/Style&gt;
&lt;/UserControl.Styles&gt;
</code></pre>
<p>Az utóbbi verziót használva az alábbi ábrán látható a futó alkalmazás: bal oldalt a kezdetleges CourseDisplay, jobb oldalt a kezdetleges Dashboard. Az autó az <code>(50, 50)</code> pozícióba van kirajzolva, a kör a <code>(400, 200)</code> koordinátákra (bal felső sarokkal értendő) ezek különbségét pedig kiszámolta a <em>DummySensor</em> és leolvasható a műszerfalról.</p>
<p><img src="images/avalonia_skeleton.png" alt="" /></p>
<h4 id="forgatás"><a class="header" href="#forgatás">Forgatás</a></h4>
<p>Az autó forgatása is a pozicionáláshoz hasonló elven történik. Az alábbi példában közvetlenül az egyes elem Canvas-ához csatoljuk a transzformációs utasításokat. Ez azzal is jár, hogy egyszerre lehet transzformálni a képet és a poligont is. Több transzformáció esetén fontos a <code>TransformGroup</code> használata. Például forgatás (szögben) az elem egy változójához kötve. Valamint egy X,Y eltolás az előbbi példában.</p>
<pre><code class="language-xml">&lt;DataTemplate DataType="{x:Type models:AutomatedCar}"&gt;
    &lt;Canvas&gt;
        &lt;Canvas.RenderTransform&gt;
            &lt;TransformGroup&gt;
                &lt;RotateTransform Angle="{Binding Angle}" /&gt;
                &lt;TranslateTransform  X="54" /&gt;
                &lt;TranslateTransform  Y="120" /&gt;
            &lt;/TransformGroup&gt;
        &lt;/Canvas.RenderTransform&gt;
        &lt;Image Source="{Binding Filename, Converter={x:Static visualization:WorldObjectTransformer.Instance}}"/&gt;
        &lt;Polyline Stroke="{Binding Brush, Mode=OneWay}" Points="{Binding Geometry.Points, Mode=OneWay}" /&gt;
    &lt;/Canvas&gt;
&lt;/DataTemplate&gt;
</code></pre>
<p><img src="images/rotate.png" alt="" /></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="context-cards.js"></script>
        <script src="mermaid-init.js"></script>
        <script src="mermaid.min.js"></script>
        <script src="d3.5.16.0.js"></script>
        <script src="markmap-lib.transform.min.js"></script>
        <script src="markmap-lib.view.min.js"></script>
        <script src="markmap-init.js"></script>
        <script src="quizdown/quizdown.js"></script>
        <script src="quizdown/quizdown-init.js"></script>

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
